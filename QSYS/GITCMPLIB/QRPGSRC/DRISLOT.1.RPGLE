500gA /COPY *libl/qcopysrc,hspecs

     *----------------------------------------------------------------
     *   Copyright (C) 2002 BFC Software, Inc. - All Rights Reserved
     *   BFC Software, Inc.
     *   799 Roosevelt Rd.  Bldg 6, Suite 108
     *   Glen Ellyn, IL  60137
     *   (708) 790-8383
     *----------------------------------------------------------------
     *
     *  DRISLOT     Dakota realtime interface - Slot maintenance
     *  10 October 2001
     *  Dave Sommerville
     *
416  *    10/10/01  DAS  4.16
     *      - Created
     *
416aA*    10/29/01  DAS  4.16a
     *      - Revised UPDSTOCK routine to update SLREC2 instead of SLREC.
     *      - Revised UPDSTOCK routine to recalculate qtys at the end.
     *
416bA*    11/21/01  DAS  4.16b
     *      - Added subcommand *NXTOVRF, *PRVOVRF, *NXTPICK, *PRVPICK,
     *        *NXTSLOT, *PRVSLOT, *NXTSLOTI, *PRVSLOTI, *NXTITEM, *PRVITEM.
     *
416cA*    11/26/01  DAS  4.16c
     *      - Added subcommand *UPDQTY.
     *      - Added logging.
     *
416dA*    12/04/01  DAS  4.16d
     *      - Added routine *VERIFYQTY.
     *      - Added subcommands *ADJALC, *ADJPCK, *ADJSTK, *ADJPCKSTK,
     *        *ADJUST, *ADJUSTORD and *ALC2PCK.
     *
416eA*    01/11/02  DAS  4.16e
     *      - Added subcommand *SEQPTYRPL.
     *      - Revised routine crtprtyrpl to use *CRTRPLSEQ instead of
     *        *CRTRPL. New code will automatically assign sequence
     *        number to Priority Replenishment.
     *      - Added call to crtprtyrpl at end of qtypick routine.
     *
416eA*    01/23/02  DAS  4.16f
     *      - Implemented logging.
     *
416g *    01/24/02  DAS  4.16g
     *      - Moved getting record for change from changerec routine
     *        into verifychg routine.
     *
416h *    01/23/02  DAS  4.16h
     *      - Revised to identify if called from Dakota.
     *      - Revised to call DRIMAIN2 to update the host when called
     *        from Dakota. This allows the Dakota program to only have
     *        to make a single call to the interface.
     *
416i *    01/23/02  DAS  4.16i
     *      - Remove *UPDSTOCK, not used anymore.
     *      - Added special code *NOUPDATE* that is sent from a
     *        Dakota program in the $preturn field. See notes below.
     *      - Added *ADDVS for creating virtual slots.
     *      - Replaced VFYDESG with DRIDESIG.
     *      - Replaced VFYDEPT with DRIDEPT.
     *      - Added verification logic to verifyqty, qtytfrout,
     *        qtyclstfrout,
     *      - Added command *VERIFYTFO, *SET2VFY.
     *
416j *    02/09/02  DAS  4.16j
     *      - Added *CRTXDOCK for creating crossdock slot.
     *      - Added *GETXDOCK to get crossdock slot for item.
     *      - Added routines crtxdock, getxdock and verifygetxdk.
     *
416k *    02/16/02  DAS  4.16k
     *      - Revised deleteslot routine to use slot2 for *VERIFYDEL.
     *
416l *    02/25/02  DAS  4.16l
     *      - Revised crtprtyrpl routine to use set $prfill to 'Y'.
     *
416m *    02/28/02  DAS  4.16m
     *      - Revised changeslot by replacing calls to ADJQTY
     *        with calls to DRIITEMQTY.
     *      - Revised verifychg to initialize #slot fields.
     *      - Revised verifychg to only do active pick slot check when
     *        the status code is being changed to 'A'.
     *      - Revised divide by zero errors with catch weights.
     *
416n *    03/08/02  DAS  4.16n
     *      - Added *CHGITEM/*VFYCHGITM subcommands.
     *
416o *    04/19/02  DAS  4.16o
     *      - Added subcommand *VERIFYTFI.
     *
416p *    05/21/02  DAS  4.16p
     *      - Revised routine SHIFTSSBQTY to shift quantity fields if
     *        sent item is a type 'S'. A normal quantity sent in is
     *        shifted into a breakdown 1 quantity for the update.
     *      - Revised routine VERIFYQTY to get SSB item for the
     *        slot item and not the sent item.
     *      - Revised routine VERIFYQTY to call new routine.
     *      - Revised routine mainline to call new routine after
     *        call SAVEBEFORE routine. This routine restores the
     *        original values that were sent in, thus undoing the
     *        shift done from the VERIFYQTY routine.
     *
416q *    06/10/02  DAS  4.16q
     *      - Recompiled because $salic#/$iqlic# changed from 7.0 to 15.
     *
416r *    07/18/02  DAS  4.16r
     *      - Added *NXTPICKAV to get next pick slot with avail qty.
     *      - Revised slot2ds to get base slot for *GET, *NXT and *PRV
     *        operations. Base slot is put into $slcdsp. For non-virtual
     *        slots it is set to $sldisp.
     *
416s *    08/28/02  DAS  4.16s
     *      - Revised fixbrkdn routine to use #slotumq fields instead of
     *        $itumq fields.
     *
416t *    10/07/02  DAS  4.16t
     *      - Revised VERIFYNXTPRV routine to set $slprty to -9 when
     *        not sent for *NXTPICKAV.
     *
416u *    04/10/03  DAS  4.16u
     *      - Revised VERIFYCHG to not allow status to be changed to 'V'.
     *        Re: Slots must be verified through the verification program
     *            so corresonding records get deleted.
     *      - Added subcommand *ADJUSTTFR. It is only passed through to the
     *        host. No local files are updated by it. Re: When changing
     *        an item number during a transfer, adjustment records are made
     *        but the slot quantities are changed using the TFRIN/OUT
     *        subcommands. However, we want the host system to be able to
     *        just look at ADJUST commands to keep warehouse quantities
     *        in synch.
     *
417  *    05/02/03  DAS  4.17
     *      - Revised QTYRECEIVE routine to change priority to 0 if the
     *        slot is a reserved pick slot.
     *      - VERIFYRCVM was skipping the get record logic even when we
     *        were not doing just a verify.
     *
417a *    06/07/03  DAS  4.17a
     *      - Added subcommands *GETCHKV, *GETICHKV, *NXTVSLOT and
     *        *PRVVSLOT.
     *      - Added routine openvslot2.
     *      - Revised routine look4slot to call routine openvslot2.
     *
417b *    07/18/03  DAS  4.17b
     *      - Revised check for virtual for *NXT and *PRV.
     *
417c *    09/18/03  DAS  4.17c
     *      - Added subcommand *ZEROVFY.
     *      - Added *ZEROVFY data structure.
     *      - Added files SPCLORD, VSLEXCP, CROSSDK.
     *      - Added routines zerovfy, deletespclord, deletecrossdk,
     *        deletevlsexcp, openspclord, opencrossdk, openvlsexcp,
     *        and openvslot2.
     *      - Revised routine set2vfy to update slrec2 and to be used
     *        by *ZEROVFY and to set status to 'V'.
     *      - Revised routine deleteslot to delete associated records
     *        and to be used by *ZEROVFY.
     *
417d *    09/29/03  DAS  4.17d
     *      - Fields added to C#SLOT, version 6.
     *      - Brought CLEARERRFLAGS routine up to date.
     *      - Revised Transfer Out/In to handle an item change.
     *
417e *    10/03/03  DAS  4.17e
     *      - Field added to C#SLOT, version 7.
     *      - Revised to send back check digit with slot information.
     *
417f *    10/16/03  DAS  4.17f
     *      - Added *TFRINCHG, *TFROUTCHG, *VFYTFICHG, *VFYTFOCHG,
     *        *CLSTFICHG and *CLSTFOCHG.
     *        These commands take into account that the item may change and
     *        because of this, the IN qty may have to be converted.
     *
417g *    10/17/03  DAS  4.17g
     *      - Added *NXTOVRFAV to get next overflow slot with avail qty.
     *
417h *    10/31/03  DAS  4.17h
     *      - Added commands specific for Returns. Letdowns, Specific Slot
     *        Replenishments and Priority Replenishments. This was done
     *        1) to provide more informative commands that can be viewed in
     *        the log and 2) because entered/expirations date logic needs
     *        to know what type of transaction is being performed.
     *
417i *    11/03/03  DAS  4.17i
     *      - Created routines setentdate, setexpdate, setpriority
     *        and setstatus. The date routines use the new date
     *        options.
     *      - Revised routines qtyclsrcv and qtyreceive to call new
     *        routines.
     *
417j *    11/11/03  DAS  4.17j
     *      - Added more error checking logic to VERIFYRCVM.
     *      - Revised LOOK4SLOT to see if exp dates are the same.
     *
417k *    11/16/03  DAS  4.17k
     *      - Revised NEXTPREV routine by moving call to slot2ds after
     *        the qtys are checked.
     *
417l *    11/20/03  DAS  4.17l
     *      - Revised NEXTPREV routine to do setll first.
     *
417o *    04/07/04  MLB  4.17o
     *      - Fix: Revised VerifyChg to not allow RSRV field to be
     *        changed to V=Virtual slot.
     *
417p *    04/07/04  DAS  4.17p
     *      - Fix: Revised WRITEADJ routine to use SSB item number
     *        when writing SSB adjustment record.
     *
417q *    05/27/04  DAS  4.17q
     *      - Fix: Revised look4slot to initializ error field.
     *
417r *    06/08/04  DAS  4.17r
     *      - Fix: Revised to call checkstat before setentdate.
     *        Re: checkstat was overwriting entered date.
     *
417s *    10/07/04  DAS  4.17s
     *      - Enh: Added command *CLSRCVADJ to receive qty and
     *        create adjustment record.
     *
500  *    11/05/04  DAS  5.00
     *      - Added *NXTITEMAV to get next item slot with avail qty.
     *      - Added *GETITEMAV to get next item slot with avail qty.
     *
500a *    09/09/04  DAS  5.00a (was 4.17s in PIRVOICE)
     *      - Enh: Added *GETOVRFAV'
     *
500b *    11/05/04  DAS  5.00b
     *      - Added *GETITEMAV to get next item slot with avail qty.
     *      - Removed some 5.00a code from NXTPREV routine.
     *
500c *    11/17/04  DAS  5.00c
     *      - Revised to handle Alias items when adjusting quantities.
     *
500dA*    12/17/04  DAS  5.00d
     *      - Fix: Removed check for negative avail whse qty.
     *
500eA*    01/26/05  DAS  5.00e
     *      - Fix: For *NXT if priority is 0, set to -9.
     *
500eA*    01/27/05  DAS  5.00e
     *      - Enh: Added commands *VERIFYPUT and *VERIFYRTN.
     *cur   - Reserved
     *
501eA*    01/27/05  DAS  5.01e
     *      - Enh: Added C#SLOT field $SASLPOS (slot position).
     *
500fA*    01/28/05  DAS  5.00f
     *      - Enh: Added putaway check that a virtual slot cannot
     *        be sent in.
     *cur   - Second part not added to this version.
     *
501fA*    01/28/05  DAS  5.01f
     *      - Enh: Added putaway warning of item going into pick slot.
     *
500gA*    01/29/05  DAS  5.00g
     *cur   - Reserved
     *      - Enh: Added logic to take slot position into account when
     *        seeing if item is in same slot.
     *      - Enh: Added logic to take into account license tracking when
     *        determining if a virtual slot needs to be created.
     *
500hA*    02/06/05  DAS  5.00h
     *      - Enh: Revised to not do Host call. Re: No one currently using
     *        it. Not calling host will cut down on log records.
     *
500iA*    02/09/05  DAS  5.00i
     *curr  - Reserved
     *      - Enh: Added subcommands *STUFFIT and *VERIFYSI
     *
500jA*    02/10/05  DAS  5.00j
     *curr  - Reserved
     *      - Enh: Added *VFYCLS... subcommands.
     *      - Enh: Removed some *VFY checks in QTYCLSRCV and
     *        QTYRECEIVE routines because they weren't needed.
     *
500kA*    04/08/05  DAS  5.00k
     *cur   - Added command *CRTVPICK.
     *cur   - Added routines CRTVPICK and VFYCRTVPICK
     *cur   - Revised routine VERIFYPICK to user $saitem instead of slitem.
     *      - Revised when the warehouse qty is updated for PR repl, SS
     *        repl and transfers. Now program will only update warehouse
     *        qty when the item is being changed. Re: Before this change,
     *        the 'In' qty would update the whse stock bucket and the 'Out'
     *        qty would update the whse allocate bucket. Although the avail
     *        qty would correctly show what was in the warehouse, the stock
     *        qty would be inflated for a period of time, giving a false
     *        impression of the physical stock quantity in the warehouse.
     *
500lA*    05/08/05  DAS  5.00l
     *      - Enh: Revised program to add support for Client id
     *
500mA*    05/10/05  DAS  5.00m
     *      - Revised routin QTYTFROUT to not check for negative avial qty
     *        when called from LT107. Re: LT108 has already put qty in tfr
     *        bucket.
     *      - Removed virtual slot check from VERIFYRCVM.
     *
500nA*    02/22/05  DAS  5.00n  *Note: Was 5.00k at BFC-IL.
     *      - Added command *CRTVPICK.
     *      - Added routines CRTVPICK and VFYCRTVPICK
     *      - Revised routine VERIFYPICK to user $saitem instead of slitem.
     *
500oA*    04/13/05  MLB  5.00o
     *      - Fix: Revise program to set error indicator for fields
     *        to '1' instead of file field names.
     *
500pA*    04/13/05  DAS  5.00p
     *      - Fix: Revised to convert Original qtys for some CHG commands.
     *      - Fix: VFYCLSTFO/VFYCLSTOC and similar commands missing
     *        from an IF statement.
     *
500qA*    04/19/05  DAS  5.00q
     *      - Revised routine VERIFYPICK to use #SLOTITEM.
     *      - Revised VFYCRTVPICK to get slot definition.
     *      - Revised to use #slotitem instead of $saitem in some spots.
     *
500rA*    04/25/05  DAS  5.00r
     *      - Revised routines qtyclrrcv and qtyreceive to not check for
     *        negative avail qty when sending in a negative qty. This was
     *        causing problems when Pick slots were allowed to go negative.
     *
500sA*    04/26/05  DAS  5.00s
     *      - Revised routine verifyqty to not skip initializing #from/#to
     *        fields if the sent and corresponding item #'s are the same.
     *      - Revised routine verifypick to check for "IN" commands instead
     *        of "OUT" commands.
     *
500tA*    05/04/05  DAS  5.00t
     *      - Added *VFYCLS_ checks to CRTVIRTUAL and VERIFYRCVM.
     *
500uA*    05/10/05  DAS  5.00u
     *      - Revised VERIFYPICK routine to close hole for transfers and
     *        instead call new program CNTPICKTFR.
     *
500vA*    05/31/05  DAS  5.00v
     *      - Revised CHECKSLOTPOS set sameslotpos on when $saslpos is
     *        not sent. Re: Programs like IT276 don't send in $saslpos
     *        because we are putting the item into that specific slot/pos.
     *
500wA*    07/06/05  DAS  5.00w
     *      - Revised VERIFYQTYADJ to create a "low" value for newavlqty
     *        to be used in checking for a negative avail qty.
     *
500xA*    08/04/05  DAS  5.00x
     *      - Added commands *STAGEPUT, *CLSSTGPUT and *VFYSTGPUT.
     *        These the same as *PUTAWAY, *CLSPUTAWY and *VERIFYPUT,
     *        excpet that we force the MANUALPUTAWAY flag on.
     *
510aA*    06/06/06  DAS  5.10a
     *      - Revised to call UPDSLTDTE to update the slot date recs.
510bA*    07/13/06  RH   5.10b
     *      - FIX: Was getting error if all hand stack's were used for
     *        virtual slots.
510cA*    09/27/06  RAH  5.10c
     *      - Revised to load the date and time to $sadate and $satime
     *        for so this date/time can be returned in parm list and
     *        used in other programs.
510dA*    02/24/07  DAS  5.10d
     *      - Added commands *CRTREPAKR, *CRTREPAKP, GETREPACK.
510eA*cur 02/24/07  DAS  5.10e
     *cur   - Added some 500g changes into look4slot. Marked 500g.
510fA*    03/05/07  DAS  5.10f
     *      - Revised verifyqtyadj routine to compare "low" qtys
     *        instead of individual qtys.
510gA*    04/14/07  MLB  5.10g
     *      - FIX: Revised VERIFYCHG routine to increment VOCOUNT by
     *        1 to include new pick slot when current status <> 'A '
     *        or item number is changing.
510hA*    12/11/07  DAS  5.10h
     *      - Revised changeslot routine to only recalculate
     *        slside when slloc changes.
520aA*    12/05/08  DAS  5.20a  (not used in ver 6.00)
     *      - Revised addslot routine to call updsltdte when
     *        expiration date changes.
520bA*    12/05/08  RH   5.20b  (not used in ver 6.00)
     *      - Revised changeslot routine to call updsltdte when
     *        expiration date changes.
520cA*    01/15/09  DAS  5.20c (replaced by 600x change)
     *      - Revised to use a different field to calculate low
     *        qty instead of #slotumq2/3. Re: These fields were being
     *        set to 1 if they were zero, which caused a problem in
     *        the fixbrkdn routine.
520dA*    06/11/09  MLB  5.20d
     *      - Fix: Revised routine CRTVIRTUAL to load base handstack
     *        field into work field so that base handstack is not
     *        corrupted by chain to SLOT2 in GETSLOT2 routine.
     *        This fix was required for items with handstack in base
     *        sloto and items in virtual slots.
600aA*    12/27/07  LMC  6.00a
     *      - Changes required during the merge of IT352 in pirlic510
     *        and pirenh510
600bA*    01/23/08  LMC  6.00b
     *      - Fix: *NXTPICKAV needs to have $slprty set to -9 if 0
600cA*    05/10/08  DAS  6.00c
     *      - Enh: Added support for new *VIRTUAL slot options.
     *      - New virtual pick slot option added to OP280 for
     *        C=Cstm. Now, in CRTVIRTUAL the client custom logic will
     *        only be used when the option is set to 'C'.
600dA*    10/22/08  DAS  6.00d
     *      - Added $saemp# to parms.
     *      - Added commands *RCVIN, *STGIN, *OSSIN, *USRIN, *USR2RCV,
     *        *USR2STG, *USR2OSS, *USR2RTN, *USR2PUT, *TFR2USR,
     *        *STARTUP, *FIXLCNS.
600eA*    01/19/09  DAS  6.00e
     *      - Implemented DRIMAIN3 for calling other DRI programs.
     *        Re: So calls would be logged to LOGDRI file.
600fA*    01/19/09  DAS  6.00f
     *      - Added $sacwhd, $saToVrfy, $saAction, $saETrn#, $saLbl#,
     *        $saToCode, $saToArea, $saToOrd, $saToSeq to parms.
     *      - Added calls to DRILICENSE.
600gA*    01/20/09  DAS  6.00g
     *      - Stopped writting to logslot file because I do not
     *        believe it is being used. Can restart if necessary.
600hA*    02/16/09  DAS  6.00h
     *      - Fix: Qty conversion between Normal and Breakdown item
     *        was incorrect.
600iA*    02/20/09  DAS  6.00i
     *      - Created new stuffit subroutine
     *      - Created command *STUFFDLT to delete any slots that
     *        correspond with the sent in base slot that contain
     *        the sent in item. This command was created to be sent
     *        before *STUFFIT to ensure the item is not in the slot
     *        it is being stuffed into.
600jA*    02/23/09  DAS  6.00j
     *      - Revised to allow adjustment codes that start with '@'
     *        forcing them to be Dakota only.
600kA*    02/24/09  DAS  6.00k
     *      - Added *CHKFIFO.
600lA*    03/02/09  DAS  6.00l
     *      - Revised same slot checks.
600mA*    03/02/09  DAS  6.00m
     *      - Revised getbaseslot to use sl fields instead of $sl.
600nA*    03/12/09  DAS  6.00n
     *      - Added %CRTOSS and %ADJUSTOSS, used by PO236.
600nA*    03/12/09  DAS  6.00n
     *      - Added %CRTOSS and %ADJUSTOSS, used by PO236.
600oA*    04/19/09  DAS  6.00o
     *      - Revised call to CHKSTAT to move slwhse into a packed
     *        parameter field.
600pA*    04/09/09  DAS  6.00p
     *      - Revised CRTVIRTUAL to save/restore SLREC when looking
     *        for an existing virtual slot.
600qA*    04/12/09  DAS  6.00q
     *      - Created copies of ISMISMTCH using different variables.
600rA*    04/22/09  DAS  6.00r
     *      - Revised to allow %OSSIN to have all zero qty's.
     *        Re: Current OSS method creates slots prior to pressing
     *        enter on the license entry screen.
     *      - Revised to delete license plates when deleting OSS slot.
600sA*    05/08/09  DAS  6.00s
     *      - Revised to set desg to BFC and sdef to BF for
     *        specialty slots.
600tA*    05/09/09  DAS  6.00t
     *      - Added calls to bfcphrase.
600uA*    05/13/09  DAS  6.00u
     *      - Added $sapullwhdp to c#slot, and used it within program.
600vA*    05/18/09  DAS  6.00v
     *      - Revise CRTOSS/RCV ... to clear SLHAND.
     *      - Revised vfychgitm.
600wA*    05/21/09  DAS  6.00w
     *      - Needed to allow breakdown qty's even if the item is not
     *        defined for it because Returns allows it.
     *      - Only allowed for programs RN246, RN246L and RC200.
600xA*    05/22/09  DAS  6.00x
     *      - Revised fixbrkdn to use 'original' itumq values.
     *        Re: If they are zero, they get set to 1 for other calcs,
     *            which cause the Each qty to be up'd when it should
     *            have been left alone.
600yA*    06/01/09  DAS  6.00y
     *      - Revised to call qtywhse when status codes are different.
     *      - Revised qtywhse to always work with *HOLD.
     *      - Revised to set USR slot slstat to the from slot slstat.
600zA*    06/02/09  DAS  6.00z
     *      - When transferring a qty from a USR slot, revised to
     *        update the warehouse qty for both the Out and In steps.
     *        Re: This ensures Hold qty is updated correctly and that
     *        the qty is updated correctly when changing an item.
601aA*    06/04/09  DAS  6.01a
     *      - Decommissioned UPDSLOTDTE.
     *      - Created new routine UPDSLOTFIFO.
601bA*    06/09/09  DAS  6.01b
     *      - Revised to send $pprogram instead of #pgm in drimain3.
     *      - Revised to send #slotumq2orig to DRIITEMQTY instead of
     *        #slotumq2.
601cA*    06/09/09  DAS  6.01c
     *      - Removed 600W.
     *      - Revised to allow a brkdn qty if sell-by flag is 'N'.
601dA*    06/10/09  DAS  6.01d
     *      - Added $saFrmEmpty to parms.
     *      - Revised qtyclstfrout to set $saFrmEmpty field.
     *      - Added command *GETCHKVX.
601eA*    06/10/09  DAS  6.01e
     *      - Revised deleteslot to use correct file to do delete.
601fA*    06/15/09  DAS  6.01f
     *      - Revised verifyqty to alway initialize #from/#to fields.
601gA*    06/15/09  DAS  6.01g
     *      - Revised verifyqty to set #fromitem correctly for tfr2usr.
     *      - Added #fromsitem, #tositem.
     *      - Revise tfrsltdte to use #from/#to informaiton instead
     *        of #sent/#slot information.
601hA*    06/27/09  DAS  6.01h
     *      - Revised verifyusr to not allow a USR slot to be sent.
601iA*    07/01/09  DAS  6.01i
     *      - Revised look4pull to use pull slot when getting license.
     *
610aA*    07/20/09  DAS  6.10a
     *      - Added command %ADJUSTRTN.
     *
610bA*    08/28/09  DAS  6.10b
     *      - Revised tracklcnstfr to use $saqty fields instead of
     *        inSlot.$saqty fields. Re: inSlot is a snapshot of what
     *        was sent in, but we need the $saqty's that have gone
     *        through the shiftssb routine.
     *
610cA*    08/29/09  DAS  6.10c
     *      - Revised verifyrcv routine to call verifyrcvs regardless
     *        of Directed or Manual putaway.
     *
610dA*    07/21/09  CWM  6.10d  (applied by GJA)
     *      - Added command %SETFIFO, subr SETLICFIFO and VFYSETFIFO
     *
610eA*    09/09/09  DAS  6.10e
     *      - Revised slot2ds to get more info for *GETITEMAV
     *        and *GETOVRFAV.
     *
610fA*    09/17/09  DAS  6.10f
     *      - Fix: Initialized ky fields in nextprev routine.
     *
610gA*    09/18/09  DAS  6.10g
     *      - Added *QTY2PUT / *QTY2PUT0 commands.
     *      - Added *VFYINSLOT command.
     *      - Revised VERIFYRCVM to always create virtual for
     *        sub command *QTY2PUT0, action CNT.
     *
610hA*    10/24/09  DAS  6.10h
     *      - Revised changeitem2 to work with a weight that has
     *        been sent in.
     *
610iA*    10/19/09  DAS  6.10i
     *      - Revised to use %TFRSLTREV in routine trackLcnsTfr
     *        when transfering out of a Pick slot.
     *
610jA*    10/24/09  DAS  6.10j
     *      - Removed Directed Putaway. Everything will now be Manual
     *        Putaway. Note, Receiving and RC200 still do Directed.
     *        Re: Even with Directed Putaway we need to create
     *        virtual slots for license tracking.
     *
610kA*    10/24/09  DAS  6.10k
     *      - Revised changeitem routine to call trackLcnsTfr instead
     *        of trackAdjust.
     *      - Revised how some From fields are initialized in
     *        trackLcnsTfr.
610l *    10/26/09  GJA  6.10l
     *      - Fix: SYNCLCS create new keylist, it was getting
     *        overwritten when processing expiration date.
610m *    11/25/09  DAS  6.10m
     *      - Fix: Revised routine qtystock to delete the slot record
     *        if all qty's are zero and special slot (i.e., RCV).
610n *    12/04/09  GJA  6.10n
     *      - Fix: Revised routine CHKFIFO to not look at BFC
     *        designated slots for checking FIFO order on
     *        replenishments.
530aA*    12/07/09  RH   5.30a
     *      - Add Designation code to parms for CHKSTAT.
610o *    12/12/09  DAS  6.10o
     *      - Revised routine DELETESLT to delete license for
     *        *ZEROVFY.
     *      - Revised routine SET2VFY to delete license.
     *      - Revised clr$license to set program to sent program.
610p *    12/15/09  DAS  6.10p
     *      - Revised routine updslotfifo to always use first FIFO
     *        license for overflow slots.
610q *    01/15/10  GJA  6.10q
     *      - Fix: CHKFIFO routine was not warning date sensitive
     *             items that were being selected out of FIFO
610r *    01/19/10  DAS  6.10r
     *      - Created routine updslotfifofrm to update the slot
     *        fifo info for the 'from' slot.
     *      - Created routine getfrmsltlic.
     *      - Revised program to call updslotfifofrm from routines
     *        changeitem and tfr2usr.
610s *    01/19/10  DAS  6.10s
     *      - Added command *TFR2USRR. This is identical as *TFR2USR
     *        except the trackLcnsTfr routine will use %TFRSLTREV
     *        instead of %TFRSLTDTE.
     *      - This command is used from IT252/IT352 when a transfer
     *        is made from the Pick slot and the item didn't change.
     *      - This change replaces the 610i logic.
610t *    03/24/10  JCJ  6.10t
     *      - Fix: If the status of an Overflow slot is 'RP'(Repack)
     *             do not create a new Virtual slot.
610u *    04/15/10  JCJ  6.10u
     *      - Enh: Add subcommand *GETREPACK to subroutine slot2ds.
610v *    05/17/10  DAS  6.10v
     *      - Revised getslot2usr to calculate a location value
     *        instead of always using 1.
     *
610w *    05/05/10  GJA  6.10w
     *      - Fix: Add subcommand *SETSTAT
     *
610x *    08/23/10  DAS  6.10x
     *      - Revised to allow the first handstack character to be a
     *        number. This was done in order to deal with a client
     *        (Glazier) where we needed to create a handstack with a
     *        number in order to match their current slot numbers.
     *        We will not automatically create a handstack with a
     *        number.
     *      - Revised *INZSR to create new codes.
     *      - Revised crtvirtual to work with new codes.
     *
610y *    08/26/10  JCJ  6.10y
     *      - Enh: Add $saAction to initiate new *CRTRPLODR command
     *      - when calling DRIPRTYRPL.
     *
610z *    08/27/10  DAS  6.10z
     *      - Enh: Add subcmd *CRTREPAKD to create On-Demand-Repack
     *        slot. This slot will not be in the RPK aisle and it
     *        will be assigned a status of 'A' instead of the 'RP'
     *        status of the base slot, and it will be created as a
     *        Pick slot regardless of what the base slot is.
     *
611a *    08/30/10  DAS  6.11a
     *      - Fix: Revised call to CNTPICK and CNTPICKTFR to use
     *        8-char return field.
     *
611b *    09/03/10  JCJ  6.11b
     *      - Enh: Allow stuffit program to add quantity to RP slots.
     *
611c *    09/03/10  DAS  6.11c
     *      - Fix: Revised routine stuffdlt to delete all license plates
     *        for slot instead of just the ones that matche slot/item.
     *      - Fix: Revised routine stuffdlt to call ut812 to recalculate
     *        item qty if slot qty changes. SU140 also does this, but
     *        it assumes stuffit will not change the item in the slot.
     *        However, we now allow this for status RP slots, so it
     *        was necessary to do the recalc here.
     *
611d *    09/28/10  RBD  6.11d
     *      - Fix: Setof error in subr crtxdock after coming back
     *        from getxdock ... it was dropping out of the subr
     *        after opening slot1 since the error was left on.
     *      - Fix: Moved numeric fields which are being passed
     *        to FRMTSL into work fields defined as packed,
     *        otherwise, you get dec data errors in FRMTSL
     *        because FRMTSL is expecting the fields to be packed.
     *      - Revised cross dock processing to be more generic and
     *        create slot for whatever aisle is passed in instead of
     *        hardcoded XDK.
     *
611eA*    11/01/10  RBD  6.11e
     *      - Added command *PREIN.
     *      - Added command *CRTPRE.
     *      - Added routines crtPRE, getNextLoc, and getNextLvl,
     *        and vfyCrtPre.
     *
611fA*    11/03/10  DAS  6.11f
     *      - Revised to prevent *ZEROVFY from zero verifying a slot
     *        that is in the workusr file.
     *
611gA*    11/22/10  RH   6.11g
     *      - Fix: Reset KYWHSE from 0 after chain to OPTIONS file
     *        for *ZEROVFY.
     *
611hA*    11/29/10  DAS  6.11h
     *      - Added file slot11.
     *      - Revised getnextloc/lvl routines to use slot11.
     *      - Made minor revision to getslot2usr routine for PRE.
     *      - Revised getslot2usr to set slpseq value to slloc.
611iA*    12/07/10  RH   6.11i
     *      - Fix: Do not create virutal BFC slots if LICACTIVE
     *        record exists for slot, virtual slot was getting
     *        created and LICACTIVE records were being deleted in
     *        error due to timing issue.
611jA*    12/14/10  RH   6.11j
     *      - Fix: Create change item adjustment memo with FROM & TO
     *        items.
611kA*    12/16/10  JCJ  6.11k
     *      - Fix: After creating an On=Demand-Repack (virtual) slot -
     *        *CRTREPAKD exsr calcqtys.  Was getting base slot
     *        available quantities.
611l *    12/09/10  RH   6.11l
     *      - Enh: Change routine QTYSTOCK to delete the slot record
     *
640a *    02/22/11  DAS  6.40a
     *      - Fix: Revised getslot2usr to call new program getbfcloc
     *        to get the location to be used by a BFC special slot.
     *      - To start, this is only implemented for STG slots, then
     *        will be added to RCV and OSS slots once proven.
     *
640b *    02/24/11  DAS  6.40b
     *      - Added logic at end of routine synclicense to call
     *        DRILICENSE to get rid of corresponding orphaned
     *        license records.
640c *    03/23/11  RH   6.40c
     *      - Fix: Revised QTYTFROUT to convert to lowest UOM like
     *        adjustments to check if new avail qty will be negative.
640d *    04/01/11  DAS  6.40d
     *      - Added command *TFR2USRN that will allow a slot to go
     *        negative. Was created to work with OR200 to allow a
     *        Pick slot to go negative.
640e *    04/01/11  DAS  6.40e
     *      - Revised routine tfr2usr to call synclcns if From slot
     *        went negative. Re: DRILICENSE doesn't create *NG
     *        license in this situation, so this will.
640f *    04/12/11  DAS  6.40f
     *      - Revised routine trackLcnsTfr to set $LiAQty to the
     *        'From' quantity.
     *      - Revised routine changeitem to set the frm$Slot.$saqty's
     *        to the reverse of the $saqty's returned from changeitem2.
     *        This will put them in the proper format DRILICENSE is
     *        expecting.
640g *    04/13/11  DAS  6.40g
     *      - Revised routine look4slot to leave the search loop
     *        when a slot is found.
640h *    04/22/11  RBD  6.40h
     *      - Revised routine verifyrcvm to populate $slpick with
     *        slpick.  If the overflow slot error occurred $slpick
     *        didn't get populated, then in RC200 if the user
     *        overrode the overflow slot error RC200 couldn't ensure
     *        that a pick slot doesn't get updated from a slot whose
     *        status is not an 'A'.
     *      - Revised routine look4slot to populate $slpick with
     *        slpick if subcmd = *VERIFYPUT.
640i *    05/25/11  DAS  6.40i
     *      - Fix:Revised setpriority to use in$slot.$slprty field.
     *      Was not setting priority for returns when put into empty
     *      PIR or added to PIR slot with return item.
     *
640y *    06/02/11  DAS  6.40y Originally 640j at Eastland
     *      - Revised to send slot status change to DRILICENSE.
     *      - Added Eastland custom code.
640z *    06/02/11  DAS  6.40z Originally 640k at Eastland
     *      - Added $saItmChg to DRISLOT parms
     *      - Added $liItmChg to DRILICENSE parms
     *      - These are used for a tfr with item change.
640j *    11/30/11  DAS  6.40j
     *      - Fix: Revised routine qtyclsrcv to set #whsestat after
     *        the status has been determined.
     *
640k *    10/18/11  RBD  6.40k
     *      - Fix: included slot item when calling DRILICENSE with
     *        cmd %SETFIFO.
     *
640l *    12/20/11  RTR  6.40l
     *      - Fix: Added test for XXXXXX size and return msg instead
     *        of error.
     *
640m *    04/09/12  DAS  6.40m
     *      - Added commands *ADDWEB and *DELETEWEB to be used for
     *        MRC maintenance programs.
     *
640n *    04/17/12  RBD  6.40n
     *      - Fix: Additional fix to rev 5.10h, it did not remove
     *        the unconditional update of slside.
     *
640o *    05/25/12  LMD  6.40o
     *      - Fix: added a check in updslotfifofrm if the
     *        frm$slot.$slitem is not blank. On CHANGEITEM the
     *        frm$slot.$slitem is blank. This was causing the Item#
     *        to be loaded with blank, and then exsr getitem was
     *        returning blank values for the $itflgd field which
     *        assumed no expiration date was needed.
     *
640p *    05/24/12  RBD  6.40p
     *      - Fix: Added missing fields to SETFIFO command : action,
     *        emp#, original license, and tran# are now being passed
     *        in by LT312 ... user will be captured by adding subr
     *        clr$license within setlicfifo subr.
     *
640q *    06/25/12  LMC  6.40q
     *      - Enh: Added the new memo field passed from SL252 to be
     *        added to the SAMEMO field starting in position 20.
     *        revised from item text to be 'Fr' instead of 'From'.
640r *    08/01/12  LMC  6.40r
     *      - Fix: License priority field was being assigned based on
     *        the slot the license was moving to.
640s *    10/08/12  DAS  6.40s
     *      - Revised to call drilicinfo instead of using file directly.
640t *    10/11/12  DAS  6.40t
     *      - Added command *DPPUT and *DPUNDO for Directed Putaway.
640u *    10/11/12  DAS  6.40u
     *      - Reinstated use of DirectPutaway flag.
     *      - Revised verifyrcv to only use verifyrcvm.
     *      - Revised verifyrcvm to use ManuPutaway flag for somee checks
640v *    10/18/12  LMC  6.40v
     *      - Added $licinfo2 for new LICINFO file format
640w *    11/12/12  DAS  6.40w
     *      - Revised routine vfylicslt to get slot item for comparison.
640x *    11/13/12  DAS  6.40x
     *      - Added *VERIFY option opvovf for allowing virtual overflow
     *        slots. Default is 'Y'.
     *      - Revised look4slot to get *VERIFY option. It uses opvall,
     *        but *VERIFY was only retrieved in crtvirtual.
     *      - Revised verifyrcvm check new opvovf option.
650aA*    02/25/13  LMC  6.50a
     *      - Enh: Keep breakdown items at received quantities in BFC
     *        designation slots. Once product is moved to a non BFC
     *        designation slot, the quantities will be converted.
650bA*    03/22/13  DAS  6.50b
     *      - Enh: Special handling of slot with desig code of '*MERG'.
     *        When puting an item into such a slot, the slot will be
     *        treated like a Pick slot, merging multiple license plates
     *        into a single slot. This originally was created for Get
     *        Fresh that repacks cases of tomatoes into their own boxes
     *        but keep the same item number.
650cA*    03/22/13  KDE  6.50c
     *      - Changed to create replenishment for On-Demand slot
     *        if required whether it is a pick slot or demand
     *
650dA*    04/24/13  KDE  6.50d
     *      - Changed to allow Repack items to be included as a
     *        parent on other repack items
     *
650eA*    04/25/13  KDE  6.50e
     *      - Add routine *GET2 which returns picked quantities
     *        removed from physical locations so true physical
     *        quantities can be reported for cycle counts
     *
650fA*    05/06/13  KDE  6.50f
     *      - Allow On-Demand Repacks via Work Order process
     *
650gA*    06/04/13  KDE  6.50g
     *      - Do not mark on-demand pick slots as "Z" when overflow
     *        slots exist for this on-demand item
     *
650hA*    06/10/13  KDE  6.50h
     *      - Add command *GETODRRPK to retrieve On-Demand pick slot
     *        as parent pick slot when an on-demand item is called by
     *        and on-demand item
     *
650iA*    06/12/13  KDE  6.50i
     *      - Add code in look4ovrflw to look at the sacitem when it
     *        is an on-demand repack item. I was looking back at base
     *        item and in the on-demand case it should look itself
650jA*    07/09/13  RH   6.50j
     *     - Fix: Change error only if pick slot count is greater
     *       then item number of pick slots allowed.  Was preventing
     *       item with no pick slots from being assigned to pick slot
650kA*    07/09/13  RH   6.50k
     *      - Enh: Change to allow transfer to XDK slot.
650lA*    07/17/13  RH   6.50l
     *      - Fix: If XDK slot is zero after transfer, need to update
     *        HOLD quantity.
650mA*    07/18/13  RH   6.50m
     *      - Fix: Was not getting record before delete for Z XDK slot
650nA*    07/22/13  RH   6.50n
     *      - Fix: Do not allow different item to be put into RP slot.
     *        Add new error message, RPKSLTITM
650oA*    06/06/14  LMC  6.50o
     *      - Fix: New Oss requires unique location for each
     *        osscode(letter) used at receiving.
650pA*    05/28/14  RH   6.50p
     *      - ENH: Add new subcmd ADJUSTREV to do adjustment in LIFO.
650qA*    06/15/14  KDE  6.50q
     *      - ENH: Add code to support new Production module
650r *    06/27/14  DAS  6.50r
     *      - Fix: Revised getslot2usr to call new program getbfcloc
     *        to get the location for RCV slots.
650s *    08/29/14  LMC  6.50s
     *      - Fix: #dtypeslot and #dtypeitem were not being populated
     *      in all situations before the edits that are based on these
     *      fields occur. We are adding exsr getdesig after getitem
     *      in Verifyqty.
     *      Added getdesig in verifyrcvm after we retrieve the base
     *      slot to get #dtypeslot field populated.
650tA*    04/25/14  KDE  6.50t
     *      - Fix: Prevent user from assigning repack item to a normal
     *        pick slot
650uA*    09/11/14  MLB  6.50u
     *      - Enh: Added client location parm to GETCLIENT call.
     *
650vA*    11/11/14  LMC  6.50v
     *      - Enh: Added a call to chkusage in VERIFYCHG.
     *        If chkusage returns $upieces > 0, then we have a qty
     *        qty that could be an open directed putaway.
     *        This check will not allow the user to change the
     *        status to a Z if this is true.
650wA*    01/28/15  MLB/RH/KDE  6.50w
     *      - Fix: Revised routine, LOOK4SLOT to add SLAISL <> RPK
     *        so that base slot is ignored when looking for item in
     *        a repack slot. Was causing pgm to create extra, empty
     *        and not finding the existing RPK slot.
650xA*    02/10/15  LMC/RH  6.50x
     *      - FIX: Only call chkusage in VERIFYCHG for directed
     *        putaway.
650yA*    02/20/15  LMC     6.50y
     *      - FIX: When user is doing putaway - if a virtual
     *        slot is entered - this is now an error. Users were
     *        entering a virtual slot, and the program would create
     *        a new virtual, making it's base slot a virtual.
650zA*    02/23/15  LMC     6.50z
     *      - Fix: Do not allow status change on BFC designation
     *        slots.
6501A*    02/27/15  LMC/RH  6.501
     *      - ENH: Return slstat for VFYTFICHG to be used to check
     *        status change.
651bA*    09/19/14  LMC/RH  6.51b
     *      - Fix: When using the new stuffit that allows for multiple
     *      license plates to be stuffed into the pick slot, we now
     *      need to set the resulting qty equal to the adjustment qty.
     *      The problem was overstating the license qty it was being
     *      set to the slot qty.
700  *    03/15/15  RTR     7.00
     *      - Enh: Changes for new LICADJ file.
700aA*    04/06/15  LMC  7.00a
     *      - Enh: Remove part of the 640m DELETEWEB command logic.
     *        Added DELETEWEB to some additional logic, so drislot
     *        will delete the slot.
700bA*    05/01/15  MLB     7.00b
     *      - Enh: Revised call to pgm, HIT735CL to pass slot status.
     *        Needed for FoodPro to determine which Retalix whse to
     *        update.
700cA*    05/08/15  MLB     7.00c
     *      - Added command *CRTVOFLW - Create virtual overflow slot.
     *
700dA*    07/24/15  NLK  7.00d
     *      - Added command *AMPIN.
     *      - Added command *CRTAMP.
     *      - Enh: Add AMP - Advanced Merge Pick -- call or643
     *        Similar to PrePick but no known route
     *      - Items picked and placed in box, the box is an item
700eA*    08/19/15  RH/LMC  7.00e
     *      - Fix: Send from USR slot dept to CNTPICKTFR when USR2PUT
     *        Error when transfer from / to pick slot with different
     *        departments.
700fA*    08/20/15  RH/LMC  7.00f
     *      - Enh: Change LOOK4SLOT to find & use existing slot for
     *        TFR if to slot available quantity is negative.
     *        Will allow tranfer to fix negative slots and not create
     *        virtual.
     *
700gA*    08/27/15  RH/LMC  7.00g
     *      - Enh: Change LOOK4OVERFLOW to use SLOT13 instead SlOT3 to
     *        use the dates in determining if overflow slot exist.
     *        So now it looks for older overflow slots, than the
     *        product being putaway.
700hA*    09/16/15  MLB  7.00h
     *      - Fix: Revised routine, CRTXDOCK to check for tmploc = 999,
     *        then add 1 to tmplvl and set tmploc = 1 to start at
     *        beginning. This will allow cross dock slots for levels 1
     *        thru 99.
700iA*    05/03/16  KDE  7.00i
     *      - Fix: Revised routine, VERIFYCHG to exclude *EACH slot
     *             type in total Pick Slots and only allow ONE EACH
     *             slot
     *
700jA*    05/11/16  LMC  7.00j
     *      - Fix: Cross Dock Licenses were not getting loaded with
     *             dates.
700kA*    06/20/16  LMC  7.00k
     *      - Fix: Revised routine, VERIFYCHG to only check pick slot
     *             count if the slot we are working with is not a
     *             *each slot
700lA*    06/27/16  LMC  7.00l
     *      - Reserved - UCI Tracking - New Item tracking level 'U'
700mA*    08/05/16  LMC  7.00m
     *      - ENH: Only allow *EACH pallet type with items that have
     *             a breakdown.
700n *    10/11/16  RTR  7.00n
     *      - Fix: For license in LICADJ fix for type *ADJUST.
700oA*    10/25/16  LMC  7.00o
     *      - Fix: program is allowing for product to be put away
     *      - to an inactive slot.
     *      - Mod 611b appears to have disabled this edit.
700pA*    12/05/16  RH/DAS  7.00p
     *      - Enh: Allow change item on OSS slots, VFYCHGITM sr
700qA*    12/07/16  DAS  7.00q
     *      - Enh: Added flag $saAllowZero. When 'Y', skip zero qty
     *        check in routine VerifyQty. Originally created for Full
     *        screen transfer IT352 to allow moving item to new Pick
     *        slot when no quantity exists.
700rA*    12/09/16  RTR  7.00r
     *      - Enh: Making part of mod SBRa base code, will force LICADJ
     *        for Change Item to send to host.
     *      - Fix: Exclude RC200 from mod. Multiple licenses caused prob.
700sA*    01/05/17  LMC 7.00s
     *      - Enh: Add new command *RTNIN.
     *      - Enh: Add new command *USR2RTNO - back to the RTN slot
     *        *USR2RTNO - Is same as *USR2RCV only to the RTN slot
     *        instead of the RCV slot.
     *        Had to use this command because *USR2RTN is already used
     *        to do the actual putaway for the return.
700tA*    12/14/16  MR  7.00t
     *      - Enh: Allow zero quantity transfers
710 A*    02/02/17  KDE 7.10
     *      - Fix: Always send *ADJUST to DRIITEMQTY instead of *ADJUSTPRD
     *             for Production Adjustments
710aA*    02/06/17  KDE 7.10a
     *      - Fix: Recompile to include changes to prevent level check
     *             for file CUSTMAST since it was changed.  Key changed as well.
     *      - Fix: Softcode place where Production Aisle was hardcoded
     *      - Enh: Pass Raw MAterial UCI for Dry Production
     *      - Enh: Pass Entered Date for Production Adjustment (trackADjust)
710bA*    02/17/17  LMC 7.10b
     *      - Enh: Added new command *ADJUSTIMP - setup for Canopy
     *             production import. Works simliar to *ADJUST with a
     *             few exceptions.
     *             We will not write adjustment, the host is sending
     *             us a qty to update in Dakota.
710cA*    02/20/17  LMC 7.10c
     *      - Enh: Skip the virtial pick slot count check on command
     *             *CRTPRODC. With importing production from the host
     *             we will have the potential to have multiple pick
     *             slots in the PAR slot locations if product is being
     *             produced for multiple customers.
     *      - Fix  In vfycrtprod don't exsr slot2ds until we have the
     *             correct slot for the customer.
710d *    04/25/17  RTR 7.10d
     *      - Fix: In LICADJ, *USR2PUT writing temp license, should be
     *        the to license.
710eA*    03/30/17  LMC 7.10e
     *      - Enh: When command *ADJUSTIMP - Need to send in the
     *             Expiration Date sent from DRIPROD, so the license
     *             Expiration Date will be set correctly.
710fA*    04/24/17  LMC 7.10f
     *      - Enh: Added a check to see if we already have a license
     *             for production with the same dates. If so use it.
710gA*    04/24/17  LMC 7.10g
     *      - Enh: Added $license3 to send more data to Drilicense.
710hA*    05/24/17  LMC 7.10h
     *      - Enh: Added some additional logic to allow clients to
     *        transfer original license plates to off site storage.
710i *    05/31/17  RTR 7.10i
     *      - Fix: Change to LICADJ routine to use correct license for
     *        TFR2USRR moves.
710jA*    06/13/17  LMC 7.10j
     *      - Enh: Added Verification of class rules.
710K *    07/03/17  LMC 7.10K
     *      - Enh: Added new command %SETOLCNS.
710l *    09/01/17  KDE 7.10l
     *      - Enh: Have Repack work the same as Production Slots during a
     *        Transfer to RPK slot and keep RP status for RPK slot during
     *        quantity move between USR and RPK slot
710m *    11/02/17  LMC 7.10m
     *      - Fix: Remove if statement in getdatetime.
     *        Had an issue where a gui job created the wrong entered
     *        date on a slot. The joblog showed
     *        10/30/17 16:36 previous date and time.
     *        11/01/17 17:24 current date and time.
     *        So the if statement if curtime < lasttime would not be
     *        true, and the curdate field was left to 10/30/17.
710n *    12/19/17  LMC 7.10n
     *      - Enh: Base inactive slot edit SLTNOTACTV as a hard error
     *        or warning on new *RFPUT option.
710o *    12/20/17  RTR 7.10o
     *      - Enh: If Adjusting OSS slot, update qtys before testing
     *        and trying to delete empty slot.
710p *    12/23/17  DAS 7.10p
     *      - Reserved for OSS change being tested at A&D.
720  *    02/19/18  KDE 7.20
     *      - Add command *RPAIN to generate and modify Staging
     *        Replenishment slots.  Marque's has the need with a
     *        on-site Store location
     *      - Add command USR2RPA
     *      - Add command CRTRPA
720b *    08/29/18  RTR 7.20b
     *      - FIX: Variable remaincw too small for large weight adjustment.
720cA*    06/27/16  LMC  7.20c
     *      - UCI Tracking - New Item tracking level 'U'
720dA*    12/05/18  KDE  7.20d
     *      - Reserved - Change how FIXBRKDN works to handle negatives
720eA*    01/02/19  KDE  7.20e
     *      - Changed to prevent base production slots from being zero
730aA*    02/06/19  LMC  7.30a
     *      - Fix - program would allow user to have too many pick
     *        slot if they change the pick flag to Y, and the slot was
     *        already active.
730bA*    02/26/19  LMC  7.30b
     *      - Fix - Mod 700c added a new command, but needs to also
     *        had code put in getmsg.
730cA*    04/03/19  LMC  7.30c
     *      - Enh - Real Time Cycle Count(RTC) will create adjustment
     *        even if the qty is zero. So condition the verify
     *      - Enh - Need to calculate physical quantity using the
     *        qty calculaged in SLTPCKQTY when *NXTSLOT and called
     *        from RTC330.
730dA*    06/26/19  LMC  7.30d
     *      - Enh - While looking for existing slot for production
     *        We need to make sure the expiration dates are the same
     *        Before using the slot.
     *      - Fix: use the entered date sent in. Not the slot entered
     *             date.
730eA*    09/24/19  LMC 7.30e
     *      - Enh: Add new command *RWOIN.
     *      - Enh: Add new command *USR2RWO - back to the RWO slot
     *        *USR2RWO - Is same as *USR2RCV only to the RWO slot
     *        instead of the RCV slot.
730fA*    11/05/19  LMC 7.30f
     *      - Fix: When changing a slot from overflow to pick, don't
     *        do the number of pick slot edit, unless there is an item
     *        in the slot, or an item is being put into the slot.
730gA*    11/08/19  KDE 7.30g
     *      - Fix: Override Designation error for *DROP slots
     *        and several other things for DropPick slots
730hA*    11/22/19  LMC 7.30h
     *      - Fix: In clr$license if employee was sent in, use it to
     *        go get the user name. This is needed for gui.
730iA*    11/03/19  DAS  7.30i
     *      - Revised to use LABELW
     *
740 A*    01/23/20  MLB  7.40
     *      - Fix: Revised VERIFCHG to run routine CLR$ITEM if $SLITEMU
     *        is on, but no item in slot. Was causing DDE error in
     *        $IMNRPK when trying to change slot from overflow to pick.
     *
740aA*    05/07/20  KDE  7.40a
     *      - Fix: Revised force Drop Pick slots to DP status
     *
740bA*    05/24/20  DAS  7.40b
     *      - Fix: Revised VerifyClass to call OPENSLOT1.
     *      - Changed from SQLRPGLE to RPGLE because SQL not used
     *
740cA*    06/08/20  RH   7.40c
     *      - Enh: Change IF to select to send custom code for change
     *        Item adjustment.
     *
740dA*    07/09/20  LMC  7.40d
     *      - Enh: Create new virtual when reactivating a license.
     *        Similar to how we do it for inventory counts.
     *      - Enh: When reactivating in tracklcnsto we need to ensure
     *        the stock qty for the slot does not get loaded. In case
     *        they reactivate a license into the pick slot.
     *        So the liclog for a LAC should always have 0 in the
     *        action and result quantities.
740eA*    08/25/20  MLB  7.40e
     *      - Fix: Revised VERIFYCHG to add test for $SLITEM > blanks
     *        when testing count for number of pick slots exceeded.
     *        Was throwing an error when changing SLPICK = Y and SLITEM
     *        is blank. Found at CPJ.
740f *    09/14/20  RTR  7.40f
     *      - Enh: Pass customer order number through for ADJUSTORD.
750  *    02/05/21  KDE  7.50
     *      - Enh: Determine if line slot exist when production line
     *        line slot without letting crtvirtual create another line slot
750aA*    03/23/21  MLB  7.50a
     *      - Fix: Removed 7.40e mod. Was allowing virtual pick slots
     *        to be created in any instance. Identifed at SBR, CPJ.
     *        All clients updated will need this patch installed.
     *        Roxanne found issue at SBR.
750bA*    05/28/21  MLB/RH  7.50b
     *      - Fix: Revised 6.40l mod in routine qtyreceive.
     *        Added logic to omit test for qty exceeding 99,999
     *        when newvs flag is on. Received product going into
     *        new virtual slot so test isn't necessary.
     *        Found problem at Sofo. Reference zd# 4380.
750cA*    06/30/21  LMC     7.50C
     *      - Fix: Remove cleint condition on directed putaway
     *        No longer client specific.
750dA*    07/01/21  RH      7.50d
     *      - Enh: Allow item slot designation mismatch moving item
     *        from USR slot when called by US311 Utility program
     *        to move item from virtual slot to empty base slot
750eA*    08/03/21  DAS     7.50e
     *      - Enh: When changing status and adj qty is zero, then
     *        use the stock qty in the LICADJ records.
     *      - Fix: When changing status and adj qty is zero, do not
     *        change status of second LICADJ record to CI.
750gA*    12/01/21 LMC      7.50g
     *      - Enh: When getting slot definition in getslotdef
     *        for vfychange need to send the screen fields. Was using
     *        the original def field from from the GET. If user changes
     *        this value, we need to get the slot definition for the  s
     *        new entry.                                              s
750hA*    12/06/21 LMC/RH   7.50h
     *      - Fix: Update expiration date for *ADJUST if date is
     *        not blank.
     *
     *----------------------------------------------------------------
     * Royal's Custom Changes / Fresh Sense
     *
RYLa *    03/18/18  NLK RYL.a
     *      - ENH: RC200 Putaway - Allow if XDK SLTNOTACTV
     *
     *----------------------------------------------------------------
     * Jordano's Custom Changes
     *
JOR  *    04/14/05  MLB  JOR
     *      - Revised CRTVIRTUAL to allow virtual pick slots to be
     *        created.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: BiRite
BIR A*    01/20/05  MLB  BIR
     *      - Revised CRTVIRTUAL to only allow virtual pick slots to
     *        be created for PIR slots. This mod was added when
     *        merging It352 pirlic510 and pirenh510.
     *----------------------------------------------------------------
     *  Client Custom Revisions: Earls
EOP A*    10/11/18  KDE  EOP
     *      - Revised CRTVIRTUAL to only allow do virtual slot checks
     *        if not Repack item
     *----------------------------------------------------------------
     *  Client Custom Revisions: Jack Palmer Foodservice
JPF A*    04/02/07  MLB  JPF
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only. This mod was added
     *        when merging It352 pirlic510 and pirenh510.
     *
     *----------------------------------------------------------------
     * Merit Foods Custom Revisions:
     *
MRTaA*    07/30/18  MRTaA
     *      - ENH: RC200 Putaway - Allow if RP Status Slot
     *             Multiple Picks allowed for RP Status
     *             Return Virtual ODR Slot if Repack Item Maint
MRTbA*    09/19/19  MRTbA
     *      - ENH: Add skip for RP Status slots on pick count in another place
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: MJ Kellner
MJK A*    08/20/08  DAS  MJKa
     *      - Revised CRTVIRTUAL to only allow virtual pick slots to
     *        be created for slots defined in MJKVRTPCK or PIR slots
MJKbA*    09/14/12  RH   MJKb
     *      - Revised to allow virutal pick slot for PIR or SPCL
     *        desg, Added merging V6.10 MJK update.
     *----------------------------------------------------------------
     *  Client Custom Revisions: Colony Foods
     *
CFIaA*    02/19/19  NLK  CFIa
     *      - Revised CRTVIRTUAL routine to allow virtual pick slots
     *        to be created when SLPICK=Y and SLRSRV='N'
     *----------------------------------------------------------------
     *  Client Custom Revisions: Packers
     *
PAK A*    08/17/07  RBD  PAK  P#00111
     *      - Revised subr verifychg to not allow status to be changed
     *        to QA or BL unless the slot is empty.
     *      - As of 7/15/09 this project was canceled because the SAP
     *        Host app never went live.  The rev's will remain, but
     *        the code will likely never be used.
PCKaA*    05/10/07  TJ   PCKa
     *      - Revised to ignore the inactive slot status code edit.
     *        This mod was added when merging It352 pirlic510 and
     *        pirenh510.
     *
PCKbA*    01/18/08  JCJ  PCKb
     *      - Allow override to put item in overflow slot with dif dte
     *      - Note: This mod no longer required at ver 6 of Dakota.
PCKcA*    11/19/09  MLB  PCKc
     *      - Allow user to put items into slots with slot status
     *        equal to SO = Star Meats special order slots.
PCKdA*    11/19/09  MLB  PCKd
     *      - Revised CRTVIRTUAL routine to allow virtual pick slots
     *        to be created when SLPICK=Y and SLRSRV='N' and
     *        psubcmd = *PUTAWAY.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Saval
SVLaA*    11/06/09  RH   SVLa
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only. Like JPF.
     *----------------------------------------------------------------
     *  Client Custom Revisions: Tiffin Paper Co
TPCaA*    10/08/07  RH   TPCa
     *      - Revised to set slot pick priority to -9 for cone house
     *        transfers to slot 07-100-A or 07-102-A or 07-104-A.
     *        This mod was added when merging It352 pirlic510 and
     *        pirenh510.
     *----------------------------------------------------------------
     *  Client Custom Revisions: ANDREWS
ADWaA*    01/19/07  RH   ADWa
     *      - Enh: Custom to not zero verify slots.
     *        This mod was added when merging IT252 pirlic510 and
     *        pirenh510.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Springfield
SFGaA*    01/28/09  DAS  SFGa
     *      - Revised look4overflow to ignore outside storage slots
     *        ' KA' and ' WI'.
SFGbA*    06/07/09  DAS  SFGb
     *      - Revised to not reuse the following OSSKANSAS2 slots:
     *        EY,EZ,FA,FE,GO,GP,KE,KK,KT,KU,QP,QW,WW,WX,WY,WZ
SFGdA*    01/24/17  RH   SFGd
     *      - Add to EIa mod for move.
     *      - Revised VERIFYRCVM to allow transfer to 'I' status base
     *        slot for whse move, was always creating virtual
SFGeA*    04/29/17  MLB  SFGe
     *      - Revised routines AddSlot, ChangeSlot, ChangeItem
     *        to capture items being placed into unassigned pick
     *        slot or changing item number in pick slot so that
     *        pick slot change can be sent over to H&S.
     *      - Added SFGe to GFCa mod.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Capitol City Produce
CCP A*    05/04/10  MLB  CCP
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only. This mod was added
     *        when merging It352 pirlic510 and pirenh510.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Glazier
GFC A*    10/17/11  RBD  GFC
     *      - Added new command %SETFIFOG to update expiration date
     *        in all slots and licenses that an item occupies if mfg
     *        shelf life days (IMMDAY) is changed on a mfg dated item
     *        (IMMFLG=Y) in DRIITEM.
     *      - Added new command %ZEROEXPD to set the expiration date
     *        to zero in all slots and licenses for an item if the
     *        date sensitive flag (ITFLGD) is changed from a Y to an
     *        N in DRIITEM.
     *
GFCa *    10/08/10  MLB  GFCa
     *      - Revised routines AddSlot, ChangeSlot, ChangeItem
     *        to capture items being placed into unassigned pick
     *        slot or changing item number in pick slot so that
     *        pick slot change can be sent over to H&S.
     *
GFCb *    11/10/10  MLB  GFCb
     *      - Revised routine USR2SLOT to capture items being placed
     *        into new pick slot.  This mod is part of GFCa.
     *
GFCc *    12/23/10  MLB  GFCc
     *      - Revised routines affected by GFCa, GFCb mods to include
     *        slot status to not call HIT735CL if slot is Z, V or XD.
GFCd *    01/19/12  MLB  GFCd
     *      - Change to GFCc mod. Added whse to call to CHKLIVE.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Inter County Bakers
ICBaA*    02/29/12  RH   ICBa
     *      - Revised to allow virtual pick slots to be created on
     *        slots with location 999. (like CCP Spcl desg mod)
ICBbA*    03/07/12  DAS  ICBb
     *      - Enh: Revised to force all virtual slots to be created
     *        as overflow unless location is 999 (like ICBa)
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Graves Menu Maker
GMMaA*    08/22/12  RH   GMM
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only.
GMMbA*    02/12/13  MLB  GMMb
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SLLOC = 199 and SLWHSE = 010.
     *      - Per Roxanne H. skype msg.
GMMcA*    03/13/13  RH   GMMc
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SLLOC = 999
GMMdA*    05/01/19  MLB  GMMd
     *      - Revised routines AddSlot, ChangeSlot, ChangeItem
     *        to capture items being placed into unassigned pick
     *        slot or changing item number in pick slot so that
     *        pick slot change can be sent over to H&S.
     *      - Added GMMd to GFCa mod.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Hearn Kirkwood
HKWaA*    01/24/13  RH   HKW
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: WestSide
WSTa *    05/07/13  GJA  WSTa
     *      - Revised to allow virtual pick slots to be created on
     *        slots in department LDCK.
WSTb *    04/23/14  LMC  WSTb
     *      - Allow virtual overflow based on C code from *virtual
     *        field OPVOVF. Directed putaway still needs to send the
     *        user to the base slot, so virtualoverflow OPVOVF coded
     *        as a "C" will be treated like an "N" when called from
     *        program RC160.
WSTc *    06/17/14  LMC  WSTc
     *      - Fix WSTb code - condition only if called from RC200
     *        Transfer and Repl were creating *multiples on high track
     *----------------------------------------------------------------
     *  Client Custom Revisions: Coastal Sunbelt
CSPa *    01/16/14  RH   CSPa
     *      - Default CI change item to code 10.
     *
CSPb *    01/27/14  RH   CSPb
     *      - Change to use 'From', not 'Fr' for from change item
     *        Host program uses word 'From' to change cost.
     *----------------------------------------------------------------
     *  Client Custom Revisions: Eastland
EFCaA*    06/02/11  DAS  EFCa
     *      - Revised to put the slot status code at the end of
     *        the iamemo field.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: European Imports
EIa  *    04/02/14  RH   EIa
     *      - Revised VERIFYRCVM to allow transfer to 'I' status base
     *        slot for whse move, was always creating virtual
EIb  *    12/29/15  RH   EIb
     *      - Add EI to WSTb mod to allow directed put away to put
     *        into base slot.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: H&M Wagner
HMWaA*    01/06/15  LMC  HMWa
     *      - Do not check for maximum pick slots, if the slot status
     *        is 'SR' We will not change the slstat from 'SR' to 'Z'
     *----------------------------------------------------------------
     *  Client Custom Revisions: Cash Wa
CWD A*    09/11/14  MLB  CWD
     *      - Revised pgm to only allow virtual pick slots to
     *        be created for Aberdeen warehouse for specific aisles,
     *        locations, levels.
CWDaA*    10/13/14  MLB  CWDa
     *      - Revised pgm to only allow virtual pick slots to
     *        be created for Kearney warehouse for specific aisles,
     *        locations, levels.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Dairyland
DRYaA*    10/30/17  LMC  DRYa
     *      - Revised to set OSS slots to status 'A' when adjusting
     *        the qty into the slot. ADJUSTOSS.
DRYbA*    07/26/18  MLB/RH   DRYb
     *      - Revised pgm to capture Before Slot Status for all adjust-
     *        ments and store them in ADJMEMO in positions 29-30.
     *        Before Adj Status is sent to Host in IETEXT fld in pos 3-4.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Cheney Brothers
CBIaA*    05/15/08  RH   CBIa
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only. Like JPF.
CBIbA*    02/18/16  MLB  CBIb
     *      - Revised CRTVIRTUAL to only allow virtual pick slots to
     *        only be created for slots defined in DESIGSP.
     *        Per w/o# 2015294.
CBIcA*    03/10/17  LMC  CBIc
     *      - Revised to do additional edits when transferring CLR
     *        to FRZ in order to calculate new expiration dates.
CBIdA*    07/05/17  LMC  CBId
     *      - Revised spec changes to CBIc.
CBIeA*    07/13/17  LMC  CBIe
     *      - Revised spec changes to CBIc.
     *      - We will now allow the transfer from a pick slot
     *
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: FoodPro
FPR  *    02/05/15  MLB  FPR
     *      - Revised routines AddSlot, ChangeSlot, ChangeItem
     *        to capture items being placed into unassigned pick
     *        slot or changing item number in pick slot so that
     *        pick slot change can be sent over to H&S.
     *      - Added FPR to GFCa mod.
FPRbA*    03/16/15  RH   FPRb
     *      - Add to HMW mod to not check for max pick slots if slot
     *        status is 'SR'.  Will not change slstat from SR to 'Z'
FPRc *    04/22/15  RTR  FPRc
     *      - Change to exclude whse 3 from special adjustment code
     *        logic.
FPRd *    04/22/15  RTR  FPRd
     *      - If catchweight entered for transfer, update parent LICADJ
     *        record also.
FPRe *    04/22/15  RTR  FPRe
     *      - If slot status is 'QU', send record to host no matter what.
FPRfA*    05/01/15  MLB  FPRf
     *      - Revised pgm to call HIT735CL when SLDISP = WHS2 or WHS4
     *        to send pick slot update to Retalix.
FPRgA*    05/01/15  MLB  FPRg
     *      - Revised routine USR2SLOT to capture items being placed
     *        into new pick slot.  This mod is part of GFCa.
     *      - Added FPRg to GFCb mod.
FPRh *    04/22/15  RTR  FPRh
     *      - Fix: exclude MV adjustments from warehouse move logic.
FPRiA*    05/08/15  MLB  FPRi
     *      - Enh: Revised routine vfycrtvpick to allow virtual pick
     *        slots to be created when slot status = SR or FR.
FPRjA*    05/26/15  RH   FPRj
     *      - Enh: Change to allow transfer to ADJ slot.
FPRkA*    08/18/15  RH   FPRk
     *      - Add to HMW mod to not check for max pick slots if slot
     *        status is 'FR'.  Will not change slstat from FR to 'Z'
     *        Whse2 slots = 'SR', Whse4 slots = 'FR' Whse3 slots='QU'
PRlA *   06/13/19  MLB  FPRl
     *     - Added if client = FoodPro around FPRe mod that was forcing
     *       adjustment to QU slot to host no matter if system to up-
     *       date was Dakota-Only.
FPRmA*    05/06/20  RH   FPRm
     *      - Revised to allow virtual pick slots to be created on
     *        slots with SPCL designation only or WHS2 or WHS4.
FPRoA*    03/30/22  RH/NK   FPRo
     *      - Revised to use code 'CI' for change item
     *        Revised to use code 'FM' for change item & Dept
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Stern Produce
SPIa *    08/24/17  RTR  SPIa
     *      - When change item with PA code, set memo to unique number.
SPIb *    08/30/17  RTR  SPIb
     *      - Change to skip creating priority replens when slot goes
     *        negative, only for inbound.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: Seashore Fruit & Produce
SFPa *    02/26/18  RTR  SFPa
     *      - Added to mod SPIa to send PA back to Thyme properly.
     *
     *----------------------------------------------------------------
     *  Client Custom Revisions: S.Bertram
SBRa *    02/02/16  RTR  SBRa
     *      - Revised writelicadj to force OSS records to update
     *        both systems, and force CI code for item change tfrs.
     *----------------------------------------------------------------
     *  Client Custom Revisions: Marques
MQS  *    03/16/18  KDE  MQS
     *      - Force "S" on Designation Type code when Staging/Store slot def
     *----------------------------------------------------------------
     *  Client Custom Revisions: Fresh Cuts
FRC  *    11/29/18  MR   FRC
     *      - Allow to adjust slots to negative value.
     *----------------------------------------------------------------
     *  Client Custom Revisions: Holt Paper
HPCa *    06/08/20  RH   HPCa
     *      - Default CI change item to code 8 .
     *----------------------------------------------------------------
     *  Client Custom Revisions: CPJ Jamacia
CPJaA*    07/06/20  RH   CPJa
     *      - Revised STUFFIT to update license & dates for existing
     *        base and virutal slots. Items & Qty set from host.
     *        Delete slot and re-create with item/qty/license/dates
     *----------------------------------------------------------------
     *
     * Notes
     *
     *  - Because the Sys2Upd parameter is not being sent into this
     *    program, another method needed to be created to determine
     *    if the call to this program was initiated by Dakota or by
     *    the Host system. Therefore, the first character of the
     *    subcommand is used to make this determination. If the
     *    character is a '%', then we assume that Dakota initiated
     *    the call. Otherwise, we assume that the Host system
     *    initiated the call.
     *
     *  - Some Dakota programs will send '*NOUPDATE*' in the $preturn
     *    parameter. This identifies that the operation was already
     *    done by the calling program and is being sent to this
     *    interface program to 1) log it and 2) send it to the host.
     *
     *----------------------------------------------------------------

     *----------------------------------------------------------------
     * Tracking options
     *
     * Tracking levels for field trackitem:
     *
     *   Low     -  User is not asked for any extra info.
     *              All tracking is done in the background.
     *
     *   Medium  -  User may be asked to apply new license plate to
     *              a split quantity.
     *              Applying new license plate is optional.
     *
     *   High    -  User may be asked to apply new license plate to
     *              a split quantity.
     *              Applying new license plate is manditory.
     *              User may be asked to confirm license plate being
     *              used for task.
     *
     * Values for trackpos fields:
     *
     *    trackpos     Track slot pallet position (Y/N)
     *
     *    trackposmrg  Putaway merge option
     *                 1 = Only ask for pallet position.
     *                 2 = Direct user step by step.
     *
     *    trackposrtn  Return pallet option
     *                 1 = Assume user returns pallets in LOFI order.
     *                 2 = Direct user step by step.
     *
     * Values for field tracksplit
     *
     *   1  =  LP goes with first quantity put into a slot.
     *   2  =  LP goes with last quantity put into a slot.
     *   3  =  Ask user.
     *
     *----------------------------------------------------------------

      *----------------------------------------------------------------
      *  Sub-Command Notes
      *
      *    Standard Sub-Commands
      *
      *      *OPEN             Open program and return.
      *
      *      *CLOSE            Close program with *INLR = *ON
      *
      *    Retrieval Sub-Commands
      *
600kA *      *CHKFIFO          Check if sent slot is in FIFO order
      *                        Does a SETGT and then a READE.
      *
      *      *GET              Get slot information using slot display.
      *
650eA *      *GET2             Get slot information using slot display
      *                        as *GET but it also calls a program to
      *                        returned picked quantities voiced but
      *                        not yet finalized and reduced from
      *                        available slot quantity
      *
417aA *      *GETCHKV          Get slot information using slot display
      *                        and check if associated virtual slot exists.
      *
601dA *      *GETCHKVX         Get slot information using slot display
      *                        and check if associated virtual slot exists.
      *                        Exclude sent in slot from virtual check.
      *
      *      *GETI             Get slot information using individual fields.
      *
417aA *      *GETICHKV         Get slot information using individual fields.
      *                        and check if associated virtual slot exists.
      *
500 A *      *GETITEMAV        Get item slot within physical slot.
      *
500aA *      *GETOVRFAV        Get item overflow slot within physical slot.
      *
650hA *      *GETODRRPK        Get parent pick slot for ondemand parent
650hA *                          - finds and returns pick slot of
650hA *                            on-demand Repack Item for the
650hA *                            on-demand parent to pull needed
650hA *                            stock
      *
510dA *      *GETREPACK        Get repack slot for item.
510dA *                          - Assumes only 1 repack slot for item.
      *
416jA *      *GETXDOCK         Get crossdock slot for item.
416jA *                          - Assumes only 1 crossdock slot for item.
      *
416bA *      *NXTITEM          Get next slot for item.
      *                        Does a SETGT and then a READE.
      *
500 A *      *NXTITEMAV        Get next slot for item with available qty.
      *                        Does a SETGT and then a READE.
      *
416bA *      *NXTOVRF          Get next overflow slot.
      *                        Does a SETGT and then a READE.
      *
417gA *      *NXTOVRFAV        Get next overflow slot with available qty.
      *                        Does a SETGT and then a READE.
      *
416bA *      *NXTPICK          Get next pick slot.
      *                        Does a SETGT and then a READE.
      *
416rA *      *NXTPICKAV        Get next pick slot with available quantity.
      *                        Does a SETGT and then a READE.
      *
416bA *      *NXTSLOT          Get next slot using slot display field.
      *                        Does a SETGT and then a READE.
      *
416bA *      *NXTSLOTI         Get next slot using individual fields.
      *                        Does a SETGT and then a READE.
      *
417aA *      *NXTVSLOT         Get next virtual slot.
      *                        Does a SETGT and then a READE.
      *
416bA *      *PRVITEM          Get previous slot for item.
      *                        Does a SETLL and then a READPE.
      *
416bA *      *PRVOVRF          Get previous overflow slot.
      *                        Does a SETLL and then a READPE.
      *
416bA *      *PRVPICK          Get previous pick slot.
      *                        Does a SETLL and then a READPE.
      *
416bA *      *PRVSLOT          Get previous slot using slot display field.
      *                        Does a SETLL and then a READPE.
      *
416bA *      *PRVSLOTI         Get previous slot using individual fields.
      *                        Does a SETLL and then a READPE.
      *
417aA *      *PRVVSLOT         Get previous virtual slot.
      *                        Does a SETLL and then a READPE.
      *
      *    Maintenance Sub-Commands
      *
      *      *ADD              Add slot.
      *
      *      *ADDVS            Add virtual slot.
      *
640mA *      *ADDWEB           Add slot - MRC version.
      *
416jA *      *ADDXDOCK         Add crossdock slot.
416jA *                         - Not used by program
416jA *                         - If sent, assumed to be sent by Dakota and
416jA *                           is passed through to host.
416jA *                         - Used to tell host that XDK slot created
416jA *                           by Dakota using *CRTXDOCK command.
416jA *                         - Host system should only send *CRTXDOCK.
      *
      *      *CHANGE           Change slot.
      *
600mA *      *CRTOSS           Create OSS slot.
      *
720 A *      *CRTRPA           Create RPA slot.
      *
700dA *      *CRTAMP           Create AMP-Advanced Merge Pick
      *
611eA *      *CRTPRE           Create Pre-Pick slot.
      *
650qA *      *CRTPROD          Create Production Slot
650qA *      *CRTPRODC         Create Production Slot for Customer
      *
500nA *      *CRTVPICK         Create virtual pick slot.
      *
610zA *      *CRTREPAKD        Create On-Demand-Repack slot.
610zA *                        - This slot will not be in the RPK aisle.
610zA *                        - The status will be set to 'A', not the status
610zA *                          of the base slot.
610zA *                        - SLPICK will be set to 'Y', regardless of how
610zA *                          the base slot is defined.
      *
510dA *      *CRTREPAKP        Create Parent repack slot.
      *
510dA *      *CRTREPAKR        Create Repack repack slot.
      *
416jA *      *CRTXDOCK         Create crossdock slot.
      *
500nA *      *CRTVPICK         Create virtual pick slot.
      *
      *      *DELETE           Delete slot using slot display field.
      *      *DELETEI          Delete slot using individual slot fields.
      *      *DELETEX          Delete slot w/o checks using slot display fld
      *
640mA *      *DELETEWEB        Delete slot - MRC version
      *
640tA *      *DPPUT            Directed Putaway - Put item into slot.
640tA *                        This will put an item into the slot. If item not
640tA *                        already in the slot, or a slot is created, the qt
640tA *                        will be set to zero. This is so Selection can
640tA *                        allocate against the slot before a DP is put away
      *
640tA *      *DPUNDO           Directed Putaway - Undo a *DPPUT.
640tA *                        This will remove an item from a slot, if necessar
640tA *                        when a DP transaction is deleted.
      *
      *      *SET2VFY          Set slot to Verified state.
      *
GFC A *      *SETFIFOG         FIFO changes for all LICACTIVE & SLOT records
GFC A *                        for this item.
      *
      *      *VERIFYADD        Do "*ADD" verification without update.
      *      *VERIFYCHG        Do "*CHANGE" verification without update.
      *      *VERIFYDEL        Do "*DELETE" verification without update.
416nA *      *VFYCHGITM        Do "*CHGITEM" verification without update.
      *
      *      *WARN             Check for warnings. Only one warning is
      *                        flagged at a time.
      *
      *      *WARNOVR          Override warning. Check for another warning.
      *
GFC A *      *ZEROEXPD         Zero expiration date in all slots and licenses
GFC A *                        for this item.
      *
417cA *      *ZEROVFY          Zero verify slot.
      *
      *    Quantity Sub-Commands
      *
      *      *ADJUST           Normal stock adjustment.
      *                        For negative adjustment, the adjustment qty
      *                        cannot be greater than the calculated
      *                        adjustable quantity.
      *
      *      *ADJUSTORD        Selection order stock adjustment.
      *                        This adjustment should only be used with the
      *                        Locator system. Slot quantity is allowed to
      *                        go negative. If slot is a pick slot and slot
      *                        quantity goes negative, generate a Priority
      *                        Replenishment.
      *
650qA *      *ADJUSTPRD        Production Back Flush Adjustment
650qA *                        This adjustment is called by DRIPROD     the
650qA *                        processing a production back flush to    to
650qA *                        a specific raw material per the bill of slot
650qA *                        material.  These slots could go negative
650qA *                        if the bill of material is off or
650qA *                        something is processed before goods are
650qA *                        replenished.
      *
650pA *      *ADJUSTREV        Normal stock adjustment
      *                        LIFO order for license.
      *
610aA *      *ADJUSTRTN        Return stock adjustment.
      *                        Slot quantity is allowed to go negative.
      *
600mA *      *ADJUSTOSS        Adjust OSS slot quantity.
      *
416uA *      *ADJUSTTFR        Transfer adjustment record created.
      *                        This subcommand does not update an local
      *                        files. It is only passed to the host system.
      *
416cA *      *ALC2PCK          Move qty from allocated to picked.
416cA *                        Decrease allocated qty with original qty.
416cA *                        Increase pick qty with adjust qty.
      *
416cA *      *ALLOCATE         Update allocated quantity.
416cA *                        Inc/Dec allocated qty with adjust qty.
      *
700dA *      *AMPIN            Transfer quantity into a AMP
      *
417hA *      *CLSLETIN         Close letdown-in.
417hA *                        See *CLSTFRIN.
      *
417hA *      *CLSLTICHG        Close letdown-in with possible item change.
417hA *                        See *CLSTFICHG.
      *
417hA *      *CLSLETOUT        Close letdown-out.
417hA *                        See *CLSTFROUT.
      *
417hA *      *CLSLTOCHG        Close letdown-out with possible item change.
417hA *                        See *CLSTFOCHG.
      *
416cA *      *CLSPICK          Close pick.
416cA *                        Decrease pick qty with original qty.
416cA *                        Decrease stock qty with adjust qty.
      *
417hA *      *CLSPRIN          Close priority repl - in
417hA *                        See *CLSTFRIN.
      *
417hA *      *CLSPRICHG        Close prty repl-in with possible item change.
417hA *                        See *CLSTFICHG.
      *
417hA *      *CLSPROUT         Close priority repl - out
417hA *                        See *CLSTFROUT.
      *
417hA *      *CLSPROCHG        Close prty rpl-out with possible item change.
417hA *                        See *CLSTFOCHG.
      *
417hA *      *CLSPUTAWY        Close putaway.
417hA *                        See *CLSRCV.
      *
416cA *      *CLSRCV           Close receiving/putaway.
416cA *                        Decrease receive qty with original qty.
416cA *                        Increase stock qty with adjust qty.
      *
417sA *      *CLSRCVADJ        Close receiving/putaway w/adjustment.
417sA *                        Decrease receive qty with original qty.
417sA *                        Increase stock qty with adjust qty.
417sA *                        Create adjustment record.
      *
417hA *      *CLSRTN           Close return putaway.
417hA *                        See *CLSRCV.
      *
417hA *      *CLSSSIN          Close specific slot - in
417hA *                        See *CLSTFRIN.
      *
417hA *      *CLSSSICHG        Close spec slot-in with possible item change.
417hA *                        See *CLSTFICHG.
      *
417hA *      *CLSSSOUT         Clost specific slot - out
417hA *                        See *CLSTFROUT.
      *
417hA *      *CLSSSOCHG        Close spec slt-out with possible item change.
417hA *                        See *CLSTFOCHG.
      *
500xA *      *CLSSTGPUT        Close staged putaway.
500xA *                        See *CLSPUTAWY.
      *
416cA *      *CLSTFRIN         Close transfer-in.
416cA *                        Decrease receive qty with original qty.
416cA *                        Increase stock qty with adjust qty.
      *
417fA *      *CLSTFICHG        Close transfer-in with possible item change.
417fA *                        Decrease receive qty with original qty.
417fA *                        Increase stock qty with adjust qty.
417fA *                        Note: Qtys will be converted for Parent/Child
417fA *                              relationship.
      *
416cA *      *CLSTFROUT        Close transfer-out.
416cA *                        Decrease transfer qty with original qty.
416cA *                        Decrease stock qty with adjust qty.
      *
417fA *      *CLSTFOCHG        Close transfer-out with possible item change.
417fA *                        Decrease transfer qty with original qty.
417fA *                        Decrease stock qty with adjust qty.
      *
417hA *      *LETIN            Transfer Letdown quantity into slot.
417hA *                        See *TFRIN.
      *
417hA *      *LETINCHG         Transfer Letdown quantity into slot
417hA *                          with possible item change.
417hA *                        See *TFRINCHG.
      *
417hA *      *LETOUT           Transfer Letdown quantity out of slot.
417hA *                        See *TFROUT.
      *
417hA *      *LETOUTCHG        Transfer Letdown quantity out of slot
417hA *                          with possible item change.
417hA *                        See *TFROUTCHG.
      *
600dA *      *OSSIN            Transfer quantity into a OSS slot.
600dA *                        New virtual slot always created.
600dA *                        Only Stock quantities used.
      *
416cA *      *PCK2ALC          Move qty from picked to allocated.
416cA *                        Decrease pick qty with original qty.
416cA *                        Increase allocated qty with adjust qty.
      *
416cA *      *PICK             Update picked quantity.
416cA *                        Inc/Dec pick qty with adjust qty.
      *
611eA *      *PREIN            Transfer quantity into a Pre-Pick slot.
      *
417hA *      *PRIN             Transfer Priority Repl quantity into slot.
417hA *                        See *TFRIN.
      *
417hA *      *PRINCHG          Transfer Priority Repl quantity into slot
417hA *                          with possible item change.
417hA *                        See *TFRINCHG.
      *
417hA *      *PROUT            Transfer Priority Repl quantity out of slot.
417hA *                        See *TFROUT.
      *
417hA *      *PROUTCHG         Transfer Priority Repl quantity out of slot
417hA *                          with possible item change.
417hA *                        See *TFROUTCHG.
      *
417hA *      *PUTAWAY          Update receive quantity for Putaway.
417hA *                        See *RECEIVE.
      *
600dA *      *RCVIN            Transfer quantity into a RCV slot.
600dA *                        New virtual slot always created.
600dA *                        Only Stock quantities used.
      *
720 A *      *RPAIN            Transfer quantity into a RPA slot.
720 A *                        New virtual slot always created.
720 A *                        Only Stock quantities used.
      *
700sA *      *RTNIN            Transfer quantity into a RTN slot.
700sA *                        New virtual slot always created.
700sA *                        Only Stock quantities used.
      *
730eA *      *RWOIN            Transfer quantity into a RWO slot.
730eA *                        New virtual slot always created.
730eA *                        Only Stock quantities used.
      *
610gA *      *QTY2PUT          Put quantity into slot.
610gA *                        $slitem is item going into slot.
610gA *                        Only Stock quantities used.
      *
610gA *      *QTY2PUT0         Put zero quantity into slot.
610gA *                        $slitem is item going into slot.
610gA *                        Only Stock quantities used.
      *
416cA *      *RECEIVE          Update receive quantity.
416cA *                        Inc/Dec receive qty with adjust qty.
      *
417hA *      *RETURN           Update receive quantity for Return.
417hA *                        See *RECEIVE.
      *
416eA *      *SEQPTYRPL        Sequence priority replenishments
      *
610dA *      *SETFIFO          FIFO changes for LICACTIVE
      *
710KA *      *SETOLCNS         Original license changes for LICACTIVE
      *
610wA *      *SETSTAT          Slot status change
      *
417hA *      *SSIN             Tfr Specific Slot Repl quantity into slot.
417hA *                        See *TFRIN.
      *
417hA *      *SSINCHG          Tfr Specific Slot Repl quantity into slot
417hA *                          with possible item change.
417hA *                        See *TFRINCHG.
      *
417hA *      *SSOUT            Tfr Specific Slot Repl quantity out of slot.
417hA *                        See *TFROUT.
      *
417hA *      *SSOUTCHG         Tfr Specific Slot Repl quantity out of slot
417hA *                          with possible item change.
417hA *                        See *TFROUTCHG.
      *
500xA *      *STAGEPUT         Update receive quantity for staged putaway.
500xA *                        See *PUTAWAY.
      *
600dA *      *SYNCLCNS         Synchronize LICACTIVE with slot qty.
      *
600dA *      *STGIN            Transfer quantity into a STG slot.
600dA *                        New virtual slot always created.
600dA *                        Only Stock quantities used.
      *
416cA *      *STOCK            Update stock quantity.
416cA *                        Inc/Dec stock qty with adjust qty.
      *
500iA *      *STUFFIT          Stuff item into slot.
500iA *                        Increase stock qty with adjust qty.
500iA *                        Similar to *CLSRTN.
      *
600dA *      *TFR2USR          Transfer quantity out to USR slot.
600dA *                        $slitem and $sacitem should be the same.
600dA *                        Only Stock quantities used.
600dA *                        Delete RCV/STG/OSS slot when quantity goes to zer
      *
640dA *      *TFR2USRN         Same as *TFR2USR except it will allow slot to
640dA *                        go negative. Should only be used with Pick slots.
      *
610sA *      *TFR2USRR         Transfer quantity out to USR slot.
610sA *                        Uses %TFRSLTREV instead of %TFRSLTDTE to transfer
610sA *                        qty out of license records.
      *
416cA *      *TFRIN            Transfer quantity into slot.
416cA *                        Inc/Dec receive qty with adjust qty.
      *
417fA *      *TFRINCHG         Transfer quantity into slot
417fA *                          with possible item change.
417fA *                        Inc/Dec receive qty with adjust qty
417fA *                        Note: Qtys will be converted for Parent/Child
417fA *                              relationship.
      *
416cA *      *TFROUT           Transfer quantity out of slot.
416cA *                        Inc/Dec transfer qty with adjust qty.
      *
      *
417fA *      *TFROUTCHG        Transfer quantity out of slot
417fA *                          with possible item change.
417fA *                        Inc/Dec transfer qty with adjust qty.
      *
600dA *      *USR2OSS          Transfer quantity from USR to OSS slot.
600dA *                        $slitem and $sacitem should be the same.
600dA *                        Only Stock quantities used.
600dA *                        Delete USR slot when quantity goes to zero.
      *
600dA *      *USR2PUT          Transfer quantity from USR to slot.
600dA *                        $slitem is item going into slot.
600dA *                        $sacitem is item coming out USR slot.
600dA *                        Only Stock quantities used.
600dA *                        Delete USR slot when quantity goes to zero.
      *
600dA *      *USR2RCV          Transfer quantity from USR to RCV slot.
600dA *                        $slitem and $sacitem should be the same.
600dA *                        Only Stock quantities used.
600dA *                        Delete USR slot when quantity goes to zero.
      *
720 A *      *USR2RPA          Transfer quantity from USR to RPA slot.
720 A *                        $slitem and $sacitem should be the same.
720 A *                        Only Stock quantities used.
720 A *                        Delete USR slot when quantity goes to zero.
      *
700sA *      *USR2RTNO         Transfer quantity from USR to RTN slot.
700sA *                        $slitem and $sacitem should be the same.
700sA *                        Only Stock quantities used.
700sA *                        Delete USR slot when quantity goes to zero.
      *
600dA *      *USR2RTN          Transfer quantity from USR to slot as a Return.
600dA *                        $slitem is item going into slot.
600dA *                        $sacitem is item coming out USR slot.
600dA *                        Only Stock quantities used.
600dA *                        Delete USR slot when quantity goes to zero.
      *
730eA *      *USR2RWO          Transfer quantity from USR to RWO slot.
730eA *                        $slitem and $sacitem should be the same.
730eA *                        Only Stock quantities used.
730eA *                        Delete USR slot when quantity goes to zero.
      *
600dA *      *USR2STG          Transfer quantity from USR to STG slot.
600dA *                        $slitem and $sacitem should be the same.
600dA *                        Only Stock quantities used.
600dA *                        Delete USR slot when quantity goes to zero.
      *
600dA *      *USRIN            Transfer quantity into a USR slot.
600dA *                        New virtual slot always created.
600dA *                        Only Stock quantities used.
      *
      *      *VERIFY           Do verification for *ADJUST.
650p  *                        or *ADJUSTREV.
      *
      *      *VERIFYORD        Do verification for *ADJUSTORD.
      *
500eA *      *VERIFYPUT        Do verification for *PUTAWAY.
500eA *      *VERIFYRTN        Do verification for *RETURN.
417hA *      *VERIFYLTI        Do verification for *LETIN.
417hA *      *VERIFYPRI        Do verification for *PRIN.
417hA *      *VERIFYSSI        Do verification for *SSIN.
416oA *      *VERIFYTFI        Do verification for *TFRIN.
417hA *      *VERIFYLTO        Do verification for *LETOUT.
417hA *      *VERIFYPRO        Do verification for *PROUT.
417hA *      *VERIFYSSO        Do verification for *SSOUT.
      *      *VERIFYTFO        Do verification for *TFROUT.
500iA *      *VERIFYSI         Do verification for *STUFFIT.
417hA *      *VFYLTICHG        Do verification for *LETINCHG.
417hA *      *VFYPRICHG        Do verification for *PRINCHG.
417hA *      *VFYSSICHG        Do verification for *SSINCHG.
500xA *      *VFYSTGPUT        Do verification for *STAGEPUT.
417fA *      *VFYTFICHG        Do verification for *TFRINCHG.
417hA *      *VFYLTOCHG        Do verification for *LETOUTCHG.
417hA *      *VFYPROCHG        Do verification for *PROUTCHG.
417hA *      *VFYSSOCHG        Do verification for *SSOUTCHG.
417fA *      *VFYTFOCHG        Do verification for *TFROUTCHG.
500jA *      *VERIFYLTI        Do verification for *LETIN.
500jA *      *VFYCLSPRI        Do verification for *CLSPRIN.
500jA *      *VFYCLSSSI        Do verification for *CLSSSIN.
500jA *      *VFYCLSTFI        Do verification for *CLSTFRIN.
500jA *      *VFYCLSLTO        Do verification for *CLSLETOUT.
500jA *      *VFYCLSPRO        Do verification for *CLSPROUT.
500jA *      *VFYCLSSSO        Do verification for *CLSSSOUT.
500jA *      *VFYCLSTFO        Do verification for *CLSTFROUT.
500jA *      *VFYCLSLIC        Do verification for *CLSLTICHG.
500jA *      *VFYCLSPIC        Do verification for *CLSPRICHG.
500jA *      *VFYCLSSIC        Do verification for *CLSSSICHG.
500jA *      *VFYCLSTIC        Do verification for *CLSTFICHG.
500jA *      *VFYCLSLOC        Do verification for *CLSLTOCHG.
500jA *      *VFYCLSPOC        Do verification for *CLSPROCHG.
500jA *      *VFYCLSSOC        Do verification for *CLSSSOCHG.
500jA *      *VFYCLSTOC        Do verification for *CLSTFOCHG.
610gA *      *VFYINSLOT        Verify if item in physical slot.
600dA *      *VFYLICSLT        Verify license slot
610dA *      *VFYSETFIFO       Verify FIFO Active License File
      *
      *----------------------------------------------------------------

     *----------------------------------------------------------------
     * File Specs
     *----------------------------------------------------------------

     Fslot1     uf a e           k disk    usropn
     F                                     infds(file1ds)
     Fslot2     uf a e           k disk    usropn
     F                                     infds(file2ds)
     F                                     rename(slrec:slrec2)
700gAFslot13    uf a e           k disk    usropn
700gAF                                     rename(slrec:slrec13)
416bAFslot3     uf a e           k disk    usropn
416bAF                                     infds(file4ds)
416bAF                                     rename(slrec:slrec3)
611hAFslot11    uf a e           k disk    usropn
611hAF                                     rename(slrec:slrec11)
412 AFvslot     uf a e           k disk
     F                                     infds(file3ds)
     Fvslot2    if   e           k disk
416bAF                                     rename(vsrec:vsrec2)
650tAFvslot1    if   e           k disk    prefix(v1_)
650tAF                                     rename(vsrec:vsrec1)
     Fitemadj   o  a e           k disk    usropn
700 AFlicadj    uf a e           k disk    usropn
730iDF*abel     o  a e           k disk    usropn
730iMFlabelw    o  a e           k disk    usropn
412 AFoptions   if   e           k disk
     Flogslot   o    e           k disk
417cAFspclord   uf   e           k disk    usropn
417cAFvslexcp   uf   e           k disk    usropn
417cAFcrossdk   uf   e           k disk    usropn
417eAFslotdgt   if   e           k disk    usropn
600tAFpgmsubrtn uf a e           k disk
611fAFworkusr1  if   e           k disk
GFC AFlicactive2if   e           k disk
640sDF*icinfo2  if   e           k disk
650iAFkititem   if   e           k disk
650qAFplined    if   e           k disk
650qAFcustmast  if   e           k disk
650qAFpcslot1   uf   e           k disk
710jAFitemcls   if   e           k disk
710jAFclassrule if   e           k disk
     *----------------------------------------------------------------
GFC A* Function prototypes.
     *----------------------------------------------------------------

GFC A /copy qcopysrc,p.clcdur2
700 A /copy qcopysrc,p.getoptio
CBIcA /copy qcopysrc,p.caldktex
730hA /copy qcopysrc,p.getempl

700 AD getRecId        pr                  extpgm('GETRECID')
700 AD  pWhse                         3s 0 const
700 AD  pFile                        10    const
700 AD  pRecId                       11p 0

700 AD getAdjCode      pr                  extpgm('GETADJCOD')
700 AD  pCode                         2    const
700 AD  pDesc                        30
700 AD  pSys                          1

     *----------------------------------------------------------------
     *  Table and array definitions
     *----------------------------------------------------------------

610xDD*hnd             S              2    dim(702)
610xMD hnd             S              2    dim(962)
409 AD ltr             S              1    dim(27) ctdata perrcd(27)
610xAD nbr             S              1    dim(10) ctdata perrcd(10)
650qAD prdslt          S              3    dim(100)

500lA*----------------------------------------------------------------
500lA*  Customer id
500lA*----------------------------------------------------------------
500lA
500lA /copy qcopysrc,id#jordano
500lA /copy qcopysrc,id#vigo
BIR A /COPY QCOPYSRC,Id#BIRITE
JPF A /COPY QCOPYSRC,Id#PALMER
PCKaA /COPY QCOPYSRC,Id#PACKERS
TPCaA /COPY QCOPYSRC,Id#TPC
ADWaA /COPY QCOPYSRC,Id#ANDREWS
CBIaA /COPY QCOPYSRC,Id#CHENEY
MJKaA /COPY QCOPYSRC,Id#MJKELLN
SFGaA /COPY QCOPYSRC,Id#sgc
SVLaA /COPY QCOPYSRC,Id#saval
CCP A /COPY QCOPYSRC,Id#CAPITOL
ECFaA /COPY QCOPYSRC,id#eastlan
GFCaA /COPY QCOPYSRC,Id#Glazier
FRCaA /COPY QCOPYSRC,Id#FRC
FRCaA /COPY QCOPYSRC,Id#GFK
ICBaA /COPY QCOPYSRC,Id#ICB
GMMaA /COPY QCOPYSRC,Id#GMM
HKWaA /COPY QCOPYSRC,Id#HKW
WSTaA /COPY QCOPYSRC,Id#WESTSID
CSPaA /COPY QCOPYSRC,Id#coastal
EIa A /COPY QCOPYSRC,Id#EI
HMWaA /COPY QCOPYSRC,id#hmwagne
CWD A /COPY QCOPYSRC,Id#Cashwa
FPR A /copy qcopysrc,id#fpr
SPIaA /COPY QCOPYSRC,Id#spi
SFPaA /COPY QCOPYSRC,Id#sfp
DRYaA /copy qcopysrc,id#dairyla
MQS A /COPY QCOPYSRC,Id#mqs
MRTaA /COPY QCOPYSRC,Id#mrt
RYLaA /COPY QCOPYSRC,Id#royal
EOPaA /COPY QCOPYSRC,Id#eop
SBRaA /COPY QCOPYSRC,Id#sbr
CFIaA /COPY QCOPYSRC,Id#cfi
HPCaA /COPY QCOPYSRC,Id#hpc
CPJaA /copy qcopysrc,id#cpj

     *----------------------------------------------------------------
     *  DRI parameters
     *----------------------------------------------------------------

      /COPY *libl/qcopysrc,C#DRIPARMP
      /COPY *libl/qcopysrc,C#DRIPARMS
     D savesubcmd      s                   like($psubcmd)

     *----------------------------------------------------------------
     *  Data Formats
     *----------------------------------------------------------------

      /COPY *libl/qcopysrc,C#SLOT
      /COPY *libl/qcopysrc,C#ITEM
      /COPY *libl/qcopysrc,C#ITEMQTY
416bA /COPY *libl/qcopysrc,C#PRTYRPL
416bA /COPY *libl/qcopysrc,C#DEPT
416bA /COPY *libl/qcopysrc,C#DESIG
500gA /COPY *libl/qcopysrc,C#LICHIST
500gA /COPY *libl/qcopysrc,C#LICINFO
500gA /COPY *libl/qcopysrc,C#SLOTDEF
600fA /COPY *libl/qcopysrc,C#LICENSE
     D saveVer#        s                   like($slver#)
     D savedisp        s                   like($sldisp)
     D saveexpdu       s                   like($slexpdu)
     D saveexpd        s                   like($slexpd)
600dAD saveitem        s                   like($slitem)
     D saveslfdu       s                   like($slslfdu)
     D saveslfd        s                   like($slslfd)
     D saveprtyu       s                   like($slprtyu)
     D saveprty        s                   like($slprty)
     D $slotbefore     s                   like($slot)
600fDD*$slotinput      s                   like($slot)
600fAD in$Slot         ds                  likeds($slot)
600fAD in$Slot2        ds                  likeds($slot2)
600fAD to$Slot         ds                  likeds($slot)
600fAD to$Slot2        ds                  likeds($slot2)
600fAD rcv$Slot        ds                  likeds($slot)
600fAD rcv$Slot2       ds                  likeds($slot2)
600fAD frm$Slot        ds                  likeds($slot)
600fAD frm$Slot2       ds                  likeds($slot2)
     D $preturninput   s                   like($preturn)
     D $pmessageinput  s                   like($pmessage)

     *----------------------------------------------------------------
     *  Computed slot quantities.
     *----------------------------------------------------------------

     D slphy1          s                   like(slstk1)
     D slphy2          s                   like(slstk2)
     D slphy3          s                   like(slstk3)
     D slavl1          s                   like(slstk1)
     D slavl2          s                   like(slstk2)
     D slavl3          s                   like(slstk3)
     D sladj1          s                   like(slstk1)
     D sladj2          s                   like(slstk2)
     D sladj3          s                   like(slstk3)

     *----------------------------------------------------------------
     *  Verify Subprogram Variables
     *----------------------------------------------------------------

     D $vcount         s              3p 0
     D $vcommand       s              8
     D $vdesc          s             30
     D $vmessage       s             60
     D $vmsgk          s              4
     D $vprg           s             10
     D $vreturn        s             10
611a D $vreturn8       s              8

     D $vactv          s                   like($slactv)
     D $vbld           s                   like($slbld)
     D $vcode          s                   like($sacode)
     D $vdesg          s                   like($sldesg)
     D $vdisp          s                   like($sldisp)
500uAD $vfrom          s                   like($sldisp)
     D $vitem          s                   like($slitem)
     D $vsdef          s                   like($slsdef)
     D $vstat          s                   like($slstat)
416aAD $vsys           s              1
     D $vwhdp          s                   like($slwhdp)
     D $vwhse          s              3p 0

     *----------------------------------------------------------------
     *  Called program flags
     *----------------------------------------------------------------

     D pgm2close       s             10

     D dridept         s               n
     D dridesig        s               n
     D driitem         s               n
     D driitemqty      s               n
600eAD drilicense      s               n
500gAD drilichist      s               n
500gAD drilicinfo      s               n
     D driprtyrpl      s               n
600eAD drislotdef      s               n
     D vfyadjc         s               n
     D vfyactv         s               n
     D vfybld          s               n
     D vfysdef         s               n
     D vfysstat        s               n
     D vfywhse         s               n

600dA*----------------------------------------------------------------
600dA*  Saved record formats
600dA*----------------------------------------------------------------
600dA
600dAD slrecds       e ds                  extname(slot1)
600dAD frmSLREC        ds                  likeds(slrecds)
600dAD toSLREC         ds                  likeds(slrecds)
600dAD saveSLREC       ds                  likeds(slrecds)

730hA *----------------------------------------------------------------
730hA * Fields used in GETUSER call.
730hA *----------------------------------------------------------------
730hAD $user           s             10
730hAD $emp#           s              5  0
730hAD $whse           s              3  0
730hAD $code           s             10
730hAD $fnam           s             15
730hAD $init           s              1
730hAD $lnam           s             20
730hAD $whdp           s              5
730hAD $styp           s              1
730hAD $shft           s              6
730hAD $crew           s              6
730hAD $nhrs           s              3  1
730hAD $rtn            s              8
730hAD $bpu            s              1
730hAD $lng            s              2
730hAD $email          s              1
730hAD $pics           s              1
     *----------------------------------------------------------------
     *  Variables
     *----------------------------------------------------------------

     D DakotaCall      s               n
     D HostCall        s               n
     D UpdateDakota    s               n

     D DirectPutaway   s               n
     D ManualPutaway   s               n

600dAD aisleOSS        s                   like($slaisl)
600dAD aisleRCV        s                   like($slaisl)
720 AD aisleRPA        s                   like($slaisl)
700sAD aisleRTN        s                   like($slaisl)
730eAD aisleRWO        s                   like($slaisl)
600dAD aisleSTG        s                   like($slaisl)
600dAD aisleUSR        s                   like($slaisl)
600dAD allZero         s               n
600mAD baseDisp        s                   like(sldisp)
     D check4err       s               n
417dAD cssbflag        s               n
650gAd ovrFlwODR       s               n   inz('0')
640lAD qtytest         s              7  0
CBIcAD CBIClrFrz       s               n
710jAD ClassLevel      s                   like(slrlvl)
710jAD LeftLoc         s                   like(slloc)
710jAD RightLoc        s                   like(slloc)
     D curdate         s              8  0
     D curtime         s              6  0
GFC AD datein          s              8  0
600dAD deleteRec       s               n
     D desigcode       s                   like($sldesg)
600lDD*diffexpdte      s               n
600lDD*difflotcode     s               n
600lDD*diffposdiffdte  s               n
600lDD*diffpossamedte  s               n
600lDD*diffposdifflot  s               n
600lDD*diffpossamelot  s               n
600yAD diffStatus      s               n
750 Ad prodSlotFound   s               n
     D dummy           s                   like($slloc)
600dAD emp#a           s              5
     D error           s               n
     D exist           s               n
GFC AD expd            s              8  0
     D flaghs          s               n
700 AD forceadjcod     s               n
     D forever         s               n   inz(*on)
     D found           s               n
700 AD gaDesc          s             30a
700 AD gaSys           s              1a
611lAD getagain        s               n
700 AD getoptval       s            117a
700 AD holdadjnum      s             11a
700 AD holdprvadj      s             11a
700 AD holdprvslt      s                   like(sldisp)
700aAD holdprvitm      s                   like(slitem)
FPRoAD holdprvdpt      s                   like(slwhdp)
     D i               s              3  0
     D item#           s                   like(slitem)
600dAD itemChanged     s               n
     D j               s              3  0
     D k               s              3  0
     D kywhse          s                   like(slwhse)
     D kywhdp          s                   like(slwhdp)
     D kydisp          s                   like(sldisp)
610lAD kysdisp         s                   like(sldisp)
610lAD kyswhdp         s                   like(slwhdp)
610lAD kyswhse         s                   like(slwhse)
416jAD kystat          s                   like(slstat)
416jAD kyaisl          s                   like(slaisl)
611hAD kyloc           s                   like(slloc)
611hAD kyrlvl          s                   like(slrlvl)
GFC AD kyitem          s                   like(slitem)
650gAd prvWhse         s                   like(slwhse)
650gAd prvWhdp         s                   like(slwhdp)
650gAd prvDisp         s                   like(sldisp)
     D lasttime        s              6  0 inz(999999)
     D lock            s               n
417eAD lockedslotdgt   s               n
     D lockeditemqty   s               n
     D lockedslot1     s               n
     D lockedslot2     s               n
     D lockedvslot     s               n
     D logit           s               n
     D lowiaorg        s              7  0
     D lowiaqty        s              7  0
500wAD lownewavl       s              7  0
     D lowunitwgt      s              9  2
     D lowwhavl        s              7  0
610xAD maxCode         s              5  0
600eAD main3err        s               n
600eAD main3callerr    s               n
600eAD main3rtnerr     s               n
640qAD memo11          s             11
700 AD negLicAdj       s               n
     D newavlqty1      s                   like(slavl1)
     D newavlqty2      s                   like(slavl2)
     D newavlqty3      s                   like(slavl3)
     D newvs           s               n
     D nextseq#        s              7  0
500aAD noneavail       s               n
GFC AD openlicactive2  s               n
     D openstack       s             10    dim(15)
     D                                     inz(' ')
611cAD origItem        s                   like(slitem)
640yAD origStat        s                   like(slstat)
501fAD overflowfound   s               n
     D phactv          s                   like(SLACTV)
     D phaisl          s                   like(SLAISL)
     D phbld           s                   like(SLBLD)
     D phdesg          s                   like(SLDESG)
     D phdisp          s                   like(SLDISP)
     D phhand          s                   like(SLHAND)
     D phloc           s                   like(SLLOC)
     D phpseq          s                   like(SLPSEQ)
     D phrlvl          s                   like(SLRLVL)
     D phsdef          s                   like(SLSDEF)
     D phside          s                   like(SLSIDE)
     D phslfd          s                   like(SLSLFD)
     D phstyp          s                   like(SLSTYP)
     D phwhdp          s                   like(SLWHDP)
     D phwhse          s                   like(SLWHSE)
611dAD pkd_slwhse      s              3p 0
611dAD pkd_slloc       s              3p 0
611dAD pkd_slrlvl      s              2p 0
611dAD pkd_slpseq      s              5p 0
600dAD pos             s              3  0
650qAD prodCust        s             11  0
     D pssrflag        s               n
611cAD qtyChanged      s               n
700 AD recidnum        s             11p 0
417fAD remainder       s              5  0
720bDD*remaincw        s              7  2
720bMD remaincw        s              9  2
     D samedisp        s                   like($sldisp)
600lDD*sameexpdte      s               n
600lDD*samelotcode     s               n
500gAD sameslotpos     s               n
500gAD samepos         s               n
600lDD*sameposdiffdte  s               n
600lDD*samepossamedte  s               n
600lDD*sameposdifflot  s               n
600lDD*samepossamelot  s               n
600lAD samepossamelic  s               n
     D samewhdp        s                   like($slwhdp)
     D samewhse        s                   like($slwhse)
600dAD saveEntd        s                   like(slentd)
710fAD savePRlic       s                   like($litolcns)
710jAD saveiclwhs      s                   like(iclwhs)
710jAD saveiclitm      s                   like(iclitm)
710jAD saveiclcde      s                   like(iclcde)
CWD AD skipvpckchk     s               n
     D ssbflag         s               n
650lAD svsubcmd        s                   like($psubcmd)
600vAD svitem          s                   like(slitem)
640yAD statChg         s               n
750eAD statChgOnly     s               n
750eAD statChgOnlyQ1   s                   like(slstk1)
750eAD statChgOnlyQ2   s                   like(slstk2)
750eAD statChgOnlyQ3   s                   like(slstk2)
600dAD stgDisp         s                   like(sldisp)
600dAD stgWhdp         s                   like(slwhdp)
600dAD stgWhse         s                   like(slwhse)
650qAD sltc            s              3  0
610vAD temp6a          s              6
417fAD temp5n          s              5  0
600lAD tmpdisp         s                   like(sldisp)
600lAD tmpitem         s                   like(slitem)
416dAD tmploc          s                   like(slloc)
611eAD tmplvl          s                   like(slrlvl)
500gAD trackitem       s              1
500gAD trackpos        s              1
500gAD trackposmrg     s              1
500gAD trackposrtn     s              1
500gAD trackpsplit     s              1
500gAD tracktsplit     s              1
601aAD updateFifo      s               n
     D updexpdte       s               n
     D updprty         s               n
700 AD useLicAdj       s               n
600dAD usrDisp         s                   like(sldisp)
600dAD usrWhdp         s                   like(slwhdp)
600dAD usrWhse         s                   like(slwhse)
611cAD utJobq          s              1
611cAD utWhse          s             15  5
     D vslotcreated    s               n
520dAD wkslhand        s                   like(slhand)
     D warningtype     s                   like($psubcmd)
CBIcAd perrmsg         s             99
CBIcAd psessid         s             40
CBIcAd pdpcombo        s             20
CBIcAd calpwhse        s              3  0
CBIcAd calpentdate     s              8  0
CBIcAd calpdktexpd     s              8  0

416dAD #dtypeitem      s                   like($dstype)
416dAD #dtypeslot      s                   like($dstype)

600lAD pullExists      s               n
600lAD pullFound       s               n
600lAD pullItem        s                   like(slitem)
600lAD pullStat        s                   like(slstat)

416dAD #sentitem       s                   like($ititem)
416dAD #senttype       s                   like($ittype)
416dAD #sentdesc       s                   like($itdesc)
416dAD #sentpdsc       s                   like($itpdsc)
416dAD #sentwhdp       s                   like($itwhdp)
416dAD #sentstyp       s                   like($itstyp)
416dAD #sentdesg       s                   like($itdesg)
416dAD #sentum1        s                   like($itum1)
416dAD #sentflg1       s                   like($itflg1)
416dAD #sentum2        s                   like($itum2)
416dAD #sentumq2       s                   like($itumq2)
416dAD #sentflg2       s                   like($itflg2)
416dAD #sentum3        s                   like($itum3)
416dAD #sentumq3       s                   like($itumq3)
417fAD #sentmitem      s                   like($itmitem)
500gAD #sentlot        s                   like($imlot)
600dAD #senttrack      s                   like($imltrk)
CBIcAD #sentimmflg     s                   like($immflg)

416dAD #slotitem       s                   like($ititem)
416dAD #slottype       s                   like($ittype)
416dAD #slotdesc       s                   like($itdesc)
416dAD #slotpdsc       s                   like($itpdsc)
416dAD #slotwhdp       s                   like($itwhdp)
416dAD #slotstyp       s                   like($itstyp)
416dAD #slotdesg       s                   like($itdesg)
416dAD #slotum1        s                   like($itum1)
416dAD #slotflg1       s                   like($itflg1)
416dAD #slotum2        s                   like($itum2)
416dAD #slotumq2       s                   like($itumq2)
600xAD #slotumq2orig   s                   like($itumq2)
416dAD #slotflg2       s                   like($itflg2)
416dAD #slotum3        s                   like($itum3)
416dAD #slotumq3       s                   like($itumq3)
600xAD #slotumq3orig   s                   like($itumq3)
416dAD #slotnrpk       s                   like($imnrpk)
416dAD #slotflgd       s                   like($itflgd)
416nAD #slotswgt       s                   like($itswgt)
416nAD #slotcwgt       s                   like($itcwgt)
417fAD #slotmitem      s                   like($itmitem)
600dAD #slottrack      s                   like($imltrk)

416dAD #ssbitem        s                   like($ititem)
416dAD #ssbtype        s                   like($ittype)
416dAD #ssbdesc        s                   like($itdesc)
416dAD #ssbpdsc        s                   like($itpdsc)
416dAD #ssbwhdp        s                   like($itwhdp)
416dAD #ssbstyp        s                   like($itstyp)
416dAD #ssbdesg        s                   like($itdesg)
416dAD #ssbum1         s                   like($itum1)
416dAD #ssbum2         s                   like($itum2)
416dAD #ssbumq2        s                   like($itumq2)
416dAD #ssbum3         s                   like($itum3)
416dAD #ssbumq3        s                   like($itumq3)

417dAD #csentitem      s                   like($ititem)
417dAD #csenttype      s                   like($ittype)
417dAD #csentdesc      s                   like($itdesc)
417dAD #csentpdsc      s                   like($itpdsc)
417dAD #csentwhdp      s                   like($itwhdp)
417dAD #csentstyp      s                   like($itstyp)
417dAD #csentdesg      s                   like($itdesg)
417dAD #csentum1       s                   like($itum1)
417dAD #csentflg1      s                   like($itflg1)
417dAD #csentum2       s                   like($itum2)
417dAD #csentumq2      s                   like($itumq2)
417dAD #csentflg2      s                   like($itflg2)
417dAD #csentum3       s                   like($itum3)
417dAD #csentumq3      s                   like($itumq3)
417fAD #csentmitem     s                   like($itmitem)
600dAD #csenttrack     s                   like($imltrk)
CBIcAD #csentimmflg    s                   like($immflg)

417dAD #cslotitem      s                   like($ititem)
417dAD #cslottype      s                   like($ittype)
417dAD #cslotdesc      s                   like($itdesc)
417dAD #cslotpdsc      s                   like($itpdsc)
417dAD #cslotwhdp      s                   like($itwhdp)
417dAD #cslotstyp      s                   like($itstyp)
417dAD #cslotdesg      s                   like($itdesg)
417dAD #cslotum1       s                   like($itum1)
417dAD #cslotflg1      s                   like($itflg1)
417dAD #cslotum2       s                   like($itum2)
417dAD #cslotumq2      s                   like($itumq2)
417dAD #cslotflg2      s                   like($itflg2)
417dAD #cslotum3       s                   like($itum3)
417dAD #cslotumq3      s                   like($itumq3)
417dAD #cslotnrpk      s                   like($imnrpk)
417dAD #cslotflgd      s                   like($itflgd)
417nAD #cslotswgt      s                   like($itswgt)
417nAD #cslotcwgt      s                   like($itcwgt)
417fAD #cslotmitem     s                   like($itmitem)
600dAD #cslottrack     s                   like($imltrk)

417dAD #cssbitem       s                   like($ititem)
417dAD #cssbtype       s                   like($ittype)
417dAD #cssbdesc       s                   like($itdesc)
417dAD #cssbpdsc       s                   like($itpdsc)
417dAD #cssbwhdp       s                   like($itwhdp)
417dAD #cssbstyp       s                   like($itstyp)
417dAD #cssbdesg       s                   like($itdesg)
417dAD #cssbum1        s                   like($itum1)
417dAD #cssbum2        s                   like($itum2)
417dAD #cssbumq2       s                   like($itumq2)
417dAD #cssbum3        s                   like($itum3)
417dAD #cssbumq3       s                   like($itumq3)

416dAD #whseadj1       s                   like($iqadj1)
416dAD #whseadj2       s                   like($iqadj2)
416dAD #whseadj3       s                   like($iqadj3)
416dAD #whsefix1       s                   like($iqfix1)
416dAD #whsefix2       s                   like($iqfix2)
416dAD #whsefix3       s                   like($iqfix3)
416dAD #whseorg1       s                   like($iqorg1)
416dAD #whseorg2       s                   like($iqorg2)
416dAD #whseorg3       s                   like($iqorg3)
     D #whsestat       s                   like(slstat)

416dAD #fromitem       s                   like($ititem)
416dAD #fromtype       s                   like($ittype)
416dAD #fromumq2       s                   like($itumq2)
416dAD #fromumq3       s                   like($itumq3)
417fAD #frommitem      s                   like($itmitem)
601gAD #fromsentitem   s                   like($ititem)
601gAD #fromsenttype   s                   like($ittype)

416dAD #toitem         s                   like($ititem)
416dAD #totype         s                   like($ittype)
416dAD #toumq2         s                   like($itumq2)
416dAD #toumq3         s                   like($itumq3)
417fAD #tomitem        s                   like($itmitem)
601gAD #tosentitem     s                   like($ititem)
601gAD #tosenttype     s                   like($ittype)

650vAD $uDiffItem      s              1
650vAD $uCube          s              9  3
650vAD $uDisp          s             12
650vAD $uItem          s             15
650vAD $uPieces        s              5  0
650vAD $uRecs          s              3  0
650vAD $uRsrv          s              1
650vAD $uWhdp          s              5
650vAD $uWhse          s              3  0
650vAD $uEntDte        s              8  0
650vAD $uExpDte        s              8  0
650vAD $uDiffEntd      s              1
650vAD $uDiffExpd      s              1

610vA*----------------------------------------------------------------
610vA*  Constants
610vA*----------------------------------------------------------------
610vA
610vAD ltrnbr          c                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ-
     D                                     0123456789'

417iA*----------------------------------------------------------------
417iA*  *DATEOPT  -  Expiration/Entered date options
601aA*
601aA*  **** NO LONGER USED AS OF ver 6.00 ****
601aA*
417iA*----------------------------------------------------------------
417iA*
417iA* Fields
417iA*
417iA*    OPLTDN  -  Letdown transactions.  <1-3>
417iA*    OPODRP  -  On-demand replenishment transactions. <1-3>
417iA*    OPSLTF  -  Slot transfer transactions. <1-3>
417iA*    OPPARC  -  Product put-away - Receiving transactions. <1-3>
417iA*    OPPART  -  Product put-away - Returns transactions. <1-3>
417iA*
417iA*     Destination options:
417iA*       1=Use From Slot date.
417iA*       2=Use oldest date.
417iA*       3=Use From Slot date if To Slot available qty is zero.
417iA*
417iA*     Note: For Receiving/Returns, substitute date captured during
417iA*           receiving/returns processing for From Slot date.
417iA*
417iA* Data structure
417iA*
417iAD opdta1          ds
417iAD  opltdn                 1      1
417iAD  opodrp                 2      2
417iAD  opsltf                 3      3
417iAD  opparc                 4      4
417iAD  oppart                 5      5
417iAD  opendd               117    117

650oA*----------------------------------------------------------------
650oA*  CONVERSION - Converts alpha to numeric
650oA*----------------------------------------------------------------
650oA*
650oA* Fields
650oA*
650oA*    osscode -  letter used during receiving.
650oA*    OPRF    -  Using RF module (Y,N).
650oA*
650oA*----------------------------------------------------------------
650oA
650oADConversion       DS
650oAD osscode                 1      1A
650oAD sllocValue              1      1U 0
412 A*----------------------------------------------------------------
412 A*  *SYSTEM  -  System options.
412 A*----------------------------------------------------------------
412  *
412  * Fields
412  *
412  *    OPEPM   -  Using EPM module (Y,N).
412  *    OPRF    -  Using RF module (Y,N).
412  *    OPCAPC  -  Capture catch weights at pick closing (Y,N).
412  *    OPLETD  -  Print letdown labels (Y,N).
412 A*    OPWRNC  -  Perform catch weight variance check (Y,N).
412 A*    OPRG1C  -  Catch weight low variance percentage.
412 A*    OPRG2C  -  Catch weight high variance percentage.
412 A*    OPIMPI  -  Import item fields from host.(Y,N).
412 A*    OPMPCK  -  Allow multiple pick slots for fixed items (Y,N).
412 A*
412 A*----------------------------------------------------------------
412 A
412 AD opdat2          ds
412 AD  opepm                  1      1
412 AD  oprf                   2      2
412 AD  opcapc                 3      3
412 AD  opletd                 4      4
412 AD  opwrnc                 5      5
412 AD  oprg1c                 6      8  1
412 AD  oprg2c                 9     11  1
412 AD  opimpi                12     12
412 AD  opmpck                14     14
412 AD  opten2               117    117
416aA
416aA*----------------------------------------------------------------
416aA*  *ZEROVFY -  Zero verify options
416aA*----------------------------------------------------------------
416aA*
416aA* Fields
416aA*
416aA*    OPVFYV  -  Verify virtual slot using RF (Y,N)
416aA*
416aA* Data structure
416aA*
416aAD opdat3          ds
416aAD  opvfyv                 1      1
416aAD  opten3               117    117

600cA*----------------------------------------------------------------
600cA*  *VIRTUAL  -  Virtual Slot options
600cA*----------------------------------------------------------------
600cA*
600cA* Fields
600cA*
600cA*    OPVALL  -  Always create Virtual slot. (Y/N)
600cA*    OPVPCK  -  Allow Virtual pick slots to be created.  (Y/N)
600cA*    OPVSLT  -  Create Virtual slot for item when base slot and
600cA*               corresponding Virtual slot(s) item(s) are different.
600cA*               Always Yes.
600cA*    OPVEXP  -  Create Virtual slot when item exists and
600cA*               expiration date is different.  (Y/N)
600cA*    OPVEND  -  Create Virtual slot when item exists and
600cA*               entered date is different.  (Y/N)
600cA*    OPVSAM  -  Merge product when entered/expiration dates
600cA*               are the same.  (Y/N)
600cA*    OPVEDF  -  Merge product when entered dates are different and
600cA*               expiration dates are the same.  (Y/N)
640xA*    OPVOVF  -  Allow Virtual overflow slots to be created (Y/N)
600cA*
600cA* Data structure
600cA*
600cAD opdat4          ds
600cAD  opvall                 1      1
600cAD  opvpck                 2      2
600cAD  opvslt                 3      3
600cAD  opvexp                 4      4
600cAD  opvend                 5      5
600cAD  opvsam                 6      6
600cAD  opvedf                 7      7
640xAD  opvovf                 8      8
600cAD  opten4               117    117

601aA*----------------------------------------------------------------
601aA*  *SLTFIFO  -  Pick slot FIFO information options
601aA*----------------------------------------------------------------
601aA*
601aA* Fields
601aA*
601aA*    OPPFF   -  Pick slot, use info from first FIFO license.
601aA*    OPPLF   -  Pick slot, use info from last FIFO license.
601aA*    OPPFNF  -  Pick slot, use info from first non-expired FIFO license.
601aA*
601aA* Data structure
601aA*
601aAD opdat5          ds
601aAD  oppff                  1      1
601aAD  opplf                  2      2
601aAD  oppfnf                 3      3
601aAD  optend               117    117
710nA*----------------------------------------------------------------
710nA*  *RFPUT   -  RF Putaway options
710nA*----------------------------------------------------------------
710nA*
710nA* Fields
710nA*
710nA*    OPVRFY  -  Verify scanned slot for manual putaway (Y,N)
710nA*    OPPQTY  -  Verify pallet quantity (Y,N)
710nA*    OPMSCN  -  Allow multiple license/labels to be scanned during
710nA*               putaway? (Y/N)
710nA*    OPISWN  -  Allow warning override on inactive slot edit.    g
710nA*
710nA* Data structure
710nA*
710nAD opdat6          ds
710nAD  opvrfy                 1      1
710nAD  oppqty                 2      2
710nAD  opmscn                 3      3
710nAD  opiswn                 4      4
710nAD  optend6              117    117
MQS A*----------------------------------------------------------------
MQS A*  *REPLEN  -  Replenishment options
MQS A*----------------------------------------------------------------
MQS A*
MQS A* Fields
MQS A*
MQS A*    OPRZST  -  Store Def in Slots
MQS A*
MQS A* Data structure
MQS A*
MQS AD opdat7          ds
MQS AD  oprzst                30     31
MQS AD  optend7              117    117

GFC A*----------------------------------------------------------------
GFC A*  Verify Subprogram Variables.
GFC A*----------------------------------------------------------------

GFC AD $cdCmd          s              8
GFC AD $cdDatein       s              8  0
GFC AD $cdTimein       s              6  0
GFC AD $cdYears        s              3  0
GFC AD $cdMonths       s              3  0
GFC AD $cdDays         s              3  0
GFC AD $cdHours        s              3  0
GFC AD $cdMinutes      s              3  0
GFC AD $cdSeconds      s              3  0
GFC AD $cdDateout      s              8  0
GFC AD $cdTimeout      s              6  0

     *----------------------------------------------------------------
     *  Called programs
     *----------------------------------------------------------------

     D @cvtdt          c                   const('CVTDTE')

     D $cvtdt          ds
     D  $cvcmd                 1      8
     D  $cvprg                 9     18
     D  $cvd6i                19     24
     D  $cvd8i                25     32
     D  $cvd6o                33     38  0
     D  $cvd8o                39     46  0
     D  $cvsto                47     64
     D  $cvrtn                65     72
     D  $cverm                73    132
     D  $cvmsg                73     76

500gA*----------------------------------------------------------------
500gA*  Called program parameters
500gA*----------------------------------------------------------------
500gA
500gAD $lparm          ds
     D  $lcmd                  1      8
     D  $lprg                  9     18
     D  $luky                 19     68
     D  $lrtn                 69     76
     D  $lerm                 77    136
     D  $lmsg                 77     80
     D  $ltype                81     88
     *
     *   Redefine key
     *
     D  $lwhse                19     21  0
     D  $ltrackitem           22     22
     D  $ltrackpos            23     23
     D  $lposmrg              24     24
     D  $lposrtn              25     25
     D  $lpsplit              26     26
     D  $ltsplit              27     27

     *----------------------------------------------------------------
     *  Program info data structure
     *----------------------------------------------------------------

     D                sds
     D  #prog            *proc
500gAD  #pgm             *proc
     D  #status               11     15
     D  #stmt                 21     28  0
     D  #pgmmsg               91    170
     D  #job                 244    253
     D  #user                254    263
     D  #jobn                264    269
     D  #jobnbr              264    269
     D  #jobdt               276    281  0
     D  #jobtm               282    287  0
600fAD  #curruser            358    367

600dA*----------------------------------------------------------------
600dA*  Tracking variables
600dA*----------------------------------------------------------------
600dA
600dA /COPY *libl/qcopysrc,c#trackvar

     *----------------------------------------------------------------
     *  File info data structures
     *----------------------------------------------------------------

     D File1DS         ds
     D  f1filename             1      8
     D  f1openind              9      9
     D  f1endoffile           10     10
     D  f1status              11     15  0
     D  f1opercode            16     21
     D  f1routine             22     29
     D  f1stmtnbr             30     37
     D  f1recordcd            38     45
     D  f1messageid           46     52
     D  f1sourceid            53     54

     D File2DS         ds
     D  f2filename             1      8
     D  f2openind              9      9
     D  f2endoffile           10     10
     D  f2status              11     15  0
     D  f2opercode            16     21
     D  f2routine             22     29
     D  f2stmtnbr             30     37
     D  f2recordcd            38     45
     D  f2messageid           46     52
     D  f2sourceid            53     54

     D File3DS         ds
     D  f3filename             1      8
     D  f3openind              9      9
     D  f3endoffile           10     10
     D  f3status              11     15  0
     D  f3opercode            16     21
     D  f3routine             22     29
     D  f3stmtnbr             30     37
     D  f3recordcd            38     45
     D  f3messageid           46     52
     D  f3sourceid            53     54

416bAD File4DS         ds
416bAD  f4filename             1      8
416bAD  f4openind              9      9
416bAD  f4endoffile           10     10
416bAD  f4status              11     15  0
416bAD  f4opercode            16     21
416bAD  f4routine             22     29
416bAD  f4stmtnbr             30     37
416bAD  f4recordcd            38     45
416bAD  f4messageid           46     52
416bAD  f4sourceid            53     54

416bAD File5DS         ds
416bAD  f5filename             1      8
416bAD  f5openind              9      9
416bAD  f5endoffile           10     10
416bAD  f5status              11     15  0
416bAD  f5opercode            16     21
416bAD  f5routine             22     29
416bAD  f5stmtnbr             30     37
416bAD  f5recordcd            38     45
416bAD  f5messageid           46     52
416bAD  f5sourceid            53     54

600tA*----------------------------------------------------------------
600tA*  Phrase Variables
600tA*----------------------------------------------------------------
600tA
600tA /COPY *libl/qcopysrc,c#phrasvar
600tAD  currFile       s             10
600tAD  currRoutine    s             20
600tAD  stackCount     s              3  0
600tAD  aRoutine       s             20    dim(30)
600tA
600tA*----------------------------------------------------------------
600tA*  Phrases
600tA*----------------------------------------------------------------
600tA
600tA /COPY *libl/qcopysrc,c#phrases

      *----------------------------------------------------------------
      *  Parameters
      *
      *    Input Parameters
      *      $psubcmd   Sub-command
      *      $pprogram  Calling program (the one that called interface)
      *      $pdata     Data needed by command
600fA *      $pdata2    Data needed by command
      *
      *    Returned Parameters
      *      $preturn   Return code
      *      $pmessage  Return code
      *      $pdata     Data returned by command
      *
      *----------------------------------------------------------------

      *----------------------------------------------------------------
      *  Let the show begin .....
      *----------------------------------------------------------------

     C     *entry        plist
     C                   parm                    $psubcmd
     C                   parm                    $pprogram
     C                   parm                    $preturn
     C                   parm                    $pmessage
     C                   parm                    $pdata
600fAC                   parm                    $pdata2

600fDC**                 eval      $slotinput     = $pdata
     C                   eval      $preturninput  = $preturn
     C                   eval      $pmessageinput = $pmessage
600tAC                   eval      stackCount = 0
750eAC                   eval      statChgOnly = *off

     C                   if        $preturn = '*NOUPDATE*'
     C                   eval      UpdateDakota = *off
     C                   else
     C                   eval      UpdateDakota = *on
     C                   endif

     C                   eval      $slot    = $pdata
600fAC                   eval      in$slot  = $pdata
600fAC                   if        %parms >= 6
600fAC                   eval      $slot2   = $pdata2
600fAC                   eval      in$slot2 = $pdata2
600fAC                   endif
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '

600dAC                   if        $slver# >= 8
600dAC                   if        $saemp#U
600dAC                   eval      emp#a = %editc($saemp#:'X')
600dAC                   else
600dAC                   eval      emp#a = '00000'
600dAC                   endif
600dAC                   endif

     *----------------------------------------------------------------
     * Main line
     *----------------------------------------------------------------
500lA
500lA* Get client id.
500lA
500lAC                   call      'GETCLIENT'
500lAC                   parm                    client           10
650uAC                   parm                    clientloc        10

     *  See which system is calling the program.

     C                   if        %subst($psubcmd:1:1) = '%'
     C                   eval      DakotaCall = *on
     C                   eval      HostCall   = *off
     C                   eval      %subst($psubcmd:1:1) = '*'
     C                   else
     C                   eval      HostCall   = *on
     C                   eval      DakotaCall = *off
     C                   endif

     *  See if we are just opening or closing program.

     C                   select

     C                   when      $psubcmd = '*OPEN'
     C                   eval      logit = *off
     C                   if        DakotaCall
     C                   exsr      callhost
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   endif
     C                   goto      bottom

     C                   when      $psubcmd = '*CLOSE'
     C                   eval      logit = *off
     C                   if        DakotaCall
     C                   exsr      callhost
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   endif
     C                   exsr      aaaclose
     C                   eval      *inlr = *on
     C                   goto      bottom

     C                   endsl

     *  Otherwise, do some initialization and move on.

     C                   exsr      aaainit
     C                   eval      error = *off

     *  Force right adjustment of certain fields.

     C                   exsr      rightadj

     *  Do what user has requested.

     C                   select

     C                   when      $psubcmd = '*ADD'
640mAC                             or $psubcmd = '*ADDWEB'
     C                   eval      logit = *on
     C                   if        DakotaCall
     C                   exsr      callhost
     C                   endif
     C                   if        UpdateDakota and not error
640mAC                   if        $psubcmd = '*ADDWEB'
640mAC                   exsr      DeleteSlotWeb
640mAC                   endif
     C                   exsr      verifygen
     C                   if        not error
     C                   exsr      verifyadd
     C                   if        not error
     C                   exsr      addslot
     C                   endif
     C                   endif
     C                   endif

     C                   when      $psubcmd = '*ADDVS'
     C                   eval      logit = *on
     C                   if        UpdateDakota
     C                   exsr      verifygen
     C                   if        not error
     C                   exsr      verifyadd
     C                   if        not error
     C                   exsr      addslot
     C                   endif
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

416jAC                   when      $psubcmd = '*ADDXDOCK' and DakotaCall
416jAC                   eval      logit = *on
416jAC                   exsr      callhost

416cAC                   when      $psubcmd = '*ADJUST'    or
710bAC                             $psubcmd = '*ADJUSTIMP' or
650pAC                             $psubcmd = '*ADJUSTREV' or
416cAC                             $psubcmd = '*ADJUSTORD' or
650qAC                             $psubcmd = '*ADJUSTPRD' or
610aAC                             $psubcmd = '*ADJUSTRTN' or
600mAC                             $psubcmd = '*ADJUSTOSS'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
416cAC                   exsr      verifyqtyadj
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtyadjust
     C                   endif
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
416cAC                   endif

416uAC                   when      $psubcmd = '*ADJUSTTFR'
416uAC                   if        DakotaCall
416uAC                   exsr      callhost
416uAC                   endif

416cAC                   when      $psubcmd = '*ALC2PCK'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtyalc2pck
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

416cAC                   when      $psubcmd = '*ALLOCATE'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtyallocate
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

     C                   when      $psubcmd = '*CHANGE'
     C                   eval      logit = *on
     C                   if        DakotaCall
     C                   exsr      callhost
     C                   endif
     C                   if        UpdateDakota and not error
     C                   exsr      verifygen
     C                   if        not error
     C                   exsr      verifychg
     C                   if        not error
     C                   exsr      savebefore
     C                   exsr      changeslot
     C                   endif
     C                   endif
     C                   endif

416nAC                   when      $psubcmd = '*CHGITEM'
416nAC                   eval      logit = *on
416nAC                   if        DakotaCall
416nAC                   exsr      callhost
416nAC                   endif
416nAC                   if        UpdateDakota and not error
416nAC                   exsr      vfychgitm
416nAC                   endif
416nAC                   if        not error
416nAC                   exsr      changeitem
416nAC                   endif

600kAC                   when      $psubcmd = '*CHKFIFO'
600kAC                   eval      logit = *off
600kAC                   exsr      vfychkfifo
600kAC                   if        not error
600kAC                   exsr      chkfifo
600kAC                   endif

416cAC                   when      $psubcmd = '*CLSPICK'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtyclspick
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

416cAC                   when      $psubcmd = '*CLSRCV'    or
417sMC                             $psubcmd = '*CLSRCVADJ' or
417hMC                             $psubcmd = '*CLSRTN'    or
600dDC**                           $psubcmd = '*STUFFIT'   or
417hMC                             $psubcmd = '*CLSPUTAWY' or
500xAC                             $psubcmd = '*CLSSTGPUT' or
417fMC                             $psubcmd = '*CLSTFRIN'  or
417hMC                             $psubcmd = '*CLSLETIN'  or
417hMC                             $psubcmd = '*CLSPRIN'   or
417hMC                             $psubcmd = '*CLSSSIN'   or
417fAC                             $psubcmd = '*CLSTFICHG' or
417hAC                             $psubcmd = '*CLSLTICHG' or
417hAC                             $psubcmd = '*CLSPRICHG' or
417hAC                             $psubcmd = '*CLSSSICHG'
xxxx C                   eval      $saqty1 = $saqty1
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
416cAC                   exsr      verifyrcv
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
600yAC                   eval      diffStatus = *off
416cAC                   exsr      qtyclsrcv
     C                   endif
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

417fMC                   when      $psubcmd = '*CLSTFROUT' or
417hAC                             $psubcmd = '*CLSLETOUT' or
417hAC                             $psubcmd = '*CLSPROUT'  or
417hAC                             $psubcmd = '*CLSSSOUT'  or
417fAC                             $psubcmd = '*CLSTFOCHG' or
417hAC                             $psubcmd = '*CLSLTOCHG' or
417hAC                             $psubcmd = '*CLSPROCHG' or
417hAC                             $psubcmd = '*CLSSSOCHG'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtyclstfrout
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

600mAC                   when      $psubcmd = '*CRTOSS'
600mAC                   eval      logit = *on
600mAC                   exsr      vfycrtoss
600mAC                   if        not error
600mAC                   exsr      getslot2USR
600mAC                   exsr      crtoss
600mAC                   endif

720 AC                   when      $psubcmd = '*CRTRPA'
720 AC                   eval      logit = *on
720 AC                   exsr      vfycrtrpa
720 AC                   if        not error
720 AC                   exsr      getslot2USR
720 AC                   exsr      crtrpa
720 AC                   endif

611eAC                   when      $psubcmd = '*CRTPRE'
611eAC                   eval      logit = *on
611eAC                   exsr      vfycrtpre
611eAC                   if        not error
611eAC                   exsr      getslot2USR
611hAC                   if        not error
611eAC                   exsr      crtpre
611hAC                   endif
611eAC                   endif

700dAC                   when      $psubcmd = '*CRTAMP'
700dAC                   eval      logit = *on
700dAC                   exsr      vfycrtamp
700dAC                   if        not error
700dAC                   exsr      getslot2USR
700dAC                   if        not error
700dAC                   exsr      crtamp
700dAC                   endif
700dAC                   endif

510dAC                   when      $psubcmd = '*CRTREPAKP' or
510dAC                             $psubcmd = '*CRTREPAKR' or
650hAC                             $psubcmd = '*CRTREPAKD'
510dAC                   eval      logit = *on
510dAC                   exsr      vfycrtrepack
510dAC                   if        not error
510dAC                   exsr      crtrepack
510dAC                   endif

650qAC                   when      $psubcmd = '*CRTPROD'
650qAC                               or $psubcmd = '*CRTPRODC'
650qAc                   eval      baseDisp = $sldisp
650qAC                   eval      logit = *on
650qAC                   exsr      vfycrtprod
650qAC                   if        not error
650qAC                   exsr      crtprod
650qAC                   endif

     C                   when      $psubcmd = '*CRTXDOCK'
     C                   eval      logit = *on
     C                   exsr      verifygetxdk
     C                   if        not error
     C                   exsr      crtxdock
     C                   endif

500nAC                   when      $psubcmd = '*CRTVPICK'
500nAC                   eval      logit = *on
500nAC                   exsr      vfycrtvpick
500nAC                   if        not error
500nAC                   exsr      crtvpick
500nAC                   endif

700cAC                   when      $psubcmd = '*CRTVOFLW'
700cAC                   eval      logit = *on
700cAC                   exsr      vfycrtvoflw
700cAC                   if        not error
700cAC                   exsr      crtvoflw
700cAC                   endif

     C                   when      $psubcmd = '*DELETE' or
     C                             $psubcmd = '*DELETEI' or
640mAC                             $psubcmd = '*DELETEWEB'
     C                   eval      logit = *on
     C                   if        DakotaCall
     C                   exsr      callhost
     C                   endif
     C                   if        UpdateDakota and not error
     C                   exsr      deleteslot
     C                   endif

     C                   when      $psubcmd = '*DELETEX'
     C                   eval      logit = *on
     C                   if        UpdateDakota
     C                   exsr      deleteslot
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

640tAC                   when      $psubcmd = '*DPUNDO'
640tAC                   eval      logit = *on
640tAC                   if        UpdateDakota
640tAC                   exsr      vfydpundo
640tAC                   if        not error
640tAC                   exsr      dpundo
640tAC                   endif
640tAC                   endif
640tAC                   if        DakotaCall and not error
640tAC                   exsr      callhost
640tAC                   endif

     C                   when      $psubcmd = '*SET2VFY'
     C                   eval      logit = *on
     C                   if        UpdateDakota
     C                   exsr      set2vfy
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

417cAC                   when      $psubcmd = '*ZEROVFY'
417cAC                   eval      logit = *on
417cAC                   if        UpdateDakota
417cAC                   exsr      zerovfy
417cAC                   endif
417cAC                   if        DakotaCall and not error
417cAC                   exsr      callhost
417cAC                   endif

417aMC                   when      $psubcmd = '*GET'     or
650eAC                             $psubcmd = '*GET2' or
417aAC                             $psubcmd = '*GETCHKV' or
601dAC                             $psubcmd = '*GETCHKVX'
     C                   eval      logit = *off
     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        not error
     C                   exsr      slot2ds
     C                   endif

417aMC                   when      $psubcmd = '*GETI'     or
417aAC                             $psubcmd = '*GETICHKV'
     C                   eval      logit = *off
     C                   eval      lock = *off
     C                   exsr      getslot1
     C                   if        not error
     C                   exsr      slot2ds
     C                   endif

510dAC                   when      $psubcmd = '*GETREPACK'
510dAC                   eval      logit = *off
510dAC                   exsr      verifygetrpk
510dAC                   if        not error
510dAC                   exsr      getrepack
510dAC                   if        not error
510dAC                   exsr      slot2ds
510dAC                   endif
510dAC                   endif

650hAC                   when      $psubcmd = '*GETODRRPK'
650hAC                   eval      logit = *off
650hAC                   exsr      verifyodrrpk
650hAC                   if        not error
650hAC                   exsr      getodrrpk
650hAC                   if        not error
650hAC                   exsr      slot2ds
650hAC                   endif
650hAC                   endif

416jAC                   when      $psubcmd = '*GETXDOCK'
416jAC                   eval      logit = *off
416jAC                   exsr      verifygetxdk
416jAC                   if        not error
416jAC                   exsr      getxdock
416jAC                   if        not error
416jAC                   exsr      slot2ds
416jAC                   endif
416jAC                   endif

500aAC                   when      $psubcmd = '*GETOVRFAV'
500bAC                             or $psubcmd = '*GETITEMAV'
500aAC                   eval      logit = *off
500aAC                   exsr      vfygetovrfav
500aAC                   if        not error
500aAC                   exsr      getovrfav
500aAC                   endif

416bAC                   when      (%subst($psubcmd:1:4) = '*NXT' or
416bAC                              %subst($psubcmd:1:4) = '*PRV') and
416bAC                             (%subst($psubcmd:5:5) = 'ITEM '  or
500 AC                              %subst($psubcmd:5:6) = 'ITEMAV' or
416bAC                              %subst($psubcmd:5:5) = 'OVRF '  or
417gAC                              %subst($psubcmd:5:6) = 'OVRFAV' or
416bAC                              %subst($psubcmd:5:5) = 'PICK '  or
416rAC                              %subst($psubcmd:5:6) = 'PICKAV' or
417aAC                              %subst($psubcmd:5:5) = 'VSLOT'  or
416bAC                              %subst($psubcmd:5:5) = 'SLOT '  or
416bAC                              %subst($psubcmd:5:5) = 'SLOTI')
     C                   eval      logit = *off
416bAC                   exsr      verifynxtprv
416bAC                   if        not error
416bAC                   exsr      nextprev
416bAC                   endif

416cAC                   when      $psubcmd = '*PCK2ALC'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtypck2alc
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

416cAC                   when      $psubcmd = '*PICK'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtypick
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

610gAC                   when      $psubcmd = '*QTY2PUT'
610gAC                             or $psubcmd = '*QTY2PUT0'
640tAC                             or $psubcmd = '*DPPUT'
610gAC                   eval      logit = *on
610gAC                   if        UpdateDakota
610gAC                   exsr      verifyqty
610gAC                   if        not error
610gAC                   exsr      verifyrcv
610gAC                   if        not error
610gAC                   exsr      savebefore
610gAC                   exsr      shiftssbqty
610gAC                   exsr      qty2slt
610gAC                   endif
610gAC                   endif
610gAC                   endif
610gAC                   if        DakotaCall and not error
610gAC                   exsr      callhost
610gAC                   endif

416cAC                   when      $psubcmd = '*RECEIVE'  or
417hMC                             $psubcmd = '*PUTAWAY'  or
500xAC                             $psubcmd = '*STAGEPUT' or
417hMC                             $psubcmd = '*RETURN'   or
417fMC                             $psubcmd = '*TFRIN'    or
417fAC                             $psubcmd = '*TFRINCHG' or
417hMC                             $psubcmd = '*LETIN'    or
417hAC                             $psubcmd = '*LETINCHG' or
417hMC                             $psubcmd = '*PRIN'     or
417hAC                             $psubcmd = '*PRINCHG'  or
417hMC                             $psubcmd = '*SSIN'     or
417hAC                             $psubcmd = '*SSINCHG'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
416cAC                   exsr      verifyrcv
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtyreceive
     C                   endif
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

600dAC                   when      $psubcmd = '*RCVIN'  or
720 AC                             $psubcmd = '*RPAIN'  or
700sAC                             $psubcmd = '*RTNIN'  or
730eAC                             $psubcmd = '*RWOIN'  or
600dAC                             $psubcmd = '*STGIN'  or
600dAC                             $psubcmd = '*OSSIN'  or
611eAC                             $psubcmd = '*PREIN'  or
700dAC                             $psubcmd = '*AMPIN'  or
600dAC                             $psubcmd = '*USRIN'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      verifyrcv
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      qtyInWhse
600fAC                   clear                   frm$Slot
600fAC                   clear                   frm$Slot2
600fAC                   eval      to$Slot = $slot
600fAC                   eval      to$Slot2 = $slot2
600fAC                   exsr      trackLcnsTo
600dAC                   endif
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

610dAC                   when      $psubcmd = '*SETFIFO'
610dAC                   eval      logit = *off
610dAC                   exsr      vfysetfifo
610dAC                   if        not error
610dAC                   exsr      setLicFifo
610dAC                   endif

GFC AC                   when      $psubcmd = '*SETFIFOG'
GFC AC                   exsr      updLicSlotExpd

710kAC                   when      $psubcmd = '*SETOLCNS'
710kAC                   eval      logit = *off
710kAC                   exsr      vfysetolcns
710kAC                   if        not error
710kAC                   exsr      setLicOLcns
710kAC                   endif

600iAC                   when      $psubcmd = '*STUFFDLT'
600iAC                   eval      logit = *on
600iAC                   if        UpdateDakota
600iAC                   exsr      vfystuffdlt
600iAC                   if        not error
600iAC                   exsr      stuffdlt
600iAC                   endif
600iAC                   endif

600dAC                   when      $psubcmd = '*STUFFIT'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      verifyrcv
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      stuffit
600dAC                   endif
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

600iAC                   when      $psubcmd = '*SYNCLCNS'
600iAC                   eval      logit = *on
600iAC                   if        UpdateDakota
600iAC                   exsr      vfysynclcns
600iAC                   if        not error
600iAC                   exsr      synclcns
600iAC                   endif
600iAC                   endif

600dAC                   when      $psubcmd = '*TFR2USR'
610sAC                             or $psubcmd = '*TFR2USRR'
640dAC                             or $psubcmd = '*TFR2USRN'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      tfr2usr
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

610wAC                   when      $psubcmd = '*SETSTAT'
610wAC                   eval      logit = *on
610wAC                   if        UpdateDakota
610wAC                   exsr      zzsetstat
610wAC                   endif

416eAC                   when      $psubcmd = '*SEQPTYRPL'
     C                   eval      logit = *off
416eAC                   exsr      seqprtyrpl

416cAC                   when      $psubcmd = '*STOCK'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtystock
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

416fMC                   when      $psubcmd = '*TFROUT' or
417hAC                             $psubcmd = '*LETOUT' or
417hAC                             $psubcmd = '*PROUT' or
417hAC                             $psubcmd = '*SSOUT' or
417fAC                             $psubcmd = '*TFROUTCHG' or
417hAC                             $psubcmd = '*LETOUTCHG' or
417hAC                             $psubcmd = '*PROUTCHG' or
417hAC                             $psubcmd = '*SSOUTCHG'
     C                   eval      logit = *on
416cAC                   if        UpdateDakota
416cAC                   exsr      verifyqty
416cAC                   if        not error
     C                   exsr      savebefore
416pAC                   exsr      shiftssbqty
416cAC                   exsr      qtytfrout
     C                   endif
     C                   endif
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

600dAC                   when      $psubcmd = '*USR2OSS'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      usr2oss
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

600dAC                   when      $psubcmd = '*USR2RCV'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      usr2rcv
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

720 AC                   when      $psubcmd = '*USR2RPA'
720 AC                   eval      logit = *on
720 AC                   if        UpdateDakota
720 AC                   exsr      verifyqty
720 AC                   if        not error
720 AC                   exsr      savebefore
720 AC                   exsr      shiftssbqty
720 AC                   exsr      usr2rpa
720 AC                   endif
720 AC                   endif
720 AC                   if        DakotaCall and not error
720 AC                   exsr      callhost
720 AC                   endif

700sAC                   when      $psubcmd = '*USR2RTNO'
700sAC                   eval      logit = *on
700sAC                   if        UpdateDakota
700sAC                   exsr      verifyqty
700sAC                   if        not error
700sAC                   exsr      savebefore
700sAC                   exsr      shiftssbqty
700sAC                   exsr      usr2rtno
700sAC                   endif
700sAC                   endif
700sAC                   if        DakotaCall and not error
700sAC                   exsr      callhost
700sAC                   endif

730eAC                   when      $psubcmd = '*USR2RWO'
730eAC                   eval      logit = *on
730eAC                   if        UpdateDakota
730eAC                   exsr      verifyqty
730eAC                   if        not error
730eAC                   exsr      savebefore
730eAC                   exsr      shiftssbqty
730eAC                   exsr      usr2rwo
730eAC                   endif
730eAC                   endif
730eAC                   if        DakotaCall and not error
730eAC                   exsr      callhost
730eAC                   endif

600dAC                   when      $psubcmd = '*USR2PUT'
600dAC                             or $psubcmd = '*USR2RTN'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyusr
600dAC                   if        not error
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      verifyrcv
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      usr2slt
600dAC                   endif
600dAC                   endif
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

600dAC                   when      $psubcmd = '*USR2STG'
600dAC                   eval      logit = *on
600dAC                   if        UpdateDakota
600dAC                   exsr      verifyqty
600dAC                   if        not error
600dAC                   exsr      savebefore
600dAC                   exsr      shiftssbqty
600dAC                   exsr      usr2stg
600dAC                   endif
600dAC                   endif
600dAC                   if        DakotaCall and not error
600dAC                   exsr      callhost
600dAC                   endif

416cAC                   when      $psubcmd = '*VERIFY'    or
416cAC                             $psubcmd = '*VERIFYORD'
     C                   eval      logit = *off
416cAC                   exsr      verifyqty
416cAC                   if        not error
416cAC                   exsr      verifyqtyadj
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif
416cAC                   endif

     C                   when      $psubcmd = '*VERIFYADD'
     C                   eval      logit = *off
     C                   exsr      verifygen
     C                   if        not error
     C                   exsr      verifyadd
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif
     C                   endif

     C                   when      $psubcmd = '*VERIFYCHG'
     C                   eval      logit = *off
     C                   exsr      verifygen
     C                   if        not error
     C                   exsr      verifychg
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif
     C                   endif

     C                   when      $psubcmd = '*VERIFYDEL'
     C                   eval      logit = *off
     C                   exsr      deleteslot
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

417fMC                   when      $psubcmd = '*VERIFYTFI' or
417hAC                             $psubcmd = '*VERIFYLTI' or
417hAC                             $psubcmd = '*VERIFYPRI' or
417hAC                             $psubcmd = '*VERIFYSSI' or
417fAC                             $psubcmd = '*VFYTFICHG' or
417hAC                             $psubcmd = '*VFYLTICHG' or
417hAC                             $psubcmd = '*VFYPRICHG' or
417hAC                             $psubcmd = '*VFYSSICHG' or
500eAC                             $psubcmd = '*VERIFYPUT' or
500xAC                             $psubcmd = '*VFYSTGPUT' or
500eAC                             $psubcmd = '*VERIFYRTN' or
500iAC                             $psubcmd = '*VERIFYSI'
416oAC                   eval      logit = *off
416oAC                   exsr      verifyqty
416oAC                   if        not error
416cAC                   exsr      verifyrcv
416cAC                   if        not error
416cAC                   exsr      qtyreceive
416oAC                   endif
416oAC                   endif
416oAC                   if        DakotaCall and not error
416oAC                   exsr      callhost
416oAC                   endif

417fMC                   when      $psubcmd = '*VERIFYTFO' or
417hAC                             $psubcmd = '*VERIFYLTO' or
417hAC                             $psubcmd = '*VERIFYPRO' or
417hAC                             $psubcmd = '*VERIFYSSO' or
417fAC                             $psubcmd = '*VFYTFOCHG' or
417hAC                             $psubcmd = '*VFYLTOCHG' or
417hAC                             $psubcmd = '*VFYPROCHG' or
417hAC                             $psubcmd = '*VFYSSOCHG'
     C                   eval      logit = *off
416cAC                   exsr      verifyqty
416cAC                   if        not error
416cAC                   exsr      qtytfrout
416cAC                   endif
416oAC                   if        DakotaCall and not error
416oAC                   exsr      callhost
416oAC                   endif

416nAC                   when      $psubcmd = '*VFYCHGITM'
416nAC                   eval      logit = *off
416nAC                   exsr      vfychgitm
     C                   if        DakotaCall and not error
     C                   exsr      callhost
     C                   endif

500jAC                   when      $psubcmd = '*VFYCLSTFI'  or
500jAC                             $psubcmd = '*VFYCLSLTI'  or
500jAC                             $psubcmd = '*VFYCLSPRI'  or
500jAC                             $psubcmd = '*VFYCLSSSI'  or
500jAC                             $psubcmd = '*VFYCLSTIC'  or
500jAC                             $psubcmd = '*VFYCLSLIC'  or
500jAC                             $psubcmd = '*VFYCLSPIC'  or
500jAC                             $psubcmd = '*VFYCLSSIC'
500jAC                   eval      $saqty1 = $saqty1
500jAC                   eval      logit = *on
500jAC                   if        UpdateDakota
500jAC                   exsr      verifyqty
500jAC                   if        not error
500jAC                   exsr      verifyrcv
500jAC                   if        not error
500jAC                   exsr      savebefore
500jAC                   exsr      shiftssbqty
600yAC                   eval      diffStatus = *off
500jAC                   exsr      qtyclsrcv
500jAC                   endif
500jAC                   endif
500jAC                   endif
500jAC                   if        DakotaCall and not error
500jAC                   exsr      callhost
500jAC                   endif

500jAC                   when      $psubcmd = '*VFYCLSTFO'  or
500jAC                             $psubcmd = '*VFYCLSLTO'  or
500jAC                             $psubcmd = '*VFYCLSPRO'  or
500jAC                             $psubcmd = '*VFYCLSSSO'  or
500jAC                             $psubcmd = '*VFYCLSTOC'  or
500jAC                             $psubcmd = '*VFYCLSLOC'  or
500jAC                             $psubcmd = '*VFYCLSPOC'  or
500jAC                             $psubcmd = '*VFYCLSSOC'
500jAC                   eval      $saqty1 = $saqty1
500jAC                   eval      logit = *on
500jAC                   if        UpdateDakota
500jAC                   exsr      verifyqty
500jAC                   if        not error
500jAC                   exsr      savebefore
500jAC                   exsr      shiftssbqty
500jAC                   exsr      qtyclstfrout
500jAC                   endif
500jAC                   endif
500jAC                   if        DakotaCall and not error
500jAC                   exsr      callhost
500jAC                   endif

610gAC                   when      $psubcmd = '*VFYINSLOT'
610gAC                   eval      logit = *on
610gAC                   exsr      vfyinslot

600dAC                   when      $psubcmd = '*VFYLICSLT'
600dAC                   eval      logit = *on
600dAC                   exsr      vfylicslt

GFC AC                   when      $psubcmd = '*ZEROEXPD'
GFC AC                   exsr      zeroSlotExpd
GFC AC                   exsr      zeroLicExpd

     C                   other
     C                   eval      logit = *on
     C                   eval      error = *on
     C                   eval      $preturn = 'INVLDSBCMD'
     C                   exsr      getmsg

     C                   endsl

     C     bottom        tag

     *  Log it

     C                   if        logit
     C                   exsr      writelog
     C                   endif

     *  Make sure that nothing is locked.

     C                   exsr      unlock

     *  We are finished so get out

     C                   eval      $pdata = $slot
600fAC                   if        %parms >= 6
600fAC                   eval      $pdata2 = $slot2
600fAC                   endif
     C                   return

     *----------------------------------------------------------------
     *          SUBROUTINES IN ALPHABETICAL ORDER
     *----------------------------------------------------------------

     *----------------------------------------------------------------
     *  *INZSR  Initialization subrotine
     *----------------------------------------------------------------

     C     *inzsr        begsr

     * Key definitions

     *  Define key for SLOT1 file.

     C     keysl1        klist
     C                   kfld                    $slwhse
     C                   kfld                    $slwhdp
     C                   kfld                    $slaisl
     C                   kfld                    $slloc
     C                   kfld                    $slrlvl
     C                   kfld                    $slhand

611hA*  Define partial key for SLOT11 file.
611hA
611hAC     keysl11asl    klist
611hAC                   kfld                    $slwhse
611hMC                   kfld                    $slaisl

611hM*  Define partial key for SLOT11 file.
611eA
611hMC     keysl11loc    klist
611eAC                   kfld                    $slwhse
611hMC                   kfld                    $slaisl
611hAC                   kfld                    $slloc

611hM*  Define partial key for SLOT11 file.
611eA
611hMC     keysl11lvl    klist
611eAC                   kfld                    $slwhse
611hMC                   kfld                    $slaisl
611hMC                   kfld                    $slloc
611hMC                   kfld                    $slrlvl

600iA*  Define partial key for SLOT1 file.
600iA
600iAC     keysl1p       klist
600iAC                   kfld                    $slwhse
600iAC                   kfld                    $slwhdp
600iAC                   kfld                    $slaisl
600iAC                   kfld                    $slloc
600iAC                   kfld                    $slrlvl
600dA
600dA*  Define partial key for SLOT1 file.
600dA
600dAC     keysl2whse    klist
601hMC                   kfld                    kywhse
600dA
600dA*  Define partial key for SLOT1 file.
600dA
600dAC     keysl2whdp    klist
601hMC                   kfld                    kywhse
601hMC                   kfld                    kywhdp
600dA
600dA*  Define partial key for SLOT1 file.
600dA
600dAC     keysl2disp    klist
601hMC                   kfld                    kywhse
601hMC                   kfld                    kywhdp
601hMC                   kfld                    kydisp
416jA
416jA*  Define partial key for SLOT1 file for xdock lookup
416jA
416jAC     keys1x        klist
     C                   kfld                    $slwhse
     C                   kfld                    #slotwhdp
     C                   kfld                    kyaisl

     *  Define key for SLOT2 file.

     C     keysl2        klist
     C                   kfld                    kywhse
     C                   kfld                    kywhdp
     C                   kfld                    kydisp
610lA
610lA*  Define parital key for SLOT2 file for SYNCLCS
610lA
610lAC     Ksyncwhse     klist
     C                   kfld                    kyswhse
610lA
610lA*  Define parital key for SLOT2 file for SYNCLCS
610lA
610lAC     Ksyncwhdp     klist
     C                   kfld                    kyswhse
     C                   kfld                    kyswhdp
610lA
610lA*  Define parital key for SLOT2 file for SYNCLCS
610lA
610lAC     Ksyncdisp     klist
     C                   kfld                    kyswhse
     C                   kfld                    kyswhdp
     C                   kfld                    kysdisp
416bA
416bA*  Define key for SLOT3 file.
416bA
416bAC     keysl3        klist
     C                   kfld                    $slwhse
     C                   kfld                    $slitem
     C                   kfld                    $slstat
     C                   kfld                    $slpick
     C                   kfld                    $slprty
     C                   kfld                    $slexpd
     C                   kfld                    $slentd
     C                   kfld                    $slwhdp
     C                   kfld                    $slstyp
     C                   kfld                    $slaisl
     C                   kfld                    $slpseq
     C                   kfld                    $slrlvl
     C                   kfld                    $slhand
416bA
416bA*  Define partial key for SLOT3 file.
416bA
416bAC     keysl3p1      klist
     C                   kfld                    $slwhse
     C                   kfld                    $slitem
     C                   kfld                    $slstat
416bA
416bA*  Define partial key for SLOT3 file.
416bA
416bAC     keysl3p2      klist
     C                   kfld                    $slwhse
     C                   kfld                    $slitem
     C                   kfld                    $slstat
     C                   kfld                    $slpick
700gA*  Define partial key for SLOT13 file.
700gA
700gAC     keysl3p2x     klist
700gAC                   kfld                    $slwhse
700gAC                   kfld                    $slitem
700gAC                   kfld                    $slstat
700gAC                   kfld                    $slpick
700gAC                   kfld                    $slprty
700gAC                   kfld                    $slexpd
700gAC                   kfld                    $slentd
GFC A
GFC A*  Define partial key for SLOT3 file.
GFC A
GFC AC     keysl3p3      klist
GFC AC                   kfld                    $slwhse
GFC AC                   kfld                    $slitem
416jA
416jA*  Define partial key for SLOT3 file for xdock lookup.
416jA
416jAC     keysl3x       klist
     C                   kfld                    $slwhse
     C                   kfld                    #slotitem
     C                   kfld                    kystat
650hA
650hA*  Define partial key for SLOT3 file for xdock lookup.
650hA
650hAC     keyss3x       klist
650hAC                   kfld                    $slwhse
650hAC                   kfld                    #sentitem
650hAC                   kfld                    kystat
416bA
416bA*  Define partial key for SLOT1/2.
416bA
416bAC     keyslp        klist
     C                   kfld                    $slwhse
     C                   kfld                    $slwhdp
417eA
417eA*  Define key for SLOTDGT.
417eA
417eAC     keyscd        klist
     C                   kfld                    $slwhse
     C                   kfld                    $slwhdp
     C                   kfld                    $sldisp

     *  Define key for VSLOT file.

     C     keyvs         klist
     C                   kfld                    slwhse
     C                   kfld                    slwhdp
     C                   kfld                    slaisl
     C                   kfld                    slloc
     C                   kfld                    slrlvl
     C                   kfld                    slhand

417qA*  Define key for VSLOT file using parm fields.
417qA
417qAC     keyvs$        klist
417qAC                   kfld                    $slwhse
417qAC                   kfld                    $slwhdp
417qAC                   kfld                    $slaisl
417qAC                   kfld                    $slloc
417qAC                   kfld                    $slrlvl
417qAC                   kfld                    $slhand

     *  Define key for VSLOT2 file.

     C     keyvs2        klist
     C                   kfld                    slwhse
     C                   kfld                    slwhdp
     C                   kfld                    sldisp

500gA*  Define key for VSLOT2 file for look4slot routine.
500gA
500gAC     keyvs2l4      klist
     C                   kfld                    $slwhse
     C                   kfld                    $slwhdp
     C                   kfld                    $sldisp

417aA*  Define key for VSLOT2 file using parm fields.
417aA*    $sacdsp contains Base slot.
417aA
417aAC     keyvs2$       klist
     C                   kfld                    $slwhse
     C                   kfld                    $slwhdp
     C                   kfld                    $sacdsp

417aA*  Define full key for VSLOT2 file using parm fields.
417aA*    $sacdsp contains Base (Parent) slot.
417aA
417aAC     keyvs2$f      klist
     C                   kfld                    $slwhse
     C                   kfld                    $slwhdp
     C                   kfld                    $sacdsp
     C                   kfld                    $sldisp

     *  Define key for options file, System values.

     C     keyop         klist
     C                   kfld                    kywhse
     C                   kfld                    opcode
417cA*
417cA*  Define key to get virtual slot.
417cA*
417cAC     keysl2vs      klist
417cAC                   kfld                    vswhse
417cAC                   kfld                    vswhdp
417cAC                   kfld                    vsdisp
611fA
611fA*  Define partial key for WORKUSR1 file.
611fA
611fAC     keywu1        klist
611fAC                   kfld                    kywhse

710nA*   Get RFPUT  options.
710nA
710nA /free
710nA   kywhse = 0;
710nA   opcode = '*RFPUT';
710nA   chain (kywhse: opcode) options;
710nA   if not %found(options);
710nA     opiswn = 'N';
710nA   else;
710nA     opdat6 = opdata;
710nA   endif;
710nA /end-free
     *   Get system options.

     C                   eval      kywhse = *zeros
     C                   eval      opcode = '*SYSTEM '
     C     keyop         chain     options
 1B  C                   if        not %found
     C                   eval      opmpck = 'N'
 1X  C                   else
     C                   eval      opdat2 = opdata
 1E  C                   endif

     *   Load handstack array with codes (A..Z, AA..AZ, ...)
610xA*   This will create 702 codes.

     C                   eval      k = 0
 1B  C     1             do        27            i
 2B  C     2             do        27            j
     C                   add       1             k
 2E  C                   eval      hnd(k) = ltr(i) + ltr(j)
 2E  C                   enddo
 1E  C                   enddo

610xA*   Now tack on codes that start with a number (0 - 9)
610xA*   This will add 260 codes for a total of 962.
610xA
610xAC     1             do        10            i
610xAC     2             do        27            j
610xAC                   add       1             k
610xAC                   eval      hnd(k) = nbr(i) + ltr(j)
610xAC                   enddo
610xAC                   enddo
600dA
600dA*   Get aisles to use for RCV/STG/OSS/USRIN commands.
600dA
600dAC                   eval      aisleRCV = 'RCV'
720 AC                   eval      aisleRPA = 'RPA'
700sAC                   eval      aisleRTN = 'RTN'
730eAC                   eval      aisleRWO = 'RWO'
600dAC                   eval      aisleSTG = 'STG'
600dAC                   eval      aisleOSS = 'OSS'
600dAC                   eval      aisleUSR = 'USR'

     C                   endsr

     *----------------------------------------------------------------
     *  *PSSR  Unexpected error handler
     *----------------------------------------------------------------

     C     *pssr         begsr
600tAC                   eval      currRoutine = '*PSSR'

     *  Make sure we don't get caught in an infinite loop

 1B  C                   if        pssrflag
     C                   eval      *inlr = *on
     C                   return
     C                   endif

     C                   eval      pssrflag = *on

600tAC                   exsr      phPgmV1V2V3s

     *  Send message back to calling program.

     C                   eval      $preturn = 'U:' + #status
     C                   eval      $pmessage = 'U:'
     C                                       + %trim(#prog)
     C                                       + '('
     C                                       + %trim(%editc(#stmt:'Z'))
     C                                       + ')-'
     C                                       + #pgmmsg
     C                   eval      *inlr = *on
 1E  C                   return

     C                   endsr

     *----------------------------------------------------------------
     *  aaainit   Pre-subcommand initialization.
     *----------------------------------------------------------------

     C     aaainit       begsr
650qA /free
650qA                    sltc = 1;
650qA                    dow sltc < 101;
650qA                       prdslt(sltc) = '   ';
650qA                       sltc = sltc +1;
650qA                    enddo;
650qA
650qA                    setll (*zeros:*zeros) plined;
650qA                    read plined;
650qA                    dow not %eof(plined);
650qA
650qA                       sltc = 1;
650qA                       // look for raw material aisle location
650qA                       dow sltc < 101;
650qA                          if prdslt(sltc) = '   '
650qA                              or prdslt(sltc) = inRcvAisl;
650qA                             leave;
650qA                          endif;
650qA                          sltc = sltc +1;
650qA                       enddo;
650qA                       // if comes out blank it means we should
650qA                       // add to the array of prod slot aisles
650qA                       if prdslt(sltc) = '   ';
650qA                          prdslt(sltc) = inRcvAisl;
650qA                       endif;
650qA
650qA                       sltc = 1;
650qA                       // look for Customer Order aisle location
650qA                       dow sltc < 101;
650qA                          if prdslt(sltc) = '   '
650qA                              or prdslt(sltc) = inPckAisl;
650qA                             leave;
650qA                          endif;
650qA                          sltc = sltc +1;
650qA                       enddo;
650qA                       // if comes out blank it means we should
650qA                       // add to the array of prod slot aisles
650qA                       if prdslt(sltc) = '   ';
650qA                          prdslt(sltc) = inPckAisl;
650qA                       endif;
650qA
650qA                       sltc = 1;
650qA                       // look for PAR Stock aisle location
650qA                       dow sltc < 101;
650qA                          if prdslt(sltc) = '   '
650qA                              or prdslt(sltc) = inStkAisl;
650qA                             leave;
650qA                          endif;
650qA                          sltc = sltc +1;
650qA                       enddo;
650qA                       // if comes out blank it means we should
650qA                       // add to the array of prod slot aisles
650qA                       if prdslt(sltc) = '   ';
650qA                          prdslt(sltc) = inStkAisl;
650qA                       endif;
650qA
650qA                       sltc = 1;
650qA                       // look for WIP Stock aisle location
650qA                       dow sltc < 101;
650qA                          if prdslt(sltc) = '   '
650qA                              or prdslt(sltc) = inWipAisl;
650qA                             leave;
650qA                          endif;
650qA                          sltc = sltc +1;
650qA                       enddo;
650qA                       // if comes out blank it means we should
650qA                       // add to the array of prod slot aisles
650qA                       if prdslt(sltc) = '   ';
650qA                          prdslt(sltc) = inWipAisl;
650qA                       endif;
650qA
650qA                       read plined;
650qA                    enddo;
650qA /end-free
MQS A*
MQS A*   get Replenishment options
MQS A*
MQS Ac                   if        client = Marques
MQS AC                   eval      kywhse = $slwhse
MQS AC                   eval      opcode = '*REPLEN'
MQS AC     keyop         chain     options
MQS AC                   if        %found
MQS AC                   eval      opdat7 = opdata
MQS AC                   else
MQS AC                   eval      oprzst=*blanks
MQS AC                   endif
MQS AC                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  aaaclose   Close called programs
     *----------------------------------------------------------------

     C     aaaclose      begsr

600eaC                   eval      $drisubcmd = '*CLOSE'

     C                   if        dridept
600eMC                   eval      $dricommand = 'DRIDEPT'
600eMC                   exsr      zzzdrimain3
     C                   endif

     C                   if        dridesig
600eMC                   eval      $dricommand = 'DRIDESIG'
600eMC                   exsr      zzzdrimain3
     C                   endif

     C                   if        driitem
600eMC                   eval      $dricommand = 'DRIITEM'
600eMC                   exsr      zzzdrimain3
     C                   endif

     C                   if        driitemqty
600eMC                   eval      $dricommand = 'DRIITEMQTY'
600eMC                   exsr      zzzdrimain3
     C                   endif

600fAC                   if        drilicense
600fAC                   eval      $dricommand = 'DRILICENSE'
600fAC                   exsr      zzzdrimain3
600fAC                   endif

600fAC                   if        drislotdef
600fAC                   eval      $dricommand = 'DRISLOTDEF'
600fAC                   exsr      zzzdrimain3
600fAC                   endif

500gAC                   if        drilichist
500gAC                   call(e)   'DRILICHIST'
500gAC                   parm      '*CLOSE'      $drisubcmd
500gAC                   parm      $pprogram     $driprogram
500gAC                   parm      ' '           $drireturn
500gAC                   parm      ' '           $drimessage
500gAC                   parm      ' '           $dridata
500gAC                   if        %error
500gAC                   endif
500gAC                   endif

500gAC                   if        drilicinfo
600eMC                   eval      $dricommand = 'DRILICINFO'
600eMC                   exsr      zzzdrimain3
500gAC                   endif

     C                   if        driprtyrpl
600eMC                   eval      $dricommand = 'DRIPRTYRPL'
600eMC                   exsr      zzzdrimain3
     C                   endif

     C                   if        vfywhse
     C                   call(e)   'VFYWHSE'
     C                   parm      '*CLOSE'      $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      0             $vwhse
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        vfysdef
     C                   call(e)   'VFYSDEF'
     C                   parm      '*CLOSE'      $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      0             $vwhse
     C                   parm      ' '           $vsdef
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        vfysstat
     C                   call(e)   'VFYSSTAT'
     C                   parm      '*CLOSE'      $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      ' '           $vstat
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        vfybld
     C                   call(e)   'VFYBLD'
     C                   parm      '*CLOSE'      $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      ' '           $vbld
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        vfyactv
     C                   call(e)   'VFYACTV'
     C                   parm      '*CLOSE'      $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      ' '           $vactv
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        vfyadjc
     C                   call(e)   'VFYADJC'
     C                   parm      '*CLOSE'      $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      ' '           $vcode
416aAC                   parm      ' '           $vsys
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk
     C                   if        %error
     C                   endif
     C                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  addslot  Add slot record.
     *----------------------------------------------------------------

     C     addslot       begsr
600tAC                   eval      currRoutine = 'addslot'
600tAC                   exsr      phpgmV1V2V3s

     *  Make sure file is open.

     C                   if        not %open(slot1)
     C                   exsr      openslot1
     C                   if        error
     C                   goto      endaddslot
     C                   endif
     C                   endif

     *  Get current date and time.

     C                   exsr      getdatetime

     *  Clear slot record.

     C                   clear                   slrec

     *  Move information into slot fields.

     C                   eval      slwhse = $slwhse
     C                   eval      slwhdp = $slwhdp
     C                   eval      sldisp = $sldisp
     C                   eval      slaisl = $slaisl
     C                   eval      slloc  = $slloc
     C                   eval      slrlvl = $slrlvl
     C                   eval      slhand = $slhand
     C                   if        $psubcmd = '*ADDXDK'
     C                   eval      slstyp = 'X'
     C                   eval      slstat = 'XD'
     C                   else
     C                   eval      slstyp = $slstyp
     C                   eval      slstat = $slstat
     C                   endif
     C                   eval      slsdef = $slsdef

     C                   if        $sldesgu
     C                   eval      sldesg = $sldesg
     C                   endif

     C                   if        $slactvu
     C                   eval      slactv = $slactv
     C                   endif

     C                   if        $slbldu
     C                   eval      slbld  = $slbld
     C                   endif

     C                   if        $slpicku
     C                   eval      slpick = $slpick
     C                   else
     C                   eval      slpick = 'N'
     C                   endif

     C                   if        $slpsequ
     C                   eval      slpseq = $slpseq
     C                   endif

     C                   if        $slprtyu
     C                   eval      slprty = $slprty
     C                   endif

     C                   if        $slexpdu
     C                   eval      slexpd = $slexpd
     C                   endif

     C                   if        $slslfdu
     C                   eval      slslfd = $slslfd
     C                   endif

     C                   if        $slrsrvu
     C                   eval      slrsrv = $slrsrv
     C                   endif

     C                   if        $slitemu
     C                   eval      slitem = $slitem
     C                   endif

     *  Set status date & time.

     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime

     *  Set enter date if item is not blank.

     C                   if        slitem <> ' '
     C                   eval      slentd = curdate
     C                   endif

     *  Calculate side.

     C     slloc         div       2             dummy
     C                   mvr                     slside

     *  Add record

     C                   write(e)  slrec
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'ERRADDREC'
     C                   eval      $pmessage = 'Error on "Write '
     C                                       + 'Slot" command '
     C                                       + '('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'
     C                                       + '-' + f1messageid
     C                   goto      endaddslot
GFCaA*
GFCaAC                   else
GFCaA*
GFCaAC                   if        client = Glazier
SFGeAC                             or client = SGC
FPR AC                             or client = FoodPro
GMMdAC                             or client = MenuMaker
GFCaA*
GFCaA*      Call Host interface pgm to update Host pick slot.
GFCaAC                   if            Slitem > ' '
GFCaAC                             and Slpick = 'Y'
GFCcAC                             and Slstat <> 'Z'
GFCcAC                             and Slstat <> 'V'
GFCcAC                             and Slstat <> 'XD'
FPRfA*
FPRfAC                             or client = FoodPro
FPRfAC                             and Slpick = 'N'
FPRfAC                             and (%subst(sldisp:1:4) = 'WHS2'
FPRfAC                               or %subst(sldisp:1:4) = 'WHS4')
FPRfAC                             and Slstat <> 'Z'
FPRfAC                             and Slstat <> 'V'
FPRfAC                             and Slstat <> 'XD'
GFCaA
GFCaA*  Get live status for item's department.
GFCaAC                   call      'CHKLIVE'
GFCdAC                   parm      slwhse        $cwhse            3 0
GFCaAC                   parm                    slwhdp
GFCaAC                   parm                    livestat          8
GFCaA
GFCaA*  If department is not live, then read next item.
GFCaAC                   if        livestat = '*LIVE'
GFCaA
GFCaAC                   eval      $rwhse = %editc(slwhse:'X')
GFCaAC                   call      'HIT735CL'
GFCaAC                   parm      '*UPDPCKSLT'  $rcmd            10
GFCaAC                   parm                    $rwhse            3
GFCaAC                   parm      slitem        $ritem           15
GFCaAC                   parm      sldisp        $rdisp           12
700 AC                   parm      slstat        $rstat            2
GFCaAC                   parm      ' '           $rrtn             8
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
     C                   endif

     C     endaddslot    endsr

     *----------------------------------------------------------------
     *  calcqtys  Calculate slot quantities.
     *----------------------------------------------------------------

     C     calcqtys      begsr
600tAC                   eval      currRoutine = 'calcqtys'
600tAC                   exsr      phpgmV1V2V3s

     *  Calculate physical quantity in slot.

     *    Note: The quantities that are used to calculate the physical
     *          slot quantity are part of processes which should be
     *          completed soon. We can not wait until the processes
     *          are closed to say the stock is or isn't there.

     *          For example: A replenishment request can not be refused
     *          because the picks that depleted the slot have not been
     *          closed yet. Timing is everything.

     C                   eval      slphy1 = (slstk1+slrcv1)-(sltfr1+slpck1)
     C                   eval      slphy2 = (slstk2+slrcv2)-(sltfr2+slpck2)
     C                   eval      slphy3 = (slstk3+slrcv3)-(sltfr3+slpck3)

     *  Calculate available quantity in slot.

     C                   eval      slavl1 = slphy1 - slalc1
     C                   eval      slavl2 = slphy2 - slalc2
     C                   eval      slavl3 = slphy3 - slalc3

650eAc                   if        $psubcmd = '*GET2'
730cAc                             or $psubcmd = '*NXTSLOT' and
730cAc                                $pprogram = 'RTC330'
650eAc                   z-add     slwhse        $pwhse            3 0
650eAc                   z-add     slstk1        $stk1             5 0
650eAc                   z-add     slstk2        $stk2             5 0
650eAc                   z-add     slstk3        $stk3             5 0
650eA*  Call program to determine picked quantities picked from said
650eA*  location but not yet finalized
650eAc                   call      'SLTPCKQTY'
650eAc                   parm                    $pwhse
650eAc                   parm                    slwhdp
650eAc                   parm                    sldisp
650eAc                   parm                    slitem
650eAc                   parm                    pckqty1           5 0
650eAc                   parm                    pckqty2           5 0
650eAc                   parm                    pckqty3           5 0
650eAc                   parm                    $stk1
650eAc                   parm                    $stk2
650eAc                   parm                    $stk3
650eAc                   parm                    $return           8

650eAc                   eval      slphy1 = pckqty1
650eAc                   eval      slphy2 = pckqty2
650eAc                   eval      slphy3 = pckqty3
650aAc                   endif

     *  Calculate adjustable quantity in slot.

     C                   eval      sladj1 = slavl1 - slrcv1
     C                   eval      sladj2 = slavl2 - slrcv2
     C                   eval      sladj3 = slavl3 - slrcv3

     C                   endsr

610vA*----------------------------------------------------------------
610vA*  CalcSLLOC  Calculate SLLOC for getslot2usr routine
610vA*----------------------------------------------------------------
610vA
610vAC     CalcSLLOC     begsr

     C                   eval      temp6a = %trim($saToArea)
     C                   eval      slloc = 0

     C                   for       i = 1 to 6

     C                   eval      pos = %scan(%subst(temp6a:i:1):ltrnbr)

     C                   if        pos = 0
     C                   iter
     C                   endif

     C                   eval      slloc = slloc + pos + (36 * (i-1))

     C                   endfor

     C                   endsr

     *----------------------------------------------------------------
     *  callhost   Call host program.
     *----------------------------------------------------------------

     C     callhost      begsr
600tAC                   eval      currRoutine = 'callhost'
600tAC                   exsr      phpgmV1V2V3s

500hAC                   goto      endcallhost

     C                   if        UpdateDakota = *off
     C                   eval      $drireturn = '*LEGACY*'
     C                   else
     C                   eval      $drireturn = ' '
     C                   endif

     C                   call(e)   'DRIMAIN2'
     C                   parm      '*SLOT'       $dricommand
     C                   parm      $psubcmd      $drisubcmd
     C                   parm      'H'           $drisys2upd
     C                   parm      $pprogram     $driprogram
     C                   parm      ' '           $drireturn
     C                   parm      ' '           $drimessage
     C                   parm      $slot         $dridata

     C                   select

     C                   when      %error
     C                   eval      error = *on
     C                   eval      $preturn  = '*CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'DRIMAIN2'
     C                                       + '/' + %trim($dricommand)
     C                                       + '/' + %trim($drisubcmd)
     C                                       + ' from ' + #prog

     C                   when      $drireturn <> '*OK'        and
     C                             $drireturn <> '*NOPROGRAM'
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = 'H:' + $drimessage

     C                   endsl

     *  If calling Dakota program already performed the operation
     *    then we ignore any errors from the host.

     C                   if        UpdateDakota = *off
     C                   eval      $preturn  = '*OK'
     C                   eval      $pmessage = ' '
     C                   endif

500hMC     endcallhost   endsr

416nA*----------------------------------------------------------------
416nA*  changeitem  Change item in slot - Part 1
416nA*----------------------------------------------------------------
416nA
416nAC     changeitem    begsr
600tAC                   eval      currRoutine = 'changeitem'
600tAC                   exsr      phpgmV1V2V3s

     *  Get & Lock slot.

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endchangeitem
     C                   endif

     *  Get current date and time.

     C                   exsr      getdatetime

     *  Do adjustment for original item ...

600vAC                   eval      svitem = $saitem
600vAC                   eval      $saitem = slitem
     C                   eval      #slotitem = slitem
611jAC                   if        svitem <> $saitem
SPIaA /free
SPIaA    select;
SPIaA      when client = SternProduce
SFPaA       or client = Seashore;
SPIaA        $sacode = 'PA';
SPIaA        GetRecId($slwhse: 'WR112': recidnum);
SPIaA        $samemo = 'RPK ' + %editc(recidnum:'X');
SPIaA      other;
SPIaA /end-free
640qAC                   if        $samemou = '1'
640qAc                   eval      memo11 = $samemo
640qAc                   endif
611jAC     'To'          cat       svitem:1      $samemo
640qAC                   if        $samemou = '1'
640qac                   eval      $samemo = %replace(memo11:$samemo:20:11)
640qAc                   endif
SPIaAC                   endsl
611jAC                   endif
     C                   exsr      changeitem2
610kAC                   eval      #fromSentItem = #slotitem
610kAC                   eval      #fromSentType = #slottype
610kAC                   eval      #fromItem = #slotitem
610kAC                   eval      #fromType = #slottype
610kAC                   eval      frm$Slot = $slot
610kAC                   eval      frm$Slot2 = $slot2
640fAC                   eval      frm$slot.$saqty1 = -($saqty1)
640fAC                   eval      frm$slot.$saqty2 = -($saqty2)
640fAC                   eval      frm$slot.$saqty3 = -($saqty3)
600vAC                   eval      $saitem = svitem
     C                   if        error
     C                   goto      endchangeitem
     C                   endif

     *  Do adjustment for new item ...

     C                   eval      #slotitem = $saitem
611jAC                   if        #fromItem <> $saitem
CSPbAC                   select
CSPbAC                   when      client = CoastalSunbelt
CSPbAC     'From'        cat       #fromItem:1   $samemo
SPIaA /free
SPIaA      when client = SternProduce
SFPaA       or client = Seashore;
SPIaA        $sacode = 'PA';
SPIaA        $samemo = 'RPK ' + %editc(recidnum:'X');
SPIaA /end-free
CSPbAC                   other
640qDC*    'From'        cat       #fromItem:1   $samemo
640qMC     'Fr'          cat       #fromItem:1   $samemo
640qAc                   if        $samemou = '1'
640qac                   eval      $samemo = %replace(memo11:$samemo:20:11)
640qAc                   endif
CSPbAC                   endsl
611jAC                   endif
     C                   exsr      changeitem2
610kAC                   eval      #toSentItem = #slotitem
610kAC                   eval      #toSentType = #slottype
610kAC                   eval      #toItem = #slotitem
610kAC                   eval      #toType = #slottype
     C                   if        error
     C                   goto      endchangeitem
     C                   endif

     *  Finally, update slot record with new item.

     C                   eval      slitem = $saitem
     C                   if        slentd = 0
     C                   eval      slentd = curdate
     C                   endif
     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endchangeitem
GFCaA*
GFCaAC                   else
GFCaA*
GFCaAC                   if        client = Glazier
SFGeAC                             or client = SGC
FPR AC                             or client = FoodPro
GMMdAC                             or client = MenuMaker
GFCaA*
GFCaA*      Call Host interface pgm to update Host pick slot.
GFCaAC                   if            Slitem > ' '
GFCaAC                             and Slpick = 'Y'
GFCcAC                             and Slstat <> 'Z'
GFCcAC                             and Slstat <> 'V'
GFCcAC                             and Slstat <> 'XD'
FPRfA*
FPRfAC                             or client = FoodPro
FPRfAC                             and Slpick = 'N'
FPRfAC                             and (%subst(sldisp:1:4) = 'WHS2'
FPRfAC                               or %subst(sldisp:1:4) = 'WHS4')
FPRfAC                             and Slstat <> 'Z'
FPRfAC                             and Slstat <> 'V'
FPRfAC                             and Slstat <> 'XD'
GFCaA
GFCaA*  Get live status for item's department.
GFCaAC                   call      'CHKLIVE'
GFCdAC                   parm      slwhse        $cwhse
GFCaAC                   parm                    slwhdp
GFCaAC                   parm                    livestat
GFCaA
GFCaA*  If department is not live, then read next item.
GFCaAC                   if        livestat = '*LIVE'
GFCaA
GFCaAC                   eval      $rwhse = %editc(slwhse:'X')
GFCaAC                   call      'HIT735CL'
GFCaAC                   parm      '*UPDPCKSLT'  $rcmd
GFCaAC                   parm                    $rwhse
GFCaAC                   parm      slitem        $ritem
GFCaAC                   parm      sldisp        $rdisp
700 AC                   parm      slstat        $rstat
GFCaAC                   parm      ' '           $rrtn
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
     C                   endif

600vAC                   exsr      slot2ds
600vAC                   eval      to$Slot = $slot
600vAC                   eval      to$Slot2 = $slot2
600vA
600vA*  Update license tracking
600vA
610kDC**                 exsr      trackAdjust
610kMC                   exsr      trackLcnsTfr
610rA
610rA*  Update FIFO info for From slot.
610rA
610rAC                   exsr      updSlotFifoFrm

     C     endchangeitem endsr

416nA*----------------------------------------------------------------
416nA*  changeitem2  Change item in slot - Part 2
416nA*----------------------------------------------------------------
416nA
416nAC     changeitem2   begsr
600tAC                   eval      currRoutine = 'changeitem2'
600tAC                   exsr      phpgmV1V2V3s

     *  Get item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = #slotitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endchangeitm2
     C                   endif

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
416nAC                   eval      #slotswgt = $itswgt
416nAC                   eval      #slotcwgt = $itcwgt

     *  Get corresponding SSB item for original item (if any)

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSSB'
     C                   eval      item# = #slotitem
     C                   exsr      getitem

     C                   if        error

     C                   eval      error = *off
     C                   eval      ssbflag = *off
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '

     C                   else

     C                   eval      ssbflag = *on
     C                   eval      #ssbitem = $ititem
     C                   eval      #ssbtype = $ittype
     C                   eval      #ssbdesc = $itdesc
     C                   eval      #ssbpdsc = $itpdsc
     C                   eval      #ssbwhdp = $itwhdp
     C                   eval      #ssbstyp = $itstyp
     C                   eval      #ssbdesg = $itdesg
     C                   eval      #ssbum1  = $itum1
     C                   eval      #ssbum2  = $itum2
     C                   eval      #ssbumq2 = $itumq2
     C                   eval      #ssbum3  = $itum3
     C                   eval      #ssbumq3 = $itumq3

     C                   endif

     *  Set adjustment quantities accordingly.

     C                   if        #slotitem = slitem
     C                   eval      $saqty1 = -(slstk1)
     C                   eval      $saqty2 = -(slstk2)
     C                   eval      $saqty3 = -(slstk3)
610hAC                   eval      $sacwta = -($sacwta)
     C                   else
     C                   eval      $saqty1 = slstk1
     C                   eval      $saqty2 = slstk2
     C                   eval      $saqty3 = slstk3
610hAC                   eval      $sacwta = %abs($sacwta)
     C                   endif

     *  Converty adjustment quantities to lowest uom quantitiy.

     C                   if        #slotumq2 <= 0
     C                   eval      #slotumq2 = 1
     C                   endif

     C                   if        #slotumq3 <= 0
     C                   eval      #slotumq3 = 1
     C                   endif

     C                   eval      lowiaqty = ($saqty1 * #slotumq2 * #slotumq3)
     C                                      + ($saqty2 * #slotumq3)
     C                                      + $saqty3

     C                   eval      lowiaorg = 0

     *  Calculate catchweight adjustment.
610hA
610hA*    Catchweight adjustment can now be sent in.
610hA*    If not sent, or it is less than or equal to zero
610hA*    then calculate based on unit weight from item file.

     C                   if        #slotcwgt <> 'Y'
     C                   eval      $sacwta  = 0
     C                   else
610hAC                   if        not $sacwtau
610hAC                             or $sacwta = 0
     C                   eval      $sacwta  = (#slotswgt * $saqty1)
     C                                      + ((#slotswgt/#slotumq2) * $saqty2)
     C                                      + (((#slotswgt/#slotumq2)/#slotumq3)
     C                                           * $saqty3)
610hAC                   endif
     C                   endif

     *  Lock itemqty record.

     C                   eval      check4err = *on
     C                   eval      lock = *on
     C                   exsr      getitemqty
     C                   if        error
     C                   eval      $sldispe = '1'
     C                   goto      endchangeitm2
     C                   endif

     *  Update warehouse quantities for original item ...

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endchangeitm2
     C                   endif

     *  Write adjustment and label records.

     C                   exsr      writeadj
510aA
510aA*  Update slot date quantites.
510aA
510aAC                   eval      $ucmd  = '*FIFO'
510aAC                   eval      $uqty1 = $saqty1
510aAC                   eval      $uqty2 = $saqty2
510aAC                   eval      $uqty3 = $saqty3
601aDC**                 exsr      updslotdte

     C     endchangeitm2 endsr

     *----------------------------------------------------------------
     *  changeslot  Change slot record.
     *----------------------------------------------------------------

     C     changeslot    begsr
600tAC                   eval      currRoutine = 'changeslot'
600tAC                   exsr      phpgmV1V2V3s

601aAC                   eval      updateFifo = *off
640yAC                   eval      statChg = *off

     *  Get & lock slot information.

     C                   eval      lock = *on
     C                   exsr      getslot1
     C                   if        error
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slaisle = '1'
     C                   eval      $slloce = '1'
     C                   eval      $slrlvle = '1'
     C                   eval      $slhande = '1'
     C                   goto      endchangeslot
     C                   endif

     *  Get current date and time.

     C                   exsr      getdatetime

     *  If status changed, set status date and time.

     C                   if        $slstatu and $slstat <> slstat
640yAC                   eval      statChg = *on
640yAC                   eval      origStat = slstat
     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime
     C                   eval      $slsdteu = *off
     C                   eval      $slstimu = *off
750eAC                   if        $saqty1 = 0
750eAC                             and $saqty2 = 0
750eAC                             and $saqty3 = 0
750eAC                             and $sacwta = 0
750eAC                   eval      statChgOnly = *on
750eAC                   eval      statChgOnlyQ1 = slstk1
750eAC                   eval      statChgOnlyQ2 = slstk2
750eAC                   eval      statChgOnlyQ2 = slstk2
750eAC                   endif
     C                   endif

     *  If status changed from Active to inactive ...
     *    Warehouse hold quantitiy must be increased.

     C                   if        slstat = 'A'
     C                   if        $slstatu and
     C                             $slstat <> 'A' and
     C                             $slstat <> 'V' and
     C                             $slstat <> 'Z'

600eMC                   exsr      clr$itemqty

416mAC                   eval      #whsestat = $slstat

416mAC                   eval      #whsefix1 = 0
416mAC                   eval      #whsefix2 = 0
416mAC                   eval      #whsefix3 = 0

416mAC                   eval      #whseadj1 = slstk1
416mAC                   eval      #whseadj2 = slstk2
416mAC                   eval      #whseadj3 = slstk3

416mAC                   eval      #whseorg1 = 0
416mAC                   eval      #whseorg2 = 0
416mAC                   eval      #whseorg3 = 0

416mAC                   eval      savesubcmd = $psubcmd
416mAC                   eval      $psubcmd   = '*HOLD'

416mAC                   exsr      qtywhse

416mAC                   eval      $psubcmd   = savesubcmd

416mAC                   if        error
416mAC                   goto      endchangeslot
416mAC                   endif

     C                   endif
     C                   endif

     *  If status changed from inactive to Active ...
650lA*  OR status changed from inactive to Zero ...
     *    Warehouse hold quantitiy must be decreased.

     C                   if        slstat <> 'A' and
     C                             slstat <> 'V' and
     C                             slstat <> 'Z'
     C                   if        $slstatu and $slstat = 'A'
650lAC                             or $slstatu and $slstat = 'Z'

600eMC                   exsr      clr$itemqty

416mAC                   eval      #whsestat = $slstat

416mAC                   eval      #whsefix1 = 0
416mAC                   eval      #whsefix2 = 0
416mAC                   eval      #whsefix3 = 0

416mAC                   eval      #whseadj1 = -(slstk1)
416mAC                   eval      #whseadj2 = -(slstk2)
416mAC                   eval      #whseadj3 = -(slstk3)

416mAC                   eval      #whseorg1 = 0
416mAC                   eval      #whseorg2 = 0
416mAC                   eval      #whseorg3 = 0

416mAC                   eval      savesubcmd = $psubcmd
416mAC                   eval      $psubcmd   = '*HOLD'

416mAC                   exsr      qtywhse

416mAC                   eval      $psubcmd   = savesubcmd

416mAC                   if        error
416mAC                   goto      endchangeslot
416mAC                   endif

     C                   endif
     C                   endif
700 A
700 A*  If you made it here, slot will be updated.
700 A
700 A /free
700 A   // If status change, write status change as adjustment.
700 A   if statchg = *on;
700 A     negLicAdj = *on;
700 A     exsr writelicadj;
700 A   endif;
700 A /end-free


     *  Move information into slot fields.

     C                   if        $slwhseu
     C                   eval      slwhse = $slwhse
     C                   endif

     C                   if        $slwhdpu
     C                   eval      slwhdp = $slwhdp
     C                   endif

     C                   if        $sldispu
     C                   eval      sldisp = $sldisp
     C                   endif

     C                   if        $slaislu
     C                   eval      slaisl = $slaisl
     C                   endif

     C                   if        $sllocu
510hAC                   if        slloc <> $slloc
510hAC     $slloc        div       2             dummy
510hAC                   mvr                     slside
510hAC                   endif
     C                   eval      slloc  = $slloc
     C                   endif

     C                   if        $slrlvlu
     C                   eval      slrlvl = $slrlvl
     C                   endif

     C                   if        $slhandu
     C                   eval      slhand = $slhand
     C                   endif

     C                   if        $slstypu
     C                   eval      slstyp = $slstyp
     C                   endif

     C                   if        $slstatu
     C                   eval      slstat = $slstat
     C                   endif

     C                   if        $slsdteu
     C                   eval      slsdte = $slsdte
     C                   endif

     C                   if        $slstimu
     C                   eval      slstim = $slstim
     C                   endif

     C                   if        $slsdefu
     C                   eval      slsdef = $slsdef
     C                   endif

     C                   if        $sldesgu
     C                   eval      sldesg = $sldesg
     C                   endif

     C                   if        $slactvu
     C                   eval      slactv = $slactv
     C                   endif

     C                   if        $slbldu
     C                   eval      slbld  = $slbld
     C                   endif

     C                   if        $slpicku
     C                   eval      slpick = $slpick
     C                   endif

     C                   if        $slpsequ
     C                   eval      slpseq = $slpseq
     C                   endif

     C                   if        $slprtyu
601aAC                   if        $slprty <> slprty
601aAC                   eval      updateFifo = *on
601aAC                   endif
     C                   eval      slprty = $slprty
     C                   endif

     C                   if        $slentdu
601aAC                   if        $slentd <> slentd
601aAC                   eval      updateFifo = *on
601aAC                   endif
     C                   eval      slentd = $slentd
     C                   endif

     C                   if        $slexpdu
601aAC                   if        $slexpd <> slexpd
601aAC                   eval      updateFifo = *on
601aAC                   endif
     C                   eval      slexpd = $slexpd
     C                   endif

     C                   if        $slslfdu
     C                   eval      slslfd = $slslfd
     C                   endif

     C                   if        $slrsrvu
     C                   eval      slrsrv = $slrsrv
     C                   endif

     C                   if        $slitemu
     C                   eval      slitem = $slitem
     C                   endif

640nD*  Always recalculate 'side' field.
640nD
640nDC**   slloc         div       2             dummy
640nDC**                 mvr                     slside

     *  If status is 'V' make sure fields are cleaned up.

     C                   if        slstat = 'V'
     C                   eval      slitem = ' '
     C                   eval      slentd = 0
     C                   eval      slexpd = 0
     C                   eval      slprty = 0
     C                   eval      slstk1 = 0
     C                   eval      slstk2 = 0
     C                   eval      slstk3 = 0
     C                   eval      slalc1 = 0
     C                   eval      slalc2 = 0
     C                   eval      slalc3 = 0
     C                   eval      sltfr1 = 0
     C                   eval      sltfr2 = 0
     C                   eval      sltfr3 = 0
     C                   eval      slpck1 = 0
     C                   eval      slpck2 = 0
     C                   eval      slpck3 = 0
     C                   eval      slrcv1 = 0
     C                   eval      slrcv2 = 0
     C                   eval      slrcv3 = 0
     C                   endif

     *  Update record

700 A /free
700 A   // If status change, write status change as adjustment.
700 A   if statchg = *on;
700 A     negLicAdj = *off;
700 A     exsr writelicadj;
700 A   endif;
700 A /end-free

     C                   update(e) slrec
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'ERRUPDREC'
     C                   eval      $pmessage = 'Error on "Update '
     C                                       + 'Slot" command '
     C                                       + '('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'
     C                                       + '-' + f1messageid

     C                   goto      endchangeslot
GFCaA*
GFCaAC                   else
GFCaA*
GFCaAC                   if        client = Glazier
SFGeAC                             or client = SGC
FPR AC                             or client = FoodPro
GMMdAC                             or client = MenuMaker
GFCaA*
GFCaA*      Call Host interface pgm to update Host pick slot.
GFCaAC                   if            Slitem > ' '
GFCaAC                             and Slpick = 'Y'
GFCcAC                             and Slstat <> 'Z'
GFCcAC                             and Slstat <> 'V'
GFCcAC                             and Slstat <> 'XD'
FPRfA*
FPRfAC                             or client = FoodPro
FPRfAC                             and Slpick = 'N'
FPRfAC                             and (%subst(sldisp:1:4) = 'WHS2'
FPRfAC                               or %subst(sldisp:1:4) = 'WHS4')
FPRfAC                             and Slstat <> 'Z'
FPRfAC                             and Slstat <> 'V'
FPRfAC                             and Slstat <> 'XD'
GFCaA
GFCaA*  Get live status for item's department.
GFCaAC                   call      'CHKLIVE'
GFCdAC                   parm      slwhse        $cwhse
GFCaAC                   parm                    slwhdp
GFCaAC                   parm                    livestat
GFCaA
GFCaA*  If department is not live, then read next item.
GFCaAC                   if        livestat = '*LIVE'
GFCaA
GFCaAC                   eval      $rwhse = %editc(slwhse:'X')
GFCaAC                   call      'HIT735CL'
GFCaAC                   parm      '*UPDPCKSLT'  $rcmd
GFCaAC                   parm                    $rwhse
GFCaAC                   parm      slitem        $ritem
GFCaAC                   parm      sldisp        $rdisp
700 AC                   parm      slstat        $rstat
GFCaAC                   parm      ' '           $rrtn
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
     C                   endif
601aD **
601aD ** Delete slot date quantities.
601aD **
601aDC**                 if        slstat = 'V'
601aDC**                 exsr      deleteslotdte
601aDC**                 endif
601aA
601aA*  Update license FIFO information
601aA
601aAC                   if        updateFifo
640yAC                             or statChg
601aAC                   exsr      slot2ds
601aAC                   eval      to$Slot = $Slot
601aAC                   eval      to$Slot2 = $Slot2
640yAC                   if        statChg
640yAC                   exsr      trackLcnsStat
640yAC                   endif
640yAC                   if        updateFifo
601aAC                   exsr      trackLcnsFifo
640yAC                   endif
601aAC                   endif

     C     endchangeslot endsr

417aA*----------------------------------------------------------------
417aA*  check4virtual  Check if slot has an associated virtual slot.
417aA*----------------------------------------------------------------
417aA
417aAC     check4virtual begsr
600tAC                   eval      currRoutine = 'check4virtual'
600tAC                   exsr      phpgmV1V2V3s

     C                   eval      found = *off

     *  Make sure appropriate file is open.

417aAC                   exsr      openvslot2
417aAC                   if        error
417aAC                   goto      endchk4virt
417aaC                   endif

     *  See if item is in virtual slot.

     C     keyvs2$       setll     vslot2
     C                   dow       forever = forever

     C     keyvs2$       reade     vslot2
     C                   if        %eof
     C                   leave
     C                   endif

601dA*    Ignore sent in slot for *GETCHKVX.
601dA
601dAC                   if        $psubcmd = '*GETCHKVX'
601dAC                             and vswhdp = $slwhdp
601dAC                             and vsdisp = $sldisp
601dAC                   iter
601dAC                   endif

     C                   eval      lock = *off
     C                   eval      kywhse = vswhse
     C                   eval      kywhdp = vswhdp
     C                   eval      kydisp = vsdisp
     C                   exsr      getslot2

     C                   if        error
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   iter
     C                   endif

     C                   if        slstat = 'V' or  slstat = 'Z'
     C                   iter
     C                   endif

     C                   eval      found = *on
     C                   leave

     C                   enddo

     C                   if        found
     C                   eval      $sfvirt = 'Y'
     C                   else
     C                   eval      $sfvirt = 'N'
     C                   endif

     C     endchk4virt   endsr

600lDC**---------------------------------------------------------------
600lDC** checkexpdte    Check for different expiration date.
600lDC**---------------------------------------------------------------
600lDC**
600lDC**   checkexpdte   begsr
600lDC**
600lDC** See if expiration date of putaway matches slot exp date.
600lDC**
600lDC**   Date is NOT considered different when ...
600lDC**
600lDC**                 select
600lDC**
600lDC**   ... Slot is a Pick slot.
600lDC**
600lDC**                 when      slpick = 'Y'
600lDC**                 eval      diffexpdte = *off
600lDC**                 eval      sameexpdte = *on
600lDC**
600lDC**   ... Slot expiration date is zero.
600lDC**
600lDC**                 when      slexpd = 0
600lDC**                 eval      diffexpdte = *off
600lDC**                 eval      sameexpdte = *on
600lDC**
600lDC**   ... Expiration dates are the same (of course).
600lDC**
600lDC**                 when      $slexpdu and slexpd = $slexpd
600lDC**                 eval      diffexpdte = *off
600lDC**                 eval      sameexpdte = *on
600lDC**
600lDC**   ... All quantities are zero.
600lDC**
600lDC**                 when      slstk1 = 0 and
600lDC**                           slstk2 = 0 and
600lDC**                           slstk3 = 0 and
600lDC**                           slalc1 = 0 and
600lDC**                           slalc2 = 0 and
600lDC**                           slalc3 = 0 and
600lDC**                           sltfr1 = 0 and
600lDC**                           sltfr2 = 0 and
600lDC**                           sltfr3 = 0 and
600lDC**                           slpck1 = 0 and
600lDC**                           slpck2 = 0 and
600lDC**                           slpck3 = 0 and
600lDC**                           slrcv1 = 0 and
600lDC**                           slrcv2 = 0 and
600lDC**                           slrcv3 = 0
600lDC**                 eval      diffexpdte = *off
600lDC**                 eval      sameexpdte = *on
600lDC**
600lDC**   Otherwise, we have different expiration dates.
600lDC**
600lDC**                 other
600lDC**                 eval      diffexpdte = *on
600lDC**                 eval      sameexpdte = *off
600lDC**
600lDC**                 endsl
600lDC**
600lDC**                 endsr

600lDC**---------------------------------------------------------------
600lDC** checklotcode   Check for different lot code.
600lDC**---------------------------------------------------------------
600lDC**
600lDC**   checklotcode  begsr
600lDC**
600lDC** If not a lot code item, say that the lot code is the same.
600lDC**
600lDC**                 if        #sentlot = 'N'
600lDC**                 eval      samelotcode = *on
600lDC**                 eval      difflotcode = *off
600lDC**                 goto      endchklotcode
600lDC**                 endif
600lDC**
600lDC**                 eval      samelotcode = *on
600lDC**                 eval      difflotcode = *off
600lDC**
600lDC**   endchklotcode endsr

500gA*----------------------------------------------------------------
500gA*  checkslotpos   Check slot position.
500gA*----------------------------------------------------------------
500gA
500gAC     checkslotpos  begsr
600tAC                   eval      currRoutine = 'checkslotpos'
600tAC                   exsr      phpgmV1V2V3s
600lA
600lA*  License tracking is currently not tracking slot position.
600lA
600lAC                   eval      sameslotpos = *on
600lAC                   eval      samepos  = *on
600lAC                   eval      samewhse = slwhse
600lAC                   eval      samewhdp = slwhdp
600lAC                   eval      samedisp = sldisp
600lAC                   leavesr

     *  Get license information for slot.

     C                   eval      check4err = *on
     C                   eval      tmpdisp = $sldisp
     C                   eval      tmpitem = $slitem
     C                   exsr      getslotlic

     *  Check for same position.

     C                   select

     C                   when      $sdpos <= 1
     C                   eval      sameslotpos = *on

     C                   when      trackpos <> 'Y'
     C                   eval      sameslotpos = *on

600fMC                   when      not $saToposu
500vMC                   eval      sameslotpos = *on

     C                   when      $saTopos = 0
     C                   eval      sameslotpos = *off

600fMC                   when      $liToPos = $saTopos
     C                   eval      sameslotpos = *on

     C                   other
     C                   eval      sameslotpos = *off

     C                   endsl
600lDC**
600lDC** Check for same expiration date.
600lDC**
600lDC**                 exsr      checkexpdte
600lDC**
600lDC** Check for same lot code.
600lDC**
600lDC**                 exsr      checklotcode

     *  Now we can set our main flags.

     C                   select

     *    Same Position - Item already in slot position.

     C                   when      sameslotpos

     *      Save slot info.

     C                   eval      samepos  = *on
     C                   eval      samewhse = slwhse
     C                   eval      samewhdp = slwhdp
     C                   eval      samedisp = sldisp
600lDC**
600lDC**     Set Same Position Exp Date flag.
600lDC**
600lDC**                 if        sameexpdte
600lDC**                 eval      samepossamedte = *on
600lDC**                 else
600lDC**                 eval      sameposdiffdte = *on
600lDC**                 endif
600lDC**
600lDC**     Set Same Position Lot Code flag.
600lDC**
600lDC**                 if        samelotcode
600lDC**                 eval      samepossamelot = *on
600lDC**                 else
600lDC**                 eval      sameposdifflot = *on
600lDC**                 endif
600lDC**
600lDC**   Different Position - Item in a different position in slot.
600lDC**
600lDC**                 other
600lDC**
600lDC**     Set Different Position Exp Date flag.
600lDC**
600lDC**                 if        sameexpdte
600lDC**                 eval      diffpossamedte = *on
600lDC**                 else
600lDC**                 eval      diffposdiffdte = *on
600lDC**                 endif
600lDC**
600lDC**     Set Different Position Lot Code flag.
600lDC**
600lDC**                 if        samelotcode
600lDC**                 eval      diffpossamelot = *on
600lDC**                 else
600lDC**                 eval      diffposdifflot = *on
600lDC**                 endif

     C                   endsl

     C     endchkslotpos endsr

416cA*----------------------------------------------------------------
416cA*
416cA*----------------------------------------------------------------
416cA
416cAC     checkstatus   begsr
600tAC                   eval      currRoutine = 'checkstatus'
600tAC                   exsr      phpgmV1V2V3s

     C                   call      'CHKSTAT'
600oDC**                 parm                    slwhse
600oMC                   parm      slwhse        $uwhse
     C                   parm                    slitem
     C                   parm                    slstyp
     C                   parm                    slrsrv
     C                   parm                    slpick
     C                   parm                    slstat
530aAC                   parm                    sldesg
     C                   parm                    slstk1
     C                   parm                    slstk2
     C                   parm                    slstk3
     C                   parm                    slalc1
     C                   parm                    slalc2
     C                   parm                    slalc3
     C                   parm                    sltfr1
     C                   parm                    sltfr2
     C                   parm                    sltfr3
     C                   parm                    slpck1
     C                   parm                    slpck2
     C                   parm                    slpck3
     C                   parm                    slrcv1
     C                   parm                    slrcv2
     C                   parm                    slrcv3
     C                   parm                    $cnewstat         2
     C                   parm                    $creturn          8
640tAC                   parm                    slwhdp
640tAC                   parm                    sldisp

650gAc                   select
650gAc                   when      $creturn  = '*CHANGED'
650gAc                   eval      ovrFlwODR = *on
     *  determine if overflow slots exist prior to quantity calculation
650gAc                   if        slstat='RP' and slpick='Y'
650gAc                   eval      saveslrec = slrecds
650gAc                   exsr      look4overflow
650gAc                   if        overflowfound
650gAc                   eval      $creturn  = '*OK'
650gAc                   endif
650iMc*                  eval      ovrFlwODR = *off
650gA*  reposition slot table for previous pick slot
650gAc                   eval      kywhse = saveslrec.slwhse
650gAc                   eval      kywhdp = saveslrec.slwhdp
650gAc                   eval      kydisp = saveslrec.sldisp
650gAc                   eval      lock = *on
650gAc                   exsr      getslot2
650gAc                   eval      slrecds = saveslrec
650gAc                   endif
650iAc                   eval      ovrFlwODR = *off
650gAc                   endsl

     C                   if        $creturn  = '*CHANGED'
     C                   eval      slstat = $cnewstat
     C                   exsr      getdatetime
     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime
     C                   if        slstat = 'A'
     C                   eval      slentd = curdate
     C                   endif
     C                   endif

     C     endchkstat    endsr

600dA*----------------------------------------------------------------
600dA*  checkallzero   Check if all qtys are zero.
600dA*----------------------------------------------------------------
600dA
600dAC     checkallzero  begsr
600tAC                   eval      currRoutine = 'checkallzero'
600tAC                   exsr      phpgmV1V2V3s

     C                   if        slstk1 = 0 and
     C                             slstk2 = 0 and
     C                             slstk3 = 0 and
     C                             slalc1 = 0 and
     C                             slalc2 = 0 and
     C                             slalc3 = 0 and
     C                             sltfr1 = 0 and
     C                             sltfr2 = 0 and
     C                             sltfr3 = 0 and
     C                             slpck1 = 0 and
     C                             slpck2 = 0 and
     C                             slpck3 = 0 and
     C                             slrcv1 = 0 and
     C                             slrcv2 = 0 and
     C                             slrcv3 = 0
     C                   eval      allZero = *on
     C                   else
     C                   eval      allZero = *off
     C                   endif

     C                   endsr

600kA*----------------------------------------------------------------
600kA*  chkfifo   Check if sent slot is in FIFO order
600kA*----------------------------------------------------------------
600kA
600kAC     chkfifo       begsr
600tAC                   eval      currRoutine = 'checkfifo'
600tAC                   exsr      phpgmV1V2V3s

     *  Get current date and time.

     C                   exsr      getdatetime

     *  Open necessary file

     C                   exsr      openslot3
     C                   if        error
     C                   leavesr
     C                   endif

     *  Loop backwards through overflow slots,
     *    starting from the slot that was sent in.

     C                   eval      $slpick = 'N'
     C     keysl3        setll     slot3

     C                   dow       forever = forever

     C     keysl3p2      readpe(n) slot3

     C                   if        %eof
     C                   leave
     C                   endif

     *    Calculate qtys

     C                   exsr      calcqtys

     *    Ignore off site storage slots

610nAC                   if        sldesg='BFC'
610nAC                   iter
610nAC                   endif

     *    Ignore slot if there is no available qty.

     C                   if        slavl1 <= 0
     C                             and slavl2 <= 0
     C                             and slavl3 <= 0
     C                   iter
     C                   endif

     *    Date sensitive item ...

     C                   if        $itflgd = 'Y'

     *      Ignore slot if expiration date matches sent exp date
610qA*                                and priority.

     C                   if        slexpd = $slexpd and
610qAC                             slprty = $slprty
     C                   iter
     C                   endif

     *      Ignore slot if it is expired

     C                   if        slexpd > 0
610qMC                             and slexpd <= curdate
610qDC*                            and slexpd >= curdate
     C                   iter
     C                   endif

     C                   endif

     *    Non-Date sensitive item ...

     C                   if        $itflgd <> 'Y'

     *      Ignore slot if enter date matches sent enter date.

     C                   if        slentd = $slentd
     C                   iter
     C                   endif

     C                   endif

     *    Previous record found, sent slot not in FIFO order.

     C                   eval      $preturn = 'NOTFIFO'
     C                   exsr      getmsg
     C                   exsr      slot2ds

     C                   leave
     C                   enddo

     C                   endsr

750 A*----------------------------------------------------------------
750 A*  getProdSlot - If Production slot call DRIPROD to get proper slot
750 A*----------------------------------------------------------------

      /free
       begsr getProdSlot;

          if not %open(slot3);
            exsr openslot3;
          endif;

          prodSlotFound = *off;
          setll (kywhse:$ititem:'PR':'N') slot3;
          dow forever = forever;
            reade (kywhse:$ititem:'PR':'N') slot3;
            if %eof(slot3) or not %found(slot3);
              leave;
            endif;
            if %trim(slaisl) = %trim(prdslt(1));
              $sldisp = sldisp;
              prodSlotFound = *on;
              leave;
            endif;
          enddo;
          unlock slot3;

      /end-free

       endsr;
750 A /end-free

650vA*----------------------------------------------------------------
650vA*  chkUsage   Check slot usage
650vA*----------------------------------------------------------------
650vAC     chkUsage      begsr

650vAC                   call      'CHKUSAGE'
650vAC                   parm      $slwhse       $uWhse
650vAC                   parm      $slwhdp       $uWhdp
650vAC                   parm      $sldisp       $uDisp
650vAC                   parm      $slrsrv       $uRsrv
650vAC                   parm      $slitem       $uItem
650vAC                   parm                    $uEntDte
650vAC                   parm                    $uExpDte
650vAC                   parm      0             $uPieces
650vAC                   parm      0             $uRecs
650vAC                   parm      ' '           $uDiffItem
650vAC                   parm      ' '           $uDiffEntd
650vAC                   parm      ' '           $uDiffExpd
650vAC                   endsr

     *----------------------------------------------------------------
     *  clearerrflags  Clear error flag fields.
     *----------------------------------------------------------------

     C     clearerrflags begsr

     C                   if        $slwhsee = '1'
     C                   eval      $slwhsee = '0'
     C                   endif

     C                   if        $slwhdpe = '1'
     C                   eval      $slwhdpe = '0'
     C                   endif

     C                   if        $slaisle = '1'
     C                   eval      $slaisle = '0'
     C                   endif

     C                   if        $slloce = '1'
     C                   eval      $slloce = '0'
     C                   endif

     C                   if        $slrlvle = '1'
     C                   eval      $slrlvle = '0'
     C                   endif

     C                   if        $slhande = '1'
     C                   eval      $slhande = '0'
     C                   endif

417dAC                   if        $slsidee = '1'
417dAC                   eval      $slsidee = '0'
417dAC                   endif

     C                   if        $sldispe = '1'
     C                   eval      $sldispe = '0'
     C                   endif

     C                   if        $slstype = '1'
     C                   eval      $slstype = '0'
     C                   endif

     C                   if        $slstate = '1'
     C                   eval      $slstate = '0'
     C                   endif

417dAC                   if        $slsdtee = '1'
417dAC                   eval      $slsdtee = '0'
417dAC                   endif

417dAC                   if        $slstime = '1'
417dAC                   eval      $slstime = '0'
417dAC                   endif

     C                   if        $slsdefe = '1'
     C                   eval      $slsdefe = '0'
     C                   endif

     C                   if        $sldesge = '1'
     C                   eval      $sldesge = '0'
     C                   endif

     C                   if        $slactve = '1'
     C                   eval      $slactve = '0'
     C                   endif

     C                   if        $slblde = '1'
     C                   eval      $slblde = '0'
     C                   endif

     C                   if        $slpicke = '1'
     C                   eval      $slpicke = '0'
     C                   endif

     C                   if        $slpseqe = '1'
     C                   eval      $slpseqe = '0'
     C                   endif

     C                   if        $slprtye = '1'
     C                   eval      $slprtye = '0'
     C                   endif

417dAC                   if        $slentde = '1'
417dAC                   eval      $slentde = '0'
417dAC                   endif

417dAC                   if        $slexpde = '1'
417dAC                   eval      $slexpde = '0'
417dAC                   endif

     C                   if        $slslfde = '1'
     C                   eval      $slslfde = '0'
     C                   endif

     C                   if        $slrsrve = '1'
     C                   eval      $slrsrve = '0'
     C                   endif

     C                   if        $sliteme = '1'
     C                   eval      $sliteme = '0'
     C                   endif

417dAC                   if        $saiteme = '1'
417dAC                   eval      $saiteme = '0'
417dAC                   endif

417dAC                   if        $saqty1e = '1'
417dAC                   eval      $saqty1e = '0'
417dAC                   endif

417dAC                   if        $saqty2e = '1'
417dAC                   eval      $saqty2e = '0'
417dAC                   endif

417dAC                   if        $saqty3e = '1'
417dAC                   eval      $saqty3e = '0'
417dAC                   endif

417dAC                   if        $saorg1e = '1'
417dAC                   eval      $saorg1e = '0'
417dAC                   endif

417dAC                   if        $saorg2e = '1'
417dAC                   eval      $saorg2e = '0'
417dAC                   endif

417dAC                   if        $saorg3e = '1'
417dAC                   eval      $saorg3e = '0'
417dAC                   endif

417dAC                   if        $sacwtae = '1'
417dAC                   eval      $sacwtae = '0'
417dAC                   endif

417dAC                   if        $sacodee = '1'
417dAC                   eval      $sacodee = '0'
417dAC                   endif

417dAC                   if        $samemoe = '1'
417dAC                   eval      $samemoe = '0'
417dAC                   endif

417dAC                   if        $saciteme = '1'
417dAC                   eval      $saciteme = '0'
417dAC                   endif

417eAC                   if        $scddgte = '1'
417eAC                   eval      $scddgte = '0'
417eAC                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  crtprtyrpl   Create priority replenishment
416bA*----------------------------------------------------------------

416bAC     crtprtyrpl    begsr
600tAC                   eval      currRoutine = 'crtprtyrpl'
600tAC                   exsr      phpgmV1V2V3s

     *  Initialize data structure

600eMC                   exsr      clr$prtyrpl

     *  Initialize fields

     C                   eval      $prwhseu = *on
     C                   eval      $prwhse  = $slwhse

     C                   eval      $pritemu = *on
     C                   eval      $pritem  = $slitem

     C                   eval      $prwhdpu = *on
     C                   eval      $prwhdp  = $slwhdp

     C                   eval      $prslotu = *on
     C                   eval      $prslot  = $sldisp

     C                   eval      $prqtynu = *on
     C                   eval      $prqtyn  = %abs($slavl1)

     C                   eval      $prfillu = *on
416lDC**                 eval      $prfill  = 'N'
416lMC                   eval      $prfill  = 'Y'

     *  Call program to create priority replenishments.

     *  Note: the priority replenishment program will send back a
     *        non-*OK return code explaining why a replenishment
     *        couldn't be created, as well as errors, of course.
     *        Since, creating a priority replenishment is not our
     *        primary concern, we ignore all return codes.

600eMC                   eval      $dricommand = 'DRIPRTYRPL'
610yAC                   select
610yAC                   when      $saAction = 'ODR'
610yAC                   eval      $drisubcmd = '*CRTRPLODR'
610yAC                   other
600eMC                   eval      $drisubcmd = '*CRTRPLSEQ'
610yAC                   endsl
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3callerr
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   endsl

     C                   endsr

     *----------------------------------------------------------------
     *  crtvirtual  Create virtual slot
     *
     *    Routine was called ZZCKNS in older programs.
     *
     *----------------------------------------------------------------

     C     crtvirtual    begsr
600tAC                   eval      currRoutine = 'crtvirtual'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off
     C                   eval      newvs = *off
     C                   eval      vslotcreated = *off
600cA
600cA*  Get *VIRTUAL options.
600cA
600cAC                   exsr      getvirtualopt

750 A /free
750 A            // When Production Line slot, determine if one
750 A            // exist and use it without looking to create
750 A            // another line slot
750 A           if %trim(slaisl) = %trim(prdslt(1));
750 A             exsr getProdSlot;
750 A             if prodSlotFound;
750 A               leavesr;
750 A             endif;
750 A           endif;
750 A /end-free

600cA
600cA*  If not working with a Pick slot,
600cA*    Then we can skip the Pick slot checks.
600cA
600cAC                   if        slpick <> 'Y'
ICBbAC                             or (client = icb
ICBbAC                             and slloc <> 999)
600cAC                   goto      skipvpickchk
600cAC                   endif
MJKaA
MJKaA*  For MJK call program to get pick slot option.
MJKaA
CBIbAC                   select
CBIbMC                   when      client = mjkellner
MJKaAC                   call      'MJKVRTPCK'
MJKaAC                   parm                    slwhdp
MJKaAC                   parm                    sldisp
MJKaAC                   parm                    mjkalw            1
CBIbA*
CBIbA*  Determine if virtual pick slots are allowed.
CBIbAC                   when      client = cheney
CBIbAC                   call      'CHKDESIGSP'
CBIbAC                   parm                    sldesg
CBIbAC                   parm      ' '           $citem           15
CBIbAC                   parm                    slwhdp
CBIbAC                   parm                    sldisp
CBIbAC                   parm      0             $cckdgt           3 0
CBIbAC                   parm      ' '           $crtn             8
CBIbMC                   endsl
600cA
600cA*  Determine if virtual pick slots are allowed.
600cA
600cAC                   select
MJKaA
MJKaA*    - MJK only allows them for some Pick slots.
MJKaA
MJKaAC                   when      opvpck = 'C'
MJKaAC                             and client = mjkellner
MJKaAC                             and mjkalw = 'Y'
MJKaAC                   goto      skipvpickchk
MJKbAC
MJKbAC                   when      opvpck = 'C'
MJKbAC                             and client = mjkellner
MJKbAC                             and slstyp = 'P'
MJKbAC                   goto      skipvpickchk
MJKbAC
MJKbAC                   when      opvpck = 'C'
MJKbAC                             and client = mjkellner
MJKbAC                             and sldesg = 'SPCL'
MJKbAC
BIR A
BIR A*     - BiRite only allows them for PIR slots.
BIR A
BIR AC                   when      opvpck = 'C'
BIR AC                             and client = birite
BIR AC                             and slstyp = 'P'
BIR AC                   goto      skipvpickchk
JPF A
JPF A*     - Jack Palmer only allows for 'SPCL' designation.
JPF A
JPF AC                   when      opvpck = 'C'
JPF AC                             and client = palmer
JPF AC                             and sldesg = 'SPCL'
JPF AC                   goto      skipvpickchk
SVLaA
SVLaA*     - Saval only allows for 'SPCL' designation.
SVLaA
SVLaAC                   when      opvpck = 'C'
SVLaAC                             and client = saval
SVLaAC                             and sldesg = 'SPCL'
SVLaAC                   goto      skipvpickchk
WSTaA
WSTaA*     - WestSide only allows in LDCK department.
WSTaA
WSTaAC                   when      opvpck = 'C'
WSTaAC                             and client = westside
WSTaAC                             and slwhdp = 'LDCK'
WSTaAC                   goto      skipvpickchk
CCP A
CCP A*     - Capitol City Produce only allows for 'SPCL' designation.
CCP A
CCP AC                   when      opvpck = 'C'
CCP AC                             and client = capitolcity
CCP AC                             and sldesg = 'SPCL'
CCP AC                   goto      skipvpickchk
GMMaA
GMMaA*     - Graves Menu Maker only allows for 'SPCL' designation.
GMMaA
GMMaAC                   when      opvpck = 'C'
GMMaAC                             and client = menumaker
GMMbDC*                            and sldesg = 'SPCL'
GMMbMC                             and (sldesg = 'SPCL'
GMMcAC                               or  slloc  = 999
GMMbAC                               or  slwhse = 010
GMMbAC                               and slloc  = 199)
GMMaAC                   goto      skipvpickchk
HKWaA
HKWaA*     - Hearn Kirkwood only allows for 'SPCL' designation.
HKWaA
HKWaAC                   when      opvpck = 'C'
HKWaAC                             and client = hkw
HKWaAC                             and sldesg = 'SPCL'
HKWaAC                   goto      skipvpickchk
ICBaA
ICBaA*     - Inter County Bakers only allows for '999' items/location
ICBaA
ICBaAC                   when      opvpck = 'C'
ICBaAC                             and client = icb
ICBaAC                             and slloc = 999
ICBaAC                   goto      skipvpickchk
FPRmA*     - Food Pro only allows for 'SPCL' desg or WHS2 or WHS4
FPRmA
FPRmAC                   when      opvpck = 'C'
FPRmAC                             and client = FoodPro
FPRmAC                             and (sldesg = 'SPCL'
FPRmAC                             or (%subst(sldisp:1:4) = 'WHS2'
FPRmAC                               or %subst(sldisp:1:4) = 'WHS4'))
FPRmAC                   goto      skipvpickchk
CBIaA
CBIaA*     - Cheney only allows for special designations
CBIaA*     - ????? SEE RC200 ?????
CBIaA
CBIaAC                   when      opvpck = 'C'
CBIaAC                             and client = cheney
CBIbMC                             and (sldesg = 'SPCL'
CBIbAC                              or  $crtn  = '*FOUND')
CBIaAC                   goto      skipvpickchk
CWD A
CWD A*     - Cash Wa Aberdeen only allows virtual slots in
CWD A*       specific depts, aisles, locations, levels.
CWD A
CWD AC                   when          opvpck = 'C'
CWD AC                             and client = Cashwa
CWD AC                             and (clientloc = CashwaAberdeen)
CWD AC                   exsr      zzvpckchkcwd
CWD A*
CWD AC                   if        skipvpckchk
CWD A*       Virtual pick slot allowed.
CWD AC                   goto      skipvpickchk
CWD AC                   endif
CWDaA
CWDaA*     - Cash Wa Kearney only allows virtual slots in
CWDaA*       specific depts, aisles, locations, levels.
CWDaA
CWDaAC                   when          opvpck = 'C'
CWDaAC                             and client = Cashwa
CWDaAC                             and (clientloc = CashwaKearney)
CWDaAC                   exsr      zzvpckchkcwd3
CWDaA*
CWDaAC                   if        skipvpckchk
CWDaA*       Virtual pick slot allowed.
CWDaAC                   goto      skipvpickchk
CWDaAC                   else
CWDaA*
CWDaAC                   eval      error = *on
CWDaAC                   eval      $preturn = 'VRTNOTALWP'
CWDaAC                   exsr      getmsg
CWDaAC                   goto      endcrtvirtual
CWDaAC                   endif
600cA
600cA*     - Allow for *CRTVPICK
610zA*       and *CRTREPAKD
710cA*       and *CRTPRODC
600cA
600cAC                   when      $psubcmd  = '*CRTVPICK'
610zAC                             or $psubcmd  = '*CRTREPAKD'
710cAC                             or $psubcmd  = '*CRTPRODC'
600cAC                   goto      skipvpickchk
PCKdA*
PCKdA*      Packer's does not want to crete virtual pick slots
PCKdA*      if slot is reserved.
PCKdAC                   when          (client = Packers
CFIaAC                                 or client = Colony)
PCKdAC                             and slpick = 'Y'
PCKdAC                             and slrsrv = 'Y'
PCKdA*
PCKdAC                   eval      error = *on
PCKdAC                   eval      $preturn = 'VRTNOTALWP'
PCKdAC                   exsr      getmsg
PCKdAC                   goto      endcrtvirtual
600cA
600cA*     - Allow when *VIRTUAL option is set to 'Y'
600cA
600cAC                   when      opvpck = 'Y'
600cAC                   goto      skipvpickchk
600cA
600cA*     - Otherwise, throw error.
600cA
600cAC                   other
600cA
     C                   eval      error = *on
     C                   eval      $preturn = 'VRTNOTALWP'
     C                   exsr      getmsg
     C                   goto      endcrtvirtual
600cA
600cAC                   endsl

600cAC     skipvpickchk  tag

710cA*  $psubcmd = *CRTPRODC - will not check for maximum pick slots. m.
710cAC                   if        $psubcmd  <> '*CRTPRODC'

     *  Verify that the # of pick slots doesn't exceed maximum for item.
     *    (Force status to 'Z' for verification purposes).

ICBbAC                   if        client <> icb
HMWaAc                             and client <> hmwagner
EOP Ac                             and client <> Earls
FPRbAc                             and client <> FoodPro
MRTaAC                             and client <> Merit
ICBaAC                             or (client = icb
ICBaAC                             and slloc = 999)
HMWaAC                             or (client = hmwagner
HMWaAc                             and slstat <> 'SR')
MRTaAC                             or (client = Merit
MRTaAc                             and slstat <> 'RP')
FPRbAC                             or (client = FoodPro
FRPkAc                             and slstat <> 'FR'
FRPbAc                             and slstat <> 'SR')
EOP AC                             or (client = Earls
EOP Ac                             and $ittype <> 'R')
     C                   eval      slstat = 'Z'
     C                   exsr      verifypick
     C                   if        error
     C                   goto      endcrtvirtual
     C                   endif
ICBbAC                   endif
710cAC                   endif

     *   Get out if physical slot already uses both
     *   positions of handstack field.

     C                   if        %subst(slhand:1:1) <> ' '
     C                   eval      error = *on
     C                   eval      $preturn = 'VRTNOTALWH'
     C                   exsr      getmsg
     C                   goto      endcrtvirtual
     C                   endif

     *   Set handstack flag for later use.

     C                   if        slhand <> ' '
     C                   eval      flaghs = *on
     C                   else
     C                   eval      flaghs = *off
     C                   endif
520dAC                   eval      wkslhand = slhand

     *   Loop & increment handstack to find new v-slot to create.

     C                   eval      k = 0

610xAC                   if        flaghs
610xAC                   eval      maxCode = 962
610xAC                   else
610xAC                   eval      maxCode = 702
610xAC                   endif

510bDC*                  dow       k <= 702
610xDC*                  dow       k < 702
610xMC                   dow       k < maxCode
     C                   eval      k = k + 1

     *     If physical slot had handstack then limit hs we can use.

 4B  C                   if        flaghs and
520dDC**                           %subst(hnd(k):1:1) <> %subst(slhand:2:1)
520dMC                             %subst(hnd(k):1:1) <> %subst(wkslhand:2:1)
 3I  C                   iter
 5E  C                   endif
SFGbA
SFGbA*      Skip specific handstacks for Springfield.
SFGbA
SFGbAC                   if        client = sgc
SFGbAC                   if        $sldisp = 'OSSKANSAS'
SFGbAC                             and $slrlvl = 2
SFGbAC                   if        hnd(k) = 'EY'
SFGbAC                             or hnd(k) = 'EZ'
SFGbAC                             or hnd(k) = 'FA'
SFGbAC                             or hnd(k) = 'FE'
SFGbAC                             or hnd(k) = 'GO'
SFGbAC                             or hnd(k) = 'GP'
SFGbAC                             or hnd(k) = 'KE'
SFGbAC                             or hnd(k) = 'KK'
SFGbAC                             or hnd(k) = 'KT'
SFGbAC                             or hnd(k) = 'KU'
SFGbAC                             or hnd(k) = 'QP'
SFGbAC                             or hnd(k) = 'QW'
SFGbAC                             or hnd(k) = 'WW'
SFGbAC                             or hnd(k) = 'WX'
SFGbAC                             or hnd(k) = 'WY'
SFGbAC                             or hnd(k) = 'WZ'
SFGbAC                   iter
SFGbAC                   endif
SFGbAC                   endif
SFGbAC                   endif
650qA
650qA*      Skip handstack for Production Customer slot
650qA*      if customer production record found and not a
650qA*      match to customer passed

      /free
710aA           // production slot aisles were loaded in array
710aA           // prdslt in routine aaainit
710aA                    sltc = 0;
710aA                    sltc = %lookup($slaisl:prdslt:1);
710aA                    if sltc = 0;
710aA                       sltc = 1;
710aA                    endif;
      /end-free
650qAc                   if        ProdCust <> 0
650qAc                               and $saAction <> 'PRM'
710aDc*                              and %subst($sldisp:1:3) <> 'PRD'
710aAc                               and $slaisl <> prdslt(sltc)
650qAc                   call      'FRMTVS2'
650qAc                   parm                    $sldisp
650qAc                   parm      $slrlvl       $vrlvl            2 0
650qAc                   parm      hnd(k)        $vhand            2
650qAc                   parm      ' '           $vdisp           12
650qA /free
650qA                    chain ($slwhse:$vdisp) pcslot1;
650qA          // if slot found in production customer xref then
650qA          // it must match to use this virtual.  Otherwise assign
650qA          // another virtual to this customer
650qA                    if %found(pcslot1);
650qA                       unlock pcslot1;
650qA                       if cscust <> ProdCust;
650qA                          $sldisp = baseDisp;
650qA                          iter;
650qA                       endif;
650qA                    endif;
650qA                    endif;
650qA /end-free

700dM*      Call special format for RCV/STG/OSS/PRE/AMP
600dA
600dAC                   if        $psubcmd = '*RCVIN'
720 AC                              or $psubcmd = '*RPAIN'
700sAC                              or $psubcmd = '*RTNIN'
730eAC                              or $psubcmd = '*RWOIN'
600dAC                              or $psubcmd = '*STGIN'
600dAC                              or $psubcmd = '*OSSIN'
611eAC                              or $psubcmd = '*PREIN'
700dAC                              or $psubcmd = '*AMPIN'
611eAC                              or $psubcmd = '*CRTPRE'
700dAC                              or $psubcmd = '*CRTAMP'
720 AC                              or $psubcmd = '*CRTRPA'
600dAC                              or $psubcmd = '*USR2RCV'
720 AC                              or $psubcmd = '*USR2RPA'
700sAC                              or $psubcmd = '*USR2RTNO'
730eAC                              or $psubcmd = '*USR2RWO'
600dAC                              or $psubcmd = '*USR2STG'
600dAC                              or $psubcmd = '*USR2OSS'
600dA
600dAC                   call      'FRMTVS2'
600aDC                   parm                    $sldisp
600aDC                   parm      $slrlvl       $vrlvl            2 0
600aDC                   parm      hnd(k)        $vhand            2
600aDC                   parm      ' '           $vdisp           12
611iM*      Check for existing LICACTIVE records for slot.
611i *  Get license information for slot.

611i C                   eval      check4err = *on
611i C                   eval      tmpdisp = $vdisp
611i C                   eval      tmpitem = *blanks
611i C                   exsr      getslotlic
611iAC                   if        $liToLcns <> '*NONE'
611iAC                   iter
611iAC                   endif

600dA
600dAC                   else

     C                   call      'FRMTVS'
     C                   parm                    $sldisp
     C                   parm                    flaghs
     C                   parm      hnd(k)        $vhand            2
     C                   parm      ' '           $vdisp           12
600dA
600aDC                   endif

     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $vdisp
     C                   eval      check4err = *on
600pAC                   eval      saveSLREC = slrecds
     C                   exsr      getslot2
600pAC                   eval      slrecds = saveSLREC

 4B  C                   if        error
     C                   eval      newvs = *on
     C                   eval      error = *off
     C                   eval      $preturn  = '*OK'
     C                   eval      $pmessage = ' '
 3L  C                   leave
 4X  C                   endif

 3E  C                   enddo

     *  If unused virtual slot number not found, then get out.

     C                   if        not newvs
     C                   eval      error = *on
     C                   eval      $preturn = 'VRTNOTALWU'
     C                   exsr      getmsg
     C                   goto      endcrtvirtual
     C                   endif

     *  Otherwise, create virtual slot.

     *    Re-retrieve base slot.

700dM*      Call special routine for RCV/STG/OSS/USRIN/PRE/AMP
600dA*        because they don't have a base slot.
600dA
600dAC                   if        $psubcmd = '*RCVIN'
720 AC                              or $psubcmd = '*RPAIN'
700sAC                              or $psubcmd = '*RTNIN'
730eAC                              or $psubcmd = '*RWOIN'
600dAC                              or $psubcmd = '*STGIN'
600dAC                              or $psubcmd = '*OSSIN'
611eAC                              or $psubcmd = '*PREIN'
700dAC                              or $psubcmd = '*AMPIN'
611eAC                              or $psubcmd = '*CRTPRE'
700dAC                              or $psubcmd = '*CRTAMP'
720 AC                              or $psubcmd = '*CRTRPA'
600dAC                              or $psubcmd = '*USRIN'
600dAC                              or $psubcmd = '*TFR2USR'
610sAC                              or $psubcmd = '*TFR2USRR'
640dAC                              or $psubcmd = '*TFR2USRN'
600dAC                              or $psubcmd = '*USR2RCV'
720 AC                              or $psubcmd = '*USR2RPA'
700sAC                              or $psubcmd = '*USR2RTNO'
730eAC                              or $psubcmd = '*USR2RWO'
600dAC                              or $psubcmd = '*USR2STG'
600dAC                              or $psubcmd = '*USR2OSS'
600dAC                   exsr      getslot2USR
600vAC                   eval      slrlvl = $slrlvl
600dAC                   else
     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endcrtvirtual
     C                   endif
600dAC                   endif

416oA*    If we are only verifying, then we just fake the create.

416oAC                   if        $psubcmd = '*VERIFYTFI'
417gAC                             or $psubcmd = '*VERIFYLTI'
417gAC                             or $psubcmd = '*VERIFYPRI'
417gAC                             or $psubcmd = '*VERIFYSSI'
417gAC                             or $psubcmd = '*VFYTFICHG'
417hAC                             or $psubcmd = '*VFYLTICHG'
417hAC                             or $psubcmd = '*VFYPRICHG'
417hAC                             or $psubcmd = '*VFYSSICHG'
500tAC                             or $psubcmd = '*VFYCLSTFI'
500tAC                             or $psubcmd = '*VFYCLSLTI'
500tAC                             or $psubcmd = '*VFYCLSPRI'
500tAC                             or $psubcmd = '*VFYCLSSSI'
500tAC                             or $psubcmd = '*VFYCLSTIC'
500tAC                             or $psubcmd = '*VFYCLSLIC'
500tAC                             or $psubcmd = '*VFYCLSPIC'
500tAC                             or $psubcmd = '*VFYCLSSIC'
500eAC                             or $psubcmd = '*VERIFYPUT'
500xAC                             or $psubcmd = '*VFYSTGPUT'
500eAC                             or $psubcmd = '*VERIFYRTN'
500iAC                             or $psubcmd = '*VERIFYSI'
416oAC                   eval      vslotcreated = *on
416oAC                   goto      endcrtvirtual
416oAC                   endif

     *    Initialize some fields and create new virtual slot.

     *      Get values from base slot.

     C                   eval      $slaislu= *on
     C                   eval      $slaisl = slaisl
     C                   eval      $sllocu = *on
     C                   eval      $slloc  = slloc
     C                   eval      $slrlvlu= *on
     C                   eval      $slrlvl = slrlvl
     C                   eval      $slsideu= *on
     C                   eval      $slside = slside
     C                   eval      $slstypu= *on
     C                   eval      $slstyp = slstyp
     C                   eval      $slsdefu= *on
     C                   eval      $slsdef = slsdef
     C                   eval      $sldesgu= *on
     C                   eval      $sldesg = sldesg
     C                   eval      $slactvu= *on
     C                   eval      $slactv = slactv
     C                   eval      $slbldu = *on
     C                   eval      $slbld  = slbld
     C                   eval      $slpicku= *on
610zAC                   if        $psubcmd = '*CRTREPAKD'
610zAC                   eval      $slpick = 'Y'
610zAC                   else
     C                   eval      $slpick = slpick
610zAC                   endif
ICBbAC                   if        client = icb
ICBaAC                             and slloc <> 999
ICBbAC                   eval      $slpick = 'N'
ICBbAC                   endif
     C                   eval      $slpsequ= *on
     C                   eval      $slpseq = slpseq

     *      Clear some values.

     C                   eval      savedisp  = $sldisp

     C                   eval      saveexpdu = $slexpdu
     C                   eval      saveexpd  = $slexpd
     C*                  eval      $slexpdu  = *off
     C*                  eval      $slexpd   = 0

     C                   eval      saveslfdu = $slslfdu
     C                   eval      saveslfd  = $slslfd
     C*                  eval      $slslfdu  = *off
     C*                  eval      $slslfd   = 0

     C                   eval      saveprtyu = $slprtyu
     C                   eval      saveprty  = $slprty
     C*                  eval      $slprtyu  = *off
     C*                  eval      $slprty   = 0

     *      Set values unique to the virtual slot.

     C                   eval      $slitemu= *on
510dAC                   if        $psubcmd = '*CRTREPAKP'
510dAC                             or $psubcmd = '*CRTREPAKR'
610zAC                             or $psubcmd = '*CRTREPAKD'
510dAC                   eval      $slitem = #sentitem
510dAC                   else
500qDC**                 eval      $slitem = $saitem
500qMC                   eval      $slitem = #slotitem
510dAC                   endif
     C                   eval      $slhandu= *on
     C                   eval      $slhand = $vhand
     C                   eval      $sldispu= *on
     C                   eval      $sldisp = $vdisp

     C                   eval      $slstatu= *on
600yAC                   select
730gAc                   when      $sldesg = '*DROP'
740aDc*                  eval      $slstat='A '
740aMc                   eval      $slstat='DP'
650qAC                   when      $psubcmd = '*CRTPROD'
650qAc                              or $slstat = 'PR'
650qAC                   eval      $slstat = 'PR'
600yAC                   when      $psubcmd = '*TFR2USR'
610sAC                             or $psubcmd = '*TFR2USRR'
640dAC                             or $psubcmd = '*TFR2USRN'
600yAC                   eval      $slstat = frmSLRec.slstat
600yMC                   when      $psubcmd = '*CRTREPAKP'
510dAC                             or $psubcmd = '*CRTREPAKR'
510dAC                   eval      $slstat = 'RP'
610zAC                   when      $psubcmd = '*CRTREPAKD'
610zAC                   eval      $slstat = 'A'
600yMC                   other
600yDC**                 eval      $slstat = 'A'
610gAC                   if        slstat = 'Z' or slstat = 'V'
610gDC                   eval      $slstat = 'A'
610gDC                   else
600yMC                   eval      $slstat = slstat
610gDC                   endif
600yMC                   endsl
PCKcA*
PCKcAC                   if        client = Packers
PCKcA*      Force any putaway to have save slot status as Base slot.
PCKcAC                   if        $psubcmd = '*PUTAWAY'
PCKcAC                             and slstat = 'SO'
PCKcAC                   eval      $slstat = 'SO'
PCKcAC                   endif
PCKcA*
PCKcAC                   endif
PCKcA*

     C                   eval      $slrsrvu= *on
     C                   eval      $slrsrv = 'V'

     *      Create the virtual slot.

     C                   exsr      addslot
     C                   if        not error
     C                   eval      vslotcreated = *on
     C                   exsr      writelog
     C                   exsr      crtvslot
     C                   endif

     *      Restore values.

     C                   eval      $slexpdu = saveexpdu
     C                   eval      $slexpd  = saveexpd
     C                   eval      $slslfdu = saveslfdu
     C                   eval      $slslfd  = saveslfd
     C                   eval      $slprtyu = saveprtyu
     C                   eval      $slprty  = saveprty

     C     endcrtvirtual endsr

500nA*----------------------------------------------------------------
500nA*  crtvpick   Create Virtual Pick slot.
500nA*----------------------------------------------------------------

     C     crtvpick      begsr
600tAC                   eval      currRoutine = 'crtvpick'
600tAC                   exsr      phpgmV1V2V3s

500qDC**                 eval      $saitem = $slitem
     C                   exsr      crtvirtual
     C                   if        error
     C                   goto      endcrtvpick
     C                   endif

     C                   eval      $preturn = 'VRTPCKCRT'
     C                   exsr      getmsg

500n C     endcrtvpick   endsr

700cA*----------------------------------------------------------------
700cA*  crtvoflw   Create Virtual Overflow slot.
700cA*----------------------------------------------------------------

     C     crtvoflw      begsr
700cAC                   eval      currRoutine = 'crtvoflw'
700cAC                   exsr      phpgmV1V2V3s
700cA
700cAC                   exsr      crtvirtual
700cAC                   if        error
700cAC                   goto      endcrtvoflw
700cAC                   endif
700cA
700cAC                   eval      $preturn = 'VRTOFLCRT'
700cAC                   exsr      getmsg
700cA
700cAC     endcrtvoflw   endsr

     *----------------------------------------------------------------
     *  crtvslot   Create vslot record to connect virtual with base
     *----------------------------------------------------------------

     C     crtvslot      begsr
600tAC                   eval      currRoutine = 'crtvslot'
600tAC                   exsr      phpgmV1V2V3s

417qA* See if vslot exists.
417qA*   It shouldn't but we want to protect against an orphan rec.
417qA
417qAC                   eval      lock = *on
417qAC                   eval      check4err = *off
417qAC                   exsr      getvslot

     * Initialize fields.

     C                   eval      vswhse = $slwhse
     C                   eval      vswhdp = $slwhdp
     C                   eval      vsaisl = $slaisl
     C                   eval      vsloc  = $slloc
     C                   eval      vsrlvl = $slrlvl
     C                   eval      vshand = $slhand
     C                   eval      vsdisp = $sldisp
     C                   eval      vspdis = savedisp
     C                   eval      vscdte = $slsdte
     C                   eval      vsctim = $slstim

417qM* Update/Create vslot record.

417qAC                   if        not error
417qAC                   update(e) vsrec
417qAC                   if        %error
417qAC                   eval      error = *on
417qAC                   eval      $preturn = 'ERRUPDVS'
417qAC                   eval      $pmessage = 'Error on "Update '
417qAC                                       + 'VSlot" command '
417qAC                                       + '('
417qAC                                       + %Trim(%editc($slwhse:'Z'))
417qAC                                       + '/'
417qAC                                       + %trim($slwhdp)
417qAC                                       + '/'
417qAC                                       + %trim($sldisp)
417qAC                                       + ')'
417qAC                                       + '-' + f3messageid
417qAC                   goto      endcrtvslot
417qAC                   endif
417qAC                   else
417qAC                   eval      error = *off
     C                   write(e)  vsrec
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'ERRADDVS'
     C                   eval      $pmessage = 'Error on "Write '
     C                                       + 'VSlot" command '
     C                                       + '('
     C                                       + %Trim(%editc($slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim($slwhdp)
     C                                       + '/'
     C                                       + %trim($sldisp)
     C                                       + ')'
     C                                       + '-' + f3messageid
     C                   goto      endcrtvslot
     C                   endif
417qAC                   endif

     C     endcrtvslot   endsr


650qA*----------------------------------------------------------------
650qA*  crtProd    Create Production slot for item
650qA*----------------------------------------------------------------
650qA
650qAC     crtprod       begsr
650qAC                   eval      currRoutine = 'crtprod'
650qAC                   exsr      phpgmV1V2V3s
650qA
650qA*  Try and create a virtual slot.
650qA
650qAC                   exsr      crtvirtual
650qAC                   if        error
650qAC                   goto      endcrtprod
650qAC                   endif
650qA
650qA*  Move slot fields into data structure.
650qA
650qAC                   exsr      calcqtys
650qAC                   exsr      slot2ds
650qA
650qAC     endcrtprod    endsr
510dA*----------------------------------------------------------------
510dA*  crtrepack   Create repack slot for item.
510dA*----------------------------------------------------------------

     C     crtrepack     begsr
600tAC                   eval      currRoutine = 'crtrepack'
600tAC                   exsr      phpgmV1V2V3s

     *  Try and create a virtual slot.

     C                   exsr      crtvirtual
     C                   if        error
     C                   goto      endcrtrepack
     C                   endif

     *  Move slot fields into data structure.

611kAC                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endcrtrepack  endsr

700dA*----------------------------------------------------------------
700dA*  crtAMP     Create AMP-Advanced Merge Pick
700dA*----------------------------------------------------------------
700dA
700dAC     crtAMP        begsr
     C                   eval      currRoutine = 'crtamp'
     C                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slloc  = slloc
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  For PreP/AMP slots we only want to try to create a virtual
     *  slot within the aisle/loc/lvl that was sent in.
     *  Note, the aisle/loc/lvl equates to a single pallet so we are
     *  making the assumption that we will not have more than 702
     *  order detail lines on a pallet.

     C                   dow       forever = forever
     C                   eval      slhand = ' '
     C                   exsr      crtvirtual

     C                   select

     C                   when      not error
     C                   leave

     C                   endsl

     C                   enddo

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endCrtAMP
     C                   endif
     C                   endif

     C     endCrtAMP     endsr

600dA*----------------------------------------------------------------
600dA*  crtOSS     Create OSS slot
600dA*----------------------------------------------------------------
600dA
600daC     crtOSS        begsr
600tAC                   eval      currRoutine = 'crtoss'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  For OSS we will try to find an available slot for
     *  slot levels 1 - 10. That will give us 7020 possibilities.
     *  Therefore, we are assuming there will never be more than
     *  7020 items in a stage location.

     C                   dow       forever = forever
600vAC                   eval      slhand = ' '
     C                   exsr      crtvirtual

     C                   select

     C                   when      not error
     C                   leave

     C                   when      $slrlvl = 10
     C                   leave

     C                   other
     C                   eval      $slrlvl = $slrlvl + 1
     C                   iter

     C                   endsl

     C                   enddo

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endCrtOss
     C                   endif
     C                   endif

     C     endCrtOSS     endsr

611eA*----------------------------------------------------------------
611eA*  crtPRE     Create Pre-Pick slot
611eA*----------------------------------------------------------------
611eA
611eAC     crtPRE        begsr
     C                   eval      currRoutine = 'crtpre'
     C                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slloc  = slloc
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  For Pre-Pick slots we only want to try to create a virtual
     *  slot within the aisle/loc/lvl that was sent in.
     *  Note, the aisle/loc/lvl equates to a single pallet so we are
     *  making the assumption that we will not have more than 702
     *  order detail lines on a pallet.

     C                   dow       forever = forever
     C                   eval      slhand = ' '
     C                   exsr      crtvirtual

     C                   select

     C                   when      not error
     C                   leave

     C                   endsl

     C                   enddo

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endCrtPre
     C                   endif
     C                   endif

     C     endCrtPRE     endsr

600dA*----------------------------------------------------------------
600dA*  crtRCV     Create RCV slot
600dA*----------------------------------------------------------------
600dA
600daC     crtRCV        begsr
600tAC                   eval      currRoutine = 'crtrcv'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  For RCV we will try to find an available slot for
     *  slot levels 1 - 10. That will give us 7020 possibilities.
     *  Therefore, we are assuming there will never be more than
     *  7020 items in a receving location.

     C                   dow       forever = forever
600vAC                   eval      slhand = ' '
     C                   exsr      crtvirtual

     C                   select

     C                   when      not error
     C                   leave

     C                   when      $slrlvl = 10
     C                   leave

     C                   other
     C                   eval      $slrlvl = $slrlvl + 1
     C                   iter

     C                   endsl

     C                   enddo

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endCrtRcv
     C                   endif
     C                   endif

     C     endCrtRCV     endsr

720 A*----------------------------------------------------------------
720 A*  crtRPA     Create RPA slot
720 A*----------------------------------------------------------------
720 A
720 AC     crtRPA        begsr
720 AC                   eval      currRoutine = 'crtrpa'
720 AC                   exsr      phpgmV1V2V3s
720 AC                   eval      vslotcreated = *off
720 A
720 A*  Set aisle/loc/lvl based on base slot information
720 A*  from GETSLOT2USR, which was called in verifyqty.
720 A
720 AC                   eval      $slaisl = slaisl
720 AC                   eval      $slrlvl = slrlvl
720 AC                   eval      $sldisp = sldisp
720 A
720 A*  For RPA we will try to find an available slot for
720 A*  slot levels 1 - 10. That will give us 7020 possibilities.
720 A*  Therefore, we are assuming there will never be more than
720 A*  7020 items in a receving location.
720 A
720 AC                   dow       forever = forever
720 AC                   eval      slhand = ' '
720 AC                   exsr      crtvirtual
720 A
720 AC                   select
720 A
720 AC                   when      not error
720 AC                   leave
720 A
720 AC                   when      $slrlvl = 10
720 AC                   leave
720 A
720 AC                   other
720 AC                   eval      $slrlvl = $slrlvl + 1
720 AC                   iter
720 A
720 AC                   endsl
720 A
720 AC                   enddo

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endCrtRpa
     c                   else
     c                   eval      $sldisp = sldisp
     c                   eval      $slaisl = slaisl
     c                   eval      $slloc = slloc
     c                   eval      $slrlvl = slrlvl
     c                   eval      $slhand = slhand
     c                   eval      $sldisp = sldisp
     C                   endif
     C                   endif

     C     endCrtRPA     endsr

700sA*----------------------------------------------------------------
700sA*  crtRTNO    Create RTN slot
700sA*----------------------------------------------------------------
700sA
700saC     crtRTNO       begsr
700sAC                   eval      currRoutine = 'crtrtno'
700sAC                   exsr      phpgmV1V2V3s
700sAC                   eval      vslotcreated = *off

700sA*  Set aisle/loc/lvl based on base slot information
700sA*  from GETSLOT2USR, which was called in verifyqty.

700sAC                   eval      $slaisl = slaisl
700sAC                   eval      $slrlvl = slrlvl
700sAC                   eval      $sldisp = sldisp

700sA*  For RTN we will try to find an available slot for
700sA*  slot levels 1 - 10. That will give us 7020 possibilities.
700sA*  Therefore, we are assuming there will never be more than
700sA*  7020 items in a receving location.

700sAC                   dow       forever = forever
700sAC                   eval      slhand = ' '
700sAC                   exsr      crtvirtual

700sAC                   select

700sAC                   when      not error
700sAC                   leave

700sAC                   when      $slrlvl = 10
700sAC                   leave

700sAC                   other
700sAC                   eval      $slrlvl = $slrlvl + 1
700sAC                   iter

700sAC                   endsl

700sAC                   enddo

700sA*  If no error, get and lock the slot to be used.

700sAC                   if        not error
700sAC                   eval      lock = *on
700sAC                   eval      kywhse = slwhse
700sAC                   eval      kywhdp = slwhdp
700sAC                   eval      kydisp = sldisp
700sAC                   eval      check4err = *on
700sAC                   exsr      getslot2
700sAC                   if        error
700sAC                   eval      $slwhdpe = '1'
700sAC                   eval      $sldispe = '1'
700sAC                   goto      endCrtRTNO
700sAC                   endif
700sAC                   endif

700sAC     endCrtRTNO    endsr

730eA*----------------------------------------------------------------
730eA*  crtRWO     Create RWO slot
730eA*----------------------------------------------------------------
730eA
730eaC     crtRWO        begsr
730eAC                   eval      currRoutine = 'crtrwo'
730eAC                   exsr      phpgmV1V2V3s
730eAC                   eval      vslotcreated = *off

730eA*  Set aisle/loc/lvl based on base slot information
730eA*  from GETSLOT2USR, which was called in verifyqty.

730eAC                   eval      $slaisl = slaisl
730eAC                   eval      $slrlvl = slrlvl
730eAC                   eval      $sldisp = sldisp

730eA*  For RWO we will try to find an available slot for
730eA*  slot levels 1 - 10. That will give us 7020 possibilities.
730eA*  Therefore, we are assuming there will never be more than
730eA*  7020 items in a receving location.

730eAC                   dow       forever = forever
730eAC                   eval      slhand = ' '
730eAC                   exsr      crtvirtual

730eAC                   select

730eAC                   when      not error
730eAC                   leave

730eAC                   when      $slrlvl = 10
730eAC                   leave

730eAC                   other
730eAC                   eval      $slrlvl = $slrlvl + 1
730eAC                   iter

730eAC                   endsl

730eAC                   enddo

730eA*  If no error, get and lock the slot to be used.

730eAC                   if        not error
730eAC                   eval      lock = *on
730eAC                   eval      kywhse = slwhse
730eAC                   eval      kywhdp = slwhdp
730eAC                   eval      kydisp = sldisp
730eAC                   eval      check4err = *on
730eAC                   exsr      getslot2
730eAC                   if        error
730eAC                   eval      $slwhdpe = '1'
730eAC                   eval      $sldispe = '1'
730eAC                   goto      endCrtRWO
730eAC                   endif
730eAC                   endif

730eAC     endCrtRWO     endsr

600dA*----------------------------------------------------------------
600dA*  crtSTG     Create STG slot
600dA*----------------------------------------------------------------
600dA
600daC     crtSTG        begsr
600tAC                   eval      currRoutine = 'crtstg'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  For STG we will try to find an available slot for
     *  slot levels 1 - 10. That will give us 7020 possibilities.
     *  Therefore, we are assuming there will never be more than
     *  7020 items in a stage location.

     C                   dow       forever = forever
600vAC                   eval      slhand = ' '
     C                   exsr      crtvirtual

     C                   select

     C                   when      not error
     C                   leave

     C                   when      $slrlvl = 10
     C                   leave

     C                   other
     C                   eval      $slrlvl = $slrlvl + 1
     C                   iter

     C                   endsl

     C                   enddo

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endCrtStg
     C                   endif
     C                   endif

     C     endCrtSTG     endsr

600dA*----------------------------------------------------------------
600dA*  crtUSR     Create USR slot
600dA*----------------------------------------------------------------
600dA
600daC     crtUSR        begsr
600tAC                   eval      currRoutine = 'crtusr'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  For USRIN we try once because the loc/lvl conatins the emp#

     C                   exsr      crtvirtual

     *  If no error, get and lock the slot to be used.

     C                   if        not error
     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   endif
     C                   endif

     C     endCrtUSR     endsr

     *----------------------------------------------------------------
     *  crtxdk   Create crossdock slot for item.
     *----------------------------------------------------------------

     C     crtxdock      begsr
600tAC                   eval      currRoutine = 'crtxdock'
600tAC                   exsr      phpgmV1V2V3s

     *  See if xdock slot already exists for item.

     C                   exsr      getxdock
     C                   if        not error
     C                   exsr      slot2ds
     C                   eval      $preturn = 'XDKEXIST'
     C                   exsr      getmsg
     C                   goto      endcrtxdock
     C                   else
611dAC                   eval      error = *off
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   endif

     *  Make sure file is open.

     C                   if        not %open(slot1)
     C                   exsr      openslot1
     C                   if        error
     C                   goto      endcrtxdock
     C                   endif
     C                   endif

     *  Find next available XDK slot to use.
611dA*  XDK is no longer hardcoded, instead, the aisle passed in
611dA*  will be used.

     C                   z-add     1             tmploc
700hAC                   z-add     1             tmplvl
611dDC**                 move      'XDK'         kyaisl
611dMC                   move      $slaisl       kyaisl
     C     keys1x        setll     slot1
 1B  C                   dow       forever = forever
     C     keys1x        reade(n)  slot1
 2B  C                   if        %eof or slloc > tmploc
700hAC                                  or slrlvl > tmplvl
 1L  C                   leave
 2E  C                   endif
700hA*
700hAC                   if        tmploc = 999
700hAC                   eval      tmplvl = tmplvl + 1
700hAC                   eval      tmploc = 0
700hAC                   endif
700hA*
 2E  C                   eval      tmploc = tmploc + 1
 1E  C                   enddo

     *  Get current date and time.

     C                   exsr      getdatetime

     *  Clear slot record.

     C                   clear                   slrec

     *  Move information into slot fields.

     C                   eval      slwhse = $slwhse
     C                   eval      slwhdp = #slotwhdp
611dDC**                 eval      slaisl = 'XDK'
611dMC                   eval      slaisl = $slaisl
     C                   eval      slloc  = tmploc
700hDC*                  eval      slrlvl = 1
700hMC                   eval      slrlvl = tmplvl
     C                   eval      slhand = ' '
     C                   eval      slstyp = 'X'
     C                   eval      slpseq = tmploc
     C                   eval      slitem = #slotitem
     C                   eval      slstat = 'XD'
     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime
     C                   eval      slpick = 'N'
     C                   eval      slrsrv = 'N'
     C                   eval      slprty = 0
     C                   eval      slentd = curdate

     C                   if        $slexpdu
     C                   eval      slexpd = $slexpd
     C                   endif

     C     slloc         div       2             dummy
     C                   mvr                     slside

     *    Format display slot.
611dA*      Move signed numeric fields into packed fields
611dA*      to pass to FRMTSL.
611dAC                   eval      pkd_slwhse = slwhse
611dAC                   eval      pkd_slloc  = slloc
611dAC                   eval      pkd_slrlvl = slrlvl
611dAC                   eval      pkd_slpseq = slpseq

     C                   call      'FRMTSL'
611dDC**                 parm                    slwhse
611dMC                   parm                    pkd_slwhse
     C                   parm                    slwhdp
     C                   parm                    slaisl
611dDC**                 parm                    slloc
611dMC                   parm                    pkd_slloc
611dDC**                 parm                    slrlvl
611dMC                   parm                    pkd_slrlvl
     C                   parm                    slhand
     C                   parm                    slstyp
611dDC**                 parm                    slpseq
611dMC                   parm                    pkd_slpseq
     C                   parm                    sldisp

     *  Add record

     C                   write(e)  slrec
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'ERRADDXDK'
     C                   eval      $pmessage = 'Error on "Write '
     C                                       + 'XDK" command '
     C                                       + '('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'
     C                                       + '-' + f1messageid
     C                   goto      endcrtxdock
     C                   endif

     *  Move slot fields into data structure.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     *  When called from Dakota, send *ADDXDOCK to host.

     C                   if        DakotaCall
     C                   eval      savesubcmd = $psubcmd
     C                   eval      $psubcmd   = '*ADDXDOCK'
     C                   exsr      callhost
     C                   eval      $psubcmd   = savesubcmd
     C                   if        $preturn <> '*OK'
     C                   eval      $preturn  = '*OK'
     C                   eval      $pmessage = ' '
     C                   endif
     C                   endif

     C     endcrtxdock   endsr

640tA*----------------------------------------------------------------
640tA*  dpundo   Undo Directed Putaway
640tA*----------------------------------------------------------------
640tA
640tAC     dpundo        begsr
     C                   eval      currRoutine = 'dpundo'
     C                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  Get and lock slot.

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2

     C                   if        error
     C                   leavesr
     C                   endif

     *  Change status code for ...

     C                   select

     *    Virtual slots - Delete record and skip to end.

     C                   when      slrsrv = 'V'
     C                   exsr      deleteslot
     C                   leavesr

     *    Otherwise, Verify slot.

     C                   other
     C                   exsr      set2vfy

     C                   endsl

     C                   endsr

417cA*----------------------------------------------------------------
417cA*  deletecrossdk  Delete associated crossdk records.
417cA*----------------------------------------------------------------
417cA
417cAC     deletecrossdk begsr
600tAC                   eval      currRoutine = 'deletecrossdk'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  Open crossdk file.

     C                   exsr      opencrossdk
     C                   if        error
     C                   goto      enddltcrossdk
     C                   endif

     *  Delete special order record(s)

     C     keyvs2        setll     crossdk
 3B  C                   dou       forever <> forever
     C     keyvs2        reade     cdrec
 4B  C                   if        %eof
 3L  C                   leave
 4E  C                   endif
     C                   delete    cdrec
 3E  C                   enddo

     C     enddltcrossdk endsr

610oA*----------------------------------------------------------------
610oA*  deletelcns  Delete license for a slot.
610oA*----------------------------------------------------------------
610oA
610oAC     deletelcns    begsr
     C                   eval      currRoutine = 'deletelcns'
     C                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     C                   exsr      clr$license

     C                   if        $saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = $saAction
     C                   endif

     C                   if        $saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = $saETrn#
     C                   endif

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = sldesg

     C                   eval      $dricommand = 'DRILICENSE'
     C                   eval      $drisubcmd  = '%DELETESLT'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     C                   endsr

     *----------------------------------------------------------------
     *  deleteslot  Delete slot record.
     *----------------------------------------------------------------

     C     deleteslot    begsr
600tAC                   eval      currRoutine = 'deleteslot'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off
640mA
640mA*  Skip slot delete for *DELETEWEB (already done by MRC)
700aA*  This code was removed MRC will not be doing the update.
640mA
700aDC*                  if        $psubcmd = '*DELETEWEB'
700aDC*                  goto      skipDelete
700aDC*                  endif

     *  Get and lock slot.

417cAC                   if        $psubcmd <> '*ZEROVFY'
600dAC                             and %subst($psubcmd:5:4) <> '2USR'
600dAC                             and %subst($psubcmd:1:4) <> '*USR'
610mAC                             and $psubcmd <> '*ADJUST'
710bAC                             and $psubcmd <> '*ADJUSTIMP'
650pAC                             and $psubcmd <> '*ADJUSTREV'
650mAC                             or getagain = *on

     C                   if        $psubcmd = '*DELETE'  or
     C                             $psubcmd = '*DELETEI' or
     C                             $psubcmd = '*DELETEX' or
611lAC                             getagain = *on or
600iAC                             $psubcmd = '*STUFFDLT'
700aAC                             or $psubcmd = '*DELETEWEB'
     C                   eval      lock = *on
     C                   else
     C                   eval      lock = *off
     C                   endif

     C                   if        $psubcmd = '*DELETE' or
416kMC                             $psubcmd = '*DELETEX' or
600iAC                             $psubcmd = '*STUFFDLT' or
611lAC                             getagain = *on or
416kAC                             $psubcmd = '*VERIFYDEL'
700aAC                             or $psubcmd = '*DELETEWEB'
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   else
     C                   exsr      getslot1
     C                   endif

     C                   if        error
     C                   goto      enddel
     C                   endif

417cAC                   endif

     *  Check for quantity.

     C                   if        $psubcmd <> '*DELETEX'
600iAC                             and $psubcmd <> '*STUFFDLT'
417cAC                             and $psubcmd <> '*ZEROVFY'
600dAC                             and %subst($psubcmd:5:4) <> '2USR'
600dAC                             and %subst($psubcmd:1:4) <> '*USR'
610mAC                             and $psubcmd <> '*ADJUST'
710bAC                             and $psubcmd <> '*ADJUSTIMP'
650pAC                             and $psubcmd <> '*ADJUSTREV'
     C                   if        slstk1 <> 0 or
     C                             slstk2 <> 0 or
     C                             slstk3 <> 0 or
     C                             slalc1 <> 0 or
     C                             slalc2 <> 0 or
     C                             slalc3 <> 0 or
     C                             sltfr1 <> 0 or
     C                             sltfr2 <> 0 or
     C                             sltfr3 <> 0 or
     C                             slpck1 <> 0 or
     C                             slpck2 <> 0 or
     C                             slpck3 <> 0 or
     C                             slrcv1 <> 0 or
     C                             slrcv2 <> 0 or
     C                             slrcv3 <> 0
     C                   eval      error = *on
416kMC                   if        $psubcmd = '*DELETE' or
416kAC                             $psubcmd = '*VERIFYDEL'
700aAC                             or $psubcmd = '*DELETEWEB'
     C                   unlock    slot2
     C                   endif
     C                   if        $psubcmd = '*DELETEI'
     C                   unlock    slot1
     C                   endif
     C                   eval      $preturn = 'DELQTYEXST'
     C                   exsr      getmsg
     C                   goto      enddel
     C                   endif
     C                   endif

     *  Skip actual delete for *VERIFY.

     C                   if        $psubcmd = '*VERIFYDEL'
     C                   goto      enddel
     C                   endif

     *  Delete slot record.

601eDC**                 if        $psubcmd = '*DELETE' or
601eDC**                           $psubcmd = '*DELETEX' or
601eDC**                           $psubcmd = '*STUFFDLT' or
601eDC**                           $psubcmd <> '*ZEROVFY'
601eDC**                 delete(e) slrec2
601eDC**                 else
601eDC**                 delete(e) slrec
601eDC**                 endif
601eAC                   if        $psubcmd = '*DELETEI'
601eAC                             or $psubcmd = '*STUFFDLT'
601eAC                   delete(e) slrec
601eAC                   else
601eAC                   delete(e) slrec2
601eAC                   endif
     C                   if        %error
     C                   eval      $preturn = 'DELERROR'
     C                   eval      $pmessage = 'Error on "Delete Slot" '
     C                                       + 'command '
     C                                       + '('
     C                                       + %Trim(%editc($slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim($slwhdp)
     C                                       + '/'
     C                                       + %trim($sldisp)
     C                                       + ')'
     C                   if        $psubcmd = '*DELETE'
     C                   eval      $pmessage = %trim($pmessage)
     C                                       + '-' + f2messageid
     C                   else
     C                   eval      $pmessage = %trim($pmessage)
     C                                       + '-' + f1messageid
     C                   endif

     C                   goto      enddel
     C                   endif

640mAc     skipDelete    tag

     *  Delete corresponding vslot record.

     C                   exsr      deletevslot
417cA
417cA*  Delete crossdock record(s).
417cA
417cAC                   exsr      deletecrossdk
417cA
417cA*  Delete special order record(s).
417cA
417cAC                   exsr      deletespclord
417cA
417cA*  Delete Printed exception record(s).
417cA
417cAC                   exsr      deletevslexcp
510aA
510aA*  Delete slot date record(s).
510aA
510aAC                   exsr      deleteslotdte
600rA
600rA*  Delete any associated license records
600rA
600rAC                   if        $saAction = 'OSS'
610oAC                             or $psubcmd = '*ZEROVFY'
600rA
610oAC                   exsr      deletelcns
600rA
600rAC                   endif

611lAC     enddel        tag
611lAC                   eval      getagain = *off
611lDC**   enddel        endsr
611lMC                   endsr

510aA*----------------------------------------------------------------
510aA*  deleteslotdte  Delete associated slotdte records.
510aA*----------------------------------------------------------------
510aA
510aAC     deleteslotdte begsr
600tAC                   eval      currRoutine = 'deleteslotdte'
600tAC                   exsr      phpgmV1V2V3s

     C                   call      'UPDSLTDTE'
     C                   parm      '*DELETE'     $ucmd             8
     C                   parm      $pprogram     $upgm            10
     C                   parm      #prog         $upgm2           10
     C                   parm      slwhse        $uwhse            3 0
     C                   parm      slwhdp        $uwhdp            5
     C                   parm      sldisp        $uslot           12
     C                   parm      slpick        $upick            1
     C                   parm      ' '           $uitem           15
     C                   parm      ' '           $unewi           15
     C                   parm      0             $uentd            8 0
     C                   parm      0             $uexpd            8 0
     C                   parm      0             $uqty1            5 0
     C                   parm      0             $uqty2            5 0
     C                   parm      0             $uqty3            5 0
     C                   parm      ' '           $urtn             8

     C                   endsr

640mA*----------------------------------------------------------------
640mA*  DeleteSlotWeb  Delete slot for *ADDWEB
640mA*----------------------------------------------------------------
640mA
640mAC     DeleteSlotWeb begsr
     C                   eval      currRoutine = 'deleteslotweb'
     C                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2

     C                   if        not error
     C                   delete(e) slrec2
     C                   endif

     C                   eval      error = *off

     C                   endsr

417cA*----------------------------------------------------------------
417cA*  deletespclord  Delete associated spclord records.
417cA*----------------------------------------------------------------
417cA
417cAC     deletespclord begsr
600tAC                   eval      currRoutine = 'deletespclord'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  Open spclord file.

     C                   exsr      openspclord
     C                   if        error
     C                   goto      enddltspclord
     C                   endif

     *  Delete special order record(s)

     C     keyvs2        setll     spclord
 2B  C                   dou       forever <> forever
     C     keyvs2        reade     sprec
     C                   if        %eof
 2L  C                   leave
 3E  C                   endif
     C                   delete(e) sprec
 2E  C                   enddo

     C     enddltspclord endsr

     *----------------------------------------------------------------
     *  deletevslot  Delete vslot record.
     *----------------------------------------------------------------

     C     deletevslot   begsr
600tAC                   eval      currRoutine = 'deletevslot'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     C*  Get and lock vslot.

     C                   eval      lock = *on
416rAC                   eval      check4err = *off
     C                   exsr      getvslot

     C*  If there is an error, assume that vslot record doesn't exist.

     C                   if        error
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   goto      endvdel
     C                   endif

      *  Delete vslot record.

     C                   delete(e) vsrec
     C                   if        %error
     C                   eval      $preturn = 'DELERRORV'
     C                   eval      $pmessage = 'Error on "Delete VSlot" '
     C                                       + 'command '
     C                                       + '('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(slaisl)
     C                                       + '/'
     C                                       + %Trim(%editc(slloc:'Z'))
     C                                       + '/'
     C                                       + %Trim(%editc(slrlvl:'Z'))
     C                                       + '/'
     C                                       + %trim(slhand)
     C                                       + ')'
     C                                       + '-' + f3messageid
     C                   goto      endvdel
     C                   endif

     C     endvdel       endsr

417cA*----------------------------------------------------------------
417cA*  deletevslexcp  Delete associated vslexcp records.
417cA*----------------------------------------------------------------
417cA
417cAC     deletevslexcp begsr
600tAC                   eval      currRoutine = 'deletevslexcp'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  Open vslexcp file.

     C                   exsr      openvslexcp
     C                   if        error
     C                   goto      enddltvslexcp
     C                   endif

     *  Delete Printed exception record(s).

     C     keyvs2        setll     vslexcp
 2B  C                   dow       forever = forever
     C     keyvs2        reade     vslexcp
     C                   if        %eof
 2L  C                   leave
 3E  C                   endif
     C                   if        vxpdte <> 0
     C                   delete(e) vxrec
 3E  C                   endif
 2E  C                   enddo


     C     enddltvslexcp endsr

416cA*----------------------------------------------------------------
416cA*  fixbrkdn  Fix breakdown quantities.
416cA*----------------------------------------------------------------
416cA
416cAC     fixbrkdn      begsr
600tAC                   eval      currRoutine = 'fixbrkdn'
600tAC                   exsr      phpgmV1V2V3s

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     *  Recalculate slot available quantities.

     C                   exsr      calcqtys

     *  First make sure there are no negative available brkdn2/3 qtys.

     *    Breakdown 3 ...

600xMC                   if        #slotumq3orig > 0
 2B  C                   dow       slavl3 < 0
     C                   eval      slstk2 = slstk2 - 1
600xMC                   eval      slstk3 = slstk3 + #slotumq3orig
     C                   eval      slavl2 = slavl2 - 1
600xMC                   eval      slavl3 = slavl3 + #slotumq3orig
     C                   eval      #whsefix2 = #whsefix2 - 1
600xMC                   eval      #whsefix3 = #whsefix3 + #slotumq3orig
 2E  C                   enddo
 2E  C                   endif

     *    Breakdown 2 ...

600xMC                   if        #slotumq2orig > 0
 2B  C                   dow       slavl2 < 0
     C                   eval      slstk1 = slstk1 - 1
600xMC                   eval      slstk2 = slstk2 + #slotumq2orig
     C                   eval      slavl1 = slavl1 - 1
600xMC                   eval      slavl2 = slavl2 + #slotumq2orig
     C                   eval      #whsefix1 = #whsefix1 - 1
600xMC                   eval      #whsefix2 = #whsefix2 + #slotumq2orig
 2E  C                   enddo
 2E  C                   endif

     *  Now try to "up" available/stock quantities.
650aA*  Do not up the qty if BFC designation and SSB item
650aAc                   if        sldesg = 'BFC' and #senttype = 'S'
650aAc                   else

     *    Breakdown 3 ...

600xMC                   if        #slotumq3orig > 0
600xMC                   dow       slavl3 >= #slotumq3orig
600xMC                   eval      slstk3 = slstk3 - #slotumq3orig
     C                   eval      slstk2 = slstk2 + 1
600xMC                   eval      slavl3 = slavl3 - #slotumq3orig
     C                   eval      slavl2 = slavl2 + 1
600xMC                   eval      #whsefix3 = #whsefix3 - #slotumq3orig
     C                   eval      #whsefix2 = #whsefix2 + 1
 2E  C                   enddo
 2E  C                   endif

     *    Breakdown 2 ...

600xMC                   if        #slotumq2orig > 0
600xMC                   dow       slavl2 >= #slotumq2orig
600xMC                   eval      slstk2 = slstk2 - #slotumq2orig
     C                   eval      slstk1 = slstk1 + 1
600xMC                   eval      slavl2 = slavl2 - #slotumq2orig
     C                   eval      slavl1 = slavl1 + 1
600xMC                   eval      #whsefix2 = #whsefix2 - #slotumq2orig
     C                   eval      #whsefix1 = #whsefix1 + 1
 2E  C                   enddo
 2E  C                   endif
650aAc                   endif
 2E
     C                   endsr

416rA*----------------------------------------------------------------
416rA*  getbaseslot  Get corresponding base slot
416rA*----------------------------------------------------------------

     C     getbaseslot   begsr
600tAC                   eval      currRoutine = 'getbaseslot'
600tAC                   exsr      phpgmV1V2V3s

600mMC                   eval      baseDisp = sldisp

600dAC                   select
600dA
600mMC                   when      slaisl = aisleRCV
700sAC                             or slaisl = aisleRTN
730eAC                             or slaisl = aisleRWO
720 AC                             or slaisl = aisleRPA
600mMC                             or slaisl = aisleSTG
600mMC                   eval      pos = %scan('-':sldisp)
600dAC                   if        pos > 0
600mMC                   eval      baseDisp = %subst(sldisp:1:pos-1)
600dAC                   else
600mMC                   eval      baseDisp = %subst(sldisp:1:9)
600dAC                   endif
600dAC                   leavesr
600dA
600mMC                   when      slaisl = aisleUSR
600mMC                   eval      baseDisp = %subst(sldisp:1:8)
600dAC                   leavesr
600dA
600dAC                   endsl

600mMC                   if        slrsrv = 'V'
     C                   eval      check4err = *off
     C                   eval      lock = *off
     C                   exsr      getvslot
     C                   if        error
     C                   eval      error = *off
     C                   else
600mMC                   eval      baseDisp = vspdis
     C                   endif
     C                   endif

     C                   endsr

417eA*----------------------------------------------------------------
417eA*  getchkdigit  Get slot check digit.
417eA*----------------------------------------------------------------
417eA
417eAC     getchkdigit   begsr
600tAC                   eval      currRoutine = 'getchkdigit'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      lockedslotdgt = *off

     C* Open slotdgt file.

     C                   if        not %open(slotdgt)
     C                   exsr      openslotdgt
     C                   if        error
     C                   goto      endgetslotdgt
     C                   endif
     C                   endif

     C* Get slotdgt record

     C                   if        lock
     C     keyscd        chain     slotdgt
     C                   else
     C     keyscd        chain(n)  slotdgt
     C                   endif

     C                   if        not %found
     C                   clear                   scdrec
     C***                eval      error = *on
     C***                eval      $preturn = 'INVLDSLOT'
     C***                exsr      getmsg
     C                   goto      endgetslotdgt
     C                   endif

     C                   if        lock
     C                   eval      lockedslotdgt = *on
     C                   endif

     C     endgetslotdgt endsr

417iA*----------------------------------------------------------------
417iA*  getdateopt   Get Expiration/Entered date options
     *               Default to use Oldest Date.
417iA*----------------------------------------------------------------
417iA
417iAC     getdateopt    begsr
600tAC                   eval      currRoutine = 'getdateopt'
600tAC                   exsr      phpgmV1V2V3s

     C                   eval      kywhse = $slwhse
     C                   eval      opcode = '*DATEOPT'
     C     keyop         chain     options
     C                   if        %found
     C                   eval      opdta1 = opdata
     C                   else
     C                   eval      opltdn = '2'
     C                   eval      opodrp = '2'
     C                   eval      opsltf = '2'
     C                   eval      opparc = '2'
     C                   eval      oppart = '2'
     C                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  getdatetime  Get current date & time
     *----------------------------------------------------------------

     C     getdatetime   begsr

     C                   time                    curtime

710mDC*                  if        curtime < lasttime
     C                   eval      $cvcmd = '*CURCMD '
     C                   call      @cvtdt
     C                   parm                    $cvtdt
     C                   eval      curdate = $cvd8o
710mDC*                  endif

     C                   eval      lasttime = curtime

     C                   endsr

     *----------------------------------------------------------------
     *  getdept   Get department info.
     *----------------------------------------------------------------

     C     getdept       begsr
600tAC                   eval      currRoutine = 'getdept'
600tAC                   exsr      phpgmV1V2V3s

600eMC                   exsr      clr$dept

     C                   eval      $wdpmth = '1'
     C                   eval      $wdwhse = $slwhse
     C                   eval      $wdcode = $slwhdp

600eMC                   eval      $dricommand = 'DRIDEPT'
600eMC                   eval      $drisubcmd = '*GET'
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3err and
     C                             check4err = *on
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   endsl

640uAC                   if        $wdpmth = '2'
640uAC                             or $psubcmd = '*STAGEPUT'
640uAC                             or $psubcmd = '*CLSSTGPUT'
640uAC                             or $psubcmd = '*VFYSTGPUT'
     C                   eval      ManualPutaway = *on
     C                   eval      DirectPutaway = *off
640uAC                   else
640uAC                   eval      DirectPutaway = *on
640uAC                   eval      ManualPutaway = *off
640uAC                   endif

     C     endgetdept    endsr

     *----------------------------------------------------------------
     *  getdesig  Get designation info.
     *----------------------------------------------------------------

     C     getdesig      begsr
600tAC                   eval      currRoutine = 'getdesig'
600tAC                   exsr      phpgmV1V2V3s

600eMC                   exsr      clr$desig

     C                   eval      $dstype = 'H'
     C                   eval      $dscode = desigcode

600eMC                   eval      $dricommand = 'DRIDESIG'
600eMC                   eval      $drisubcmd = '*GET'
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3err and
     C                             check4err = *on
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   endsl

     C     endgetdesig   endsr

     *----------------------------------------------------------------
     *  getmsg   Get message for error code.
     *----------------------------------------------------------------

     C     getmsg        begsr

     C                   select

640lAC                   when      $preturn = 'ADJQTYMAX'
640lAC                   eval      $pmessage = 'Adjustment quantity woul'
640lAC                                       + 'd exceed maximum of 99999'

     C                   when      $preturn = 'ALLZERO'
     C                   eval      $pmessage = 'All quantites and catch '
     C                                       + 'weight values are zero'

     C                   when      $preturn = 'ASLNOTSNT'
     C                   eval      $pmessage = 'Aisle code must be sent'

     C                   when      $preturn = 'BLANKDISP'
     C                   eval      $pmessage = 'Slot display cannot be '
     C                                       + 'blank'

     C                   when      $preturn = 'BLANKITEM'
     C                   eval      $pmessage = 'Item number cannot be blank'

417fAC                   when      $preturn = 'BRKNOTDEF'
417fAC                   eval      $pmessage = 'Breakdown not defined'
417fAC                                       + 'for parent item'

600dAC                   when      $preturn = 'CDSPNOTSNT'
600dAC                   eval      $pmessage = 'Corresponding display '
600dAC                                       + 'must be sent'

417dAC                   when      $preturn = 'CITMNOTALW'
     C                   eval      $pmessage = 'Corresponding item not  '
     C                                       + 'allowed for '
     C                                       + $psubcmd

600dAC                   when      $preturn = 'CWHDNOTSNT'
600dAC                   eval      $pmessage = 'Corresponding department '
600dAC                                       + 'must be sent'

     C                   when      $preturn = 'DELQTYEXST'
     C                   eval      $pmessage = 'Slot not deleted - '
     C                                       + 'Quantity exists '
     C                                       + '('
     C                                       + %Trim(%editc($slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim($slwhdp)
     C                                       + '/'
     C                                       + %trim($sldisp)
     C                                       + ')'

417jAC                   when      $preturn = 'DIFEXPDTE'
417jAC                   eval      $pmessage = 'Putaway not allowed - '
417jAC                                       + 'Expiration dates different'

500gAC                   when      $preturn = 'DIFLOTCODE'
500gAC                   eval      $pmessage = 'Putaway not allowed - '
500gAC                                       + 'Lot codes different'

     C                   when      $preturn = 'DSPNOTSNT'
     C                   eval      $pmessage = 'Slot display must be sent'

650qAC                   when      $preturn = 'PRDCUSBAD'
650qAC                   eval      $pmessage = 'Invalid Customer Number'

416bAC                   when      $preturn = 'ENTDNOTSNT'
416bAC                   eval      $pmessage = 'Enter date must be sent'

416bAC                   when      $preturn = 'EXPDNOTSNT'
416bAC                   eval      $pmessage = 'Expire date must be sent'

500gAC                   when      $preturn = 'HLPEXIST'
500gAC                   eval      $pmessage = 'Putaway not allowed - '
500gAC                                       + 'High Track LP Exists'

     C                   when      $preturn = 'HNDNOTSNT'
     C                   eval      $pmessage = 'Handstack must be sent'
500nA
500nAC                   when      $preturn = 'INSLOT'
500nAC                   eval      $pmessage = 'Item '
500nAC                                       + %trim($slitem)
500nAC                                       + ' already in slot '
500nAC                                       + %trim($sldisp)

     C                   when      $preturn = 'INVLDBRKQ'
     C                   eval      $pmessage = 'Breakdow quantity not '
     C                                       + 'allowed for item'

417dAC                   when      $preturn = 'INVLDCBRKQ'
417dAC                   eval      $pmessage = 'Breakdown qty not '
417dAC                                       + 'allowed for '
417dAC                                       + 'corresponding item'

417dAC                   when      $preturn = 'INVLDCITYP'
417dAC                   eval      $pmessage = 'Invalid corresponding '
417dAC                                       + 'item type '
417dAC                                       + '(' + #slottype + ') '
417dAC                                       + 'for transfer'

417dAC                   when      $preturn = 'INVLDITYP'
417dAC                   eval      $pmessage = 'Invalid item type '
417dAC                                       + '(' + #slottype + ')'
417dAC                                       + 'for transfer'

     C                   when      $preturn = 'INVLDPICK'
     C                   eval      $pmessage = 'Invalid pick slot option '
     C                                       + '(' + $slpick + ')'

417fAC                   when      $preturn = 'INVLDQTY1'
417fAC                   eval      $pmessage = 'Quantity 1 not multiple of '
417fAC                                       + 'base quantity'

417fAC                   when      $preturn = 'INVLDQTY2'
417fAC                   eval      $pmessage = 'Quantity 2 not multiple of '
417fAC                                       + 'base quantity'

     C                   when      $preturn = 'INVLDRSRV'
     C                   eval      $pmessage = 'Invalid reserve slot '
     C                                       + 'option '
     C                                       + '(' + $slrsrv + ')'

     C                   when      $preturn = 'INVLDSBCMD'
     C                   eval      $pmessage = 'Invalid subcommand '
     C                                       + '(' + %trim($psubcmd) + ') '
     C                                       + 'sent to ' + %trim(#prog)

     C                   when      $preturn = 'INVLDSLOT'
     C                   eval      $pmessage = 'Invalid slot '
     C                                       + '('
     C                                       + %Trim(%editc($slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim($slwhdp)
     C                                       + '/'
     C                                       + %trim($sldisp)
     C                                       + ')'

     C                   when      $preturn = 'INVLDSTYP'
     C                   eval      $pmessage = 'Invalid section type '
     C                                       + '(' + $slstyp + ')'

600dAC                   when      $preturn = 'USRSLTITM'
600dAC                   eval      $pmessage = 'USR slot contains '
600dAC                                       + 'different item ('
600dAC                                       + %trim(slitem)
600dAC                                       + '/'
600dAC                                       + %trim($slitem)
600dAC                                       + ')'

600dAC                   when      $preturn = 'INVLDUSLOT'
600dAC                   eval      $pmessage = 'Invalid USR slot '
600dAC                                       + '('
600dAC                                       + %Trim(%editc($slwhse:'Z'))
600dAC                                       + '/'
600dAC                                       + %trim($sacwhd)
600dAC                                       + '/'
600dAC                                       + %trim($sacdsp)
600dAC                                       + ')'

     C                   when      $preturn = 'INVLDVSLOT'
     C                   eval      $pmessage = 'Invalid vslot '
     C                                       + '('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(slaisl)
     C                                       + '/'
     C                                       + %Trim(%editc(slloc:'Z'))
     C                                       + '/'
     C                                       + %Trim(%editc(slrlvl:'Z'))
     C                                       + '/'
     C                                       + %trim(slhand)
     C                                       + ')'

     C                   when      $preturn = 'INVLDVSTAT'
     C                   eval      $pmessage = 'Status cannot be changed '
     C                                       + 'to "V" because quantity '
     C                                       + 'exists'

     C                   when      $preturn = 'INVLDZSTAT'
     C                   eval      $pmessage = 'Status cannot be changed '
     C                                       + 'to "Z" because quantity '
     C                                       + 'exists'

PAK AC                   when      $preturn = 'INVLDPSTAT'
PAK AC                   eval      $pmessage = 'Status cannot be changed '
PAK AC                                       + 'to QA or BL unless slot'
PAK AC                                       + ' is empty'

611fAC                   when      $preturn = 'INWORKUSR'
611fAC                   eval      $pmessage = 'Slot '
611fAC                                       + %trim($slwhdp)
611fAC                                       + '/'
611fAC                                       + %trim($sldisp) + ' '
611fAC                                       + 'in use. Cannot be Verified. '

     C                   when      $preturn = 'ISMISMTCH'
     C                   eval      $pmessage = 'Item dept/styp/desg '
     C                                       + '('
     C                                       + %trim($itwhdp)
     C                                       + '/'
     C                                       + %trim($itstyp)
     C                                       + '/'
     C                                       + %trim($itdesg)
     C                                       + ')'
     C                                       + ' does not match slot'

600qAC                   when      $preturn = 'ISMISMTCH2'
600qAC                   eval      $pmessage = 'Item dept/styp/desg '
600qAC                                       + '('
600qAC                                       + %trim(#slotwhdp)
600qAC                                       + '/'
600qAC                                       + %trim(#slotstyp)
600qAC                                       + '/'
600qAC                                       + %trim(#slotdesg)
600qAC                                       + ')'
600qAC                                       + ' does not match slot'

600qAC                   when      $preturn = 'ISMISMTCH3'
600qAC                   eval      $pmessage = 'Item dept/styp/desg '
600qAC                                       + '('
600qAC                                       + %trim(#sentwhdp)
600qAC                                       + '/'
600qAC                                       + %trim(#sentstyp)
600qAC                                       + '/'
600qAC                                       + %trim(#sentdesg)
600qAC                                       + ')'
600qAC                                       + ' does not match slot'

     C                   when      $preturn = 'ITEMCHG'
     C                   eval      $pmessage = 'Item cannot be changed - '
     C                                       + 'Quantity exists '

610gAC                   when      $preturn = 'ITMFOUND'
610gAC                   eval      $pmessage = 'Item found in physical slot'

417fAC                   when      $preturn = 'ITMNOTCOMP'
417fAC                   eval      $pmessage = 'Normal item and Breakdown '
417fAC                                       + 'item are not compatible'

610gAC                   when      $preturn = 'ITMNOTFND'
610gAC                   eval      $pmessage = 'Item not found in physical slot'

600dAC                   when      $preturn = 'ITMNOTMTCH'
600dAC                   eval      $pmessage = 'License item '
600dAC                                       + 'no longer in license slot'

     C                   when      $preturn = 'ITMNOTSNT'
     C                   eval      $pmessage = 'Item number must be sent'

     C                   when      $preturn = 'LOCNOTSNT'
     C                   eval      $pmessage = 'Location must be sent'

     C                   when      $preturn = 'LVLNOTSNT'
     C                   eval      $pmessage = 'Level must be sent'

500gAC                   when      $preturn = 'MLPEXIST'
500gAC                   eval      $pmessage = 'Putaway not allowed - '
500gAC                                       + 'Medium Track LP Exists'

     C                   when      $preturn = 'NEGATIVLOC'
     C                   eval      $pmessage = 'Location must be positive'

     C                   when      $preturn = 'NEGATIVLVL'
     C                   eval      $pmessage = 'Level must be positive'

     C                   when      $preturn = 'NEGATIVPSQ'
     C                   eval      $pmessage = 'Picking sequence must be '
     C                                       + 'positive'

     C                   when      $preturn = 'NEGAVLSLT'
     C                   eval      $pmessage = 'Adjustment would make slot '
     C                                       + 'available negative'

     C                   when      $preturn = 'NEGAVLWHS'
     C                   eval      $pmessage = 'Adjustment would make '
     C                                       + 'warehouse available qty '
     C                                       + 'go negative'

     C                   when      $preturn = 'NEGRCVQTY'
     C                   eval      $pmessage = 'Cannot reduce receive qty '
     C                                       + 'for a slot with a '
     C                                       + 'Z or V status'

416nAC                   when      $preturn = 'NEWNOTSNT'
416nAC                   eval      $pmessage = 'New item number must be '
416nAC                                       + 'sent'

416nAC                   when      $preturn = 'NONSTKEXST'
416nAC                   eval      $pmessage = 'Item cannot be changed - '
416nAC                                       + 'Non-Stock qty exists'

     C                   when      $preturn = 'NOTACTIVE'
     C                   eval      $pmessage = 'Slot is not active. Status '
     C                                       + 'is "' + %trim(slstat) + '"'

600kAC                   when      $preturn = 'NOTFIFO'
600kAC                   eval      $pmessage = 'Slot not in FIFO order '
600kAC                                       + '('
600kAC                                       + %Trim(%editc($slwhse:'Z'))
600kAC                                       + '/'
600kAC                                       + %trim($slwhdp)
600kAC                                       + '/'
600kAC                                       + %trim($sldisp)
600kAC                                       + ')'

510dAC                   when      $preturn = 'NOTPARENT'
510dAC                   eval      $pmessage = 'Item '
510dAC                                       + '(type "'
510dAC                                       + %trim(#senttype) + '") '
510dAC                                       + 'is not a Parent for a '
510dAC                                       + 'Repack item.'

510dAC                   when      $preturn = 'NOTREPACK'
510dAC                   eval      $pmessage = 'Item '
510dAC                                       + '(type "'
510dAC                                       + %trim(#senttype) + '") '
510dAC                                       + 'is not a Repack item.'

417cAC                   when      $preturn = 'NOTZROSTAT'
417cAC                   eval      $pmessage = 'Slot not verified - '
417cAC                                       + 'Stat is "'
417cAC                                       + %trim(slstat)
417cAC                                       + '" not "Z" or "V"'

     C                   when      $preturn = 'OPNERRSLT1'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open Slot1 file'

     C                   when      $preturn = 'OPNERRSLT2'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open Slot2 file'

     C                   when      $preturn = 'ORGNOTALW'
     C                   eval      $pmessage = 'Original quantities not '
     C                                       + 'allowed for '
     C                                       + $psubcmd

600dAC                   when      $preturn = 'OSSNOTFND'
600dAC                   eval      $pmessage = 'OSS slot not found with item '
600dAC                                       + %trim($sldisp)
600dAC                                       + '/'
600dAC                                       + %trim($slitem)

600dAC                   when      $preturn = 'OSSNOTZRO'
600dAC                   eval      $pmessage = 'OSS slot cannot have qty '
600dAC                                       + %trim($sldisp)

500aAC                   when      $preturn = 'OVRFNOTAVL'
500aAC                   eval      $pmessage = 'no quantity available '
500aAC                                       + 'in slot '
500aAC                                       + %trim(savedisp)

500aAC                   when      $preturn = 'OVRFNOTFND'
500aAC                   eval      $pmessage = 'item not found in slot '
500aAC                                       + %trim($sldisp)

650tA /free
650tA                    when $preturn = 'SLTNOTRPK';
650tA                    $pmessage = 'slot ' + %trim($sldisp)
650tA                             + ' invalid for on-demand repack';
650tA /end-free

416bAC                   when      $preturn = 'PCKNOTSNT'
416bAC                   eval      $pmessage = 'Pick flag must be sent'

     C                   when      $preturn = 'PCKOVRFLW'
     C                   eval      $pmessage = 'Maximum pick slots ('
     C                                       + %Trim(%editc($imnrpk:'3'))
     C                                       + ') already defined for item '

416bAC                   when      $preturn = 'PSEQNOTSNT'
416bAC                   eval      $pmessage = 'Pick sequence must be sent'

416bAC                   when      $preturn = 'PRTYNOTSNT'
416bAC                   eval      $pmessage = 'Priority must be sent'

     C                   when      $preturn = 'QTYNOTSNT'
     C                   eval      $pmessage = 'Adjustment qty must be '
     C                                       + 'sent for '
     C                                       + $psubcmd

510dAC                   when      $preturn = 'RPKNOTFND'
510dAC                   eval      $pmessage = 'Repack slot not found for '
510dAC                                       + 'item ('
510dAC                                       + %Trim(%editc($slwhse:'Z'))
510dAC                                       + '/'
510dAC                                       + %trim(#slotwhdp)
510dAC                                       + '/'
510dAC                                       + %trim(#slotitem)
510dAC                                       + ')'

650nAC                   when      $preturn = 'RPKSLTITM'
650nAC                   eval      $pmessage = 'Repack slot contains '
650nAC                                       + 'different item ('
650nAC                                       + %trim(slitem)
650nAC                                       + '/'
650nAC                                       + %trim($slitem)
650nAC                                       + ')'

650hAC                   when      $preturn = 'ODRNOTFND'
650hAC                   eval      $pmessage = 'Virtual on-demand slot missing'
650hAC                                       + ' for parent item '
650hAC                                       + %trim(slitem)
650hAC                                       + ' not found'

     C                   when      $preturn = 'SLOT1EXIST'
     C                   eval      $pmessage = 'Slot not added - Already '
     C                                       + 'exists ('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(slaisl)
     C                                       + '/'
     C                                       + %Trim(%editc(slloc:'Z'))
     C                                       + '/'
     C                                       + %Trim(%editc(slrlvl:'Z'))
     C                                       + '/'
     C                                       + %trim(slhand)
     C                                       + ')'

     C                   when      $preturn = 'SLOT2EXIST'
     C                   eval      $pmessage = 'Slot not added - Already '
     C                                       + 'exists ('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'

417jAC                   when      $preturn = 'SLTNOTACTV'
417jAC                   eval      $pmessage = 'Put away not allowed - '
417jAC                                       + 'Slot not at active status'

600dAC                   when      $preturn = 'SLTNOTAV'
600dAC                   eval      $pmessage = 'License slot '
600dAC                                       + 'not at active status'

500nAC                   when      $preturn = 'SLTNOTPICK'
500nAC                   eval      $pmessage = 'Slot must be a Pick slot'

510dAC                   when      $preturn = 'SLTNOTRPK'
510dAC                   eval      $pmessage = 'Slot must be a in Repack area, '
510dAC                                       + 'aisle RPK.'

640tAC                   when      $preturn = 'SLTNOTZRO'
640tAC                   eval      $pmessage = 'Cannot delete DP tran, '
640tAC                                       + 'slot ' + %trimr($sldisp) + ' '
640tAC                                       + 'touched'

     C                   when      $preturn = 'STPNOTSNT'
     C                   eval      $pmessage = 'Section type must be sent'

     C                   when      $preturn = 'STSNOTSNT'
     C                   eval      $pmessage = 'Status code must be sent'

     C                   when      $preturn = 'UPDERRSLT2'
     C                   eval      $pmessage = 'Update error occured doing '
     C                                       + %trim($psubcmd)
     C                                       + ' - ' + f2messageid

     C                   when      $preturn = 'UPDSTKERR'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'update slot with stock '
     C                                       + 'quantity'

500fAC                   when      $preturn = 'VIRTLSLOT'
500fAC                   eval      $pmessage = 'Base slot must be '
500fAC                                       + 'entered. Slot '
500fAC                                       + %trim($sldisp)
500fAC                                       + ' is a Virtual slot.'

     C                   when      $preturn = 'VRTNOTALWH'
     C                   eval      $pmessage = 'VSlot cannot be created - '
     C                                       + 'double handstack ('
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'

640xAC                   when      $preturn = 'VRTNOTALWO'
640xAC                   eval      $pmessage = 'VSlot cannot be created '
640xAC                                       + 'for overflow slot ('
640xAC                                       + %trim(slwhdp)
640xAC                                       + '/'
640xAC                                       + %trim(sldisp)
640xAC                                       + ')'

     C                   when      $preturn = 'VRTNOTALWP'
     C                   eval      $pmessage = 'VSlot cannot be created '
     C                                       + 'for a pick slot ('
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'

     C                   when      $preturn = 'VRTNOTALWU'
     C                   eval      $pmessage = 'VSlot cannot be created - '
     C                                       + 'No openings ('
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'

650zAC                   when      $preturn = 'BFCNALLOW'
650zAC                   eval      $pmessage = 'Status code cannot be '
650zAC                                       + 'changed on BFC '
650zAC                                       + 'Designated Slot'

416uAC                   when      $preturn = 'VNOTALLOW'
416uAC                   eval      $pmessage = 'Status code cannot be '
416uAC                                       + 'changed to "V". '

500nAC                   when      $preturn = 'VRTPCKCRT'
500nAC                   eval      $pmessage = 'VSlot '
500nAC                                       + %trim(slwhdp)
500nAC                                       + '/'
500nAC                                       + %trim(sldisp)
500nAC                                       + ' created'

730bAC                   when      $preturn = 'VRTOFLCRT'
730bAC                   eval      $pmessage = 'OSlot '
730bAC                                       + %trim(slwhdp)
730bAC                                       + '/'
730bAC                                       + %trim(sldisp)
730bAC                                       + ' created'

500fAC                   when      $preturn = 'WARNPICK'
500fAC                   eval      $pmessage = 'Older product in stock. '
500fAC                                       + 'Put in overflow.'

     C                   when      $preturn = 'WHDNOTSNT'
     C                   eval      $pmessage = 'Department must be sent'

     C                   when      $preturn = 'WHSNOTSNT'
     C                   eval      $pmessage = 'Warehouse must be sent'

416dAC                   when      $preturn = 'WRONGITEM'
416dAC                   eval      $pmessage = 'Item '
416dAC                                       + %trim(#slotitem)
416dAC                                       + ' not found in slot '
416dAC                                       + %trim(slwhdp)
416dAC                                       + '/'
416dAC                                       + %trim(sldisp)
416dAC                                       + '/'
416dAC                                       + %trim(slitem)

416jAC                   when      $preturn = 'XDKEXIST'
611dDC**                 eval      $pmessage = 'Xdock slot exists for '
611dMC                   eval      $pmessage = 'XD slot exists for '
416jAC                                       + 'item ('
416jAC                                       + %Trim(%editc($slwhse:'Z'))
416jAC                                       + '/'
416jAC                                       + %trim(#slotwhdp)
416jAC                                       + '/'
416jAC                                       + %trim(#slotitem)
611dAC                                       + ' aisle '
611dAC                                       + %trim($slaisl)
416jAC                                       + ')'

416jAC                   when      $preturn = 'XDKNOTFND'
611dDC**                 eval      $pmessage = 'Xdock slot not found for '
611dMC                   eval      $pmessage = 'XD slot n/f for '
416jAC                                       + 'item ('
416jAC                                       + %Trim(%editc($slwhse:'Z'))
416jAC                                       + '/'
416jAC                                       + %trim(#slotwhdp)
416jAC                                       + '/'
416jAC                                       + %trim(#slotitem)
611dAC                                       + ' aisle '
611dAC                                       + %trim($slaisl)
416jAC                                       + ')'

610dAC                   when      $preturn = 'LCSNOTSNT'
610dAC                   eval      $pmessage = 'License must be sent'

710kAC                   when      $preturn = 'OLCSNOTSNT'
710kAC                   eval      $pmessage = 'Original License '
710kAC                                       + 'must be sent'

CBIcAC                   when      $preturn = 'CBIFITMMFG'
CBIcAC                   eval      $pmessage = 'CLR item is not MFG '
CBIcAC                                       + 'dated Item'

CBIcAC                   when      $preturn = 'CBITITMMFG'
CBIcAC                   eval      $pmessage = 'FRZ item is not MFG '
CBIcAC                                       + 'dated Item'

CBIcAC                   when      $preturn = 'CBINOPICK '
CBIcAC                   eval      $pmessage = 'CLR to FRZ transfer '
CBIcAC                                       + 'not allowed on pick '
CBIcAC                                       + 'slot'

CBIcAC                   when      $preturn = 'CBINOMFGD '
CBIcAC                   eval      $pmessage = 'Original License '
CBIcAC                                       + 'does not have a MFG '
CBIcAC                                       + 'Date'

710jAC                   when      $preturn = 'ITEMCLS1'
710jAC                   eval      $pmessage = %Trim(carcl1)
710jAC                                       + ' Cannot be '
710jAC                                       + %Trim(%editc(carabv:'Z' ))
710jAC                                       + ' levels above '
710jAC                                       + %trim(carcl2)


710jAC                   when      $preturn = 'ITEMCLS2'
710jAC                   eval      $pmessage = %Trim(carcl1)
710jAC                                       + ' Cannot be '
710jAC                                       + %Trim(%editc(carblw:'Z' ))
710jAC                                       + ' levels below '
710jAC                                       + %trim(carcl2)

710jAC                   when      $preturn = 'ITEMCLS3'
710jAC                   eval      $pmessage = %Trim(carcl1)
710jAC                                       + ' Cannot be '
710jAC                                       + %Trim(%editc(carllr:'Z' ))
710jAC                                       + ' locations next to '
710jAC                                       + %trim(carcl2)

     C                   other
     C                   eval      $pmessage = %trim($preturn)
     C                                       + ': Unknown return code'

     C                   endsl

     C                   endsr

     *----------------------------------------------------------------
     *  getitem  Get item info.
     *----------------------------------------------------------------

     C     getitem       begsr

600eMC                   exsr      clr$item

     C                   eval      $itwhse = $slwhse
     C                   eval      $ititem = item#

600eMC                   eval      $dricommand = 'DRIITEM'
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3err and
     C                             check4err = *on
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   goto      endgetitem
     C                   endsl

     C     endgetitem    endsr

     *----------------------------------------------------------------
     *  getitemqty  Get ItemQty record.
     *----------------------------------------------------------------

     C     getitemqty    begsr
     C                   eval      lockeditemqty = *off

600eMC                   exsr      clr$itemqty

     C                   eval      $iqwhseu = *on
     C                   eval      $iqwhse = $slwhse
     C                   eval      $iqitemu = *on
     C                   eval      $iqitem = #slotitem

     C                   if        lock
     C                   eval      $drisubcmd = '*GET&LOCK'
     C                   else
     C                   eval      $drisubcmd = '*GET'
     C                   endif

600eMC                   eval      $dricommand = 'DRIITEMQTY'
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3err and
     C                             check4err = *on
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   goto      endgetitemqty
     C                   endsl

     C                   if        lock
     C                   eval      lockeditemqty = *on
     C                   endif

     C     endgetitemqty endsr

611eA*----------------------------------------------------------------
611eA*  getnextloc  Get next unused location number.
611eA*----------------------------------------------------------------
611eA
611hMC     getnextloc    begsr

     * Open slot11 file

     C                   if        not %open(slot11)
     C                   exsr      openslot11
     C                   if        error
     C                   leavesr
     C                   endif
     C                   endif

     * Position to start looking at location 1.

     C                   eval      $slloc = 1
     C     keysl11loc    setll     slot11

     * Read records for aisle, looking for available location.

     C                   dow       forever = forever

     C     keysl11asl    reade     slot11

     *     Available location found, so leave

     C                   if        %eof(slot11)
     C                             or slloc <> $slloc
     C                   leave
     C                   endif

     *     If out of locations,
     *       Return error that no available location was found.

     C                   if        $slloc = 999
     C                   eval      error = *on
     C                   eval      $preturn  = 'NOLOCAVAIL'
     C                   eval      $pmessage = 'No available location '
     C                                       + 'found in aisle '
     C                                       + $slaisl
     C                   eval      $slloc = 0
     C                   leave
     C                   endif

     *     Otherwise, skip to next location and keep looking

     C                   eval      $slloc += 1
     C     keysl11loc    setll     slot11

     C                   enddo

     C                   endsr

611eA*----------------------------------------------------------------
611eA*  getnextlvl  Get next unused level within the aisle/loc.
611eA*----------------------------------------------------------------
611eA
611eAC     getnextlvl    begsr

     * Open slot11 file

     C                   if        not %open(slot11)
     C                   exsr      openslot11
     C                   if        error
     C                   leavesr
     C                   endif
     C                   endif

     * Position to start looking at level 1.

     C                   eval      $slrlvl = 1
     C     keysl11lvl    setll     slot11

     * Read records for aisle/location, looking for available level.

     C                   dow       forever = forever

     C     keysl11loc    reade     slot11

     *     Available level found, so leave

     C                   if        %eof(slot11)
     C                             or slrlvl <> $slrlvl
     C                   leave
     C                   endif

     *     If out of levels,
     *       Return error that no available level was found.

     C                   if        $slrlvl = 99
     C                   eval      error = *on
     C                   eval      $preturn  = 'NOLVLAVAIL'
     C                   eval      $pmessage = 'No available level '
     C                                       + 'found in aisle/loc '
     C                                       + $slaisl + '/' + %char($slloc)
     C                   eval      $slrlvl = 0
     C                   leave
     C                   endif

     *     Otherwise, skip to next level and keep looking

     C                   eval      $slrlvl += 1
     C     keysl11lvl    setll     slot11

     C                   enddo

     C                   endsr

500aA*----------------------------------------------------------------
500aA*  getovrfav  Get overflow slot w/available qty for physical slot.
500aA*----------------------------------------------------------------
500aA
500aAC     getovrfav     begsr
600tAC                   eval      currRoutine = 'getovrfav'
600tAC                   exsr      phpgmV1V2V3s

     C* Make sure appropriate file is open.

     C                   exsr      openslot3
     C                   if        error
     C                   goto      endgetovrfav
     C                   endif

     C* Set file pointer.

500bAC                   if        $psubcmd = '*GETITEMAV'
500bAC     keysl3p1      setll     slot3
500bAC                   else
     C                   eval      $slpick = 'N'
     C     keysl3p2      setll     slot3
500bAC                   endif

     C* Create read loop.

     C                   eval      found = *off
     C                   eval      noneavail = *off

     C                   dow       forever = forever

     C* Get record.

500bAC                   if        $psubcmd = '*GETITEMAV'
500bAC     keysl3p1      reade(n)  slot3
500bAC                   else
     C     keysl3p2      reade(n)  slot3
500bAC                   endif

     C* Check for eof.

     C                   if        %eof
     C                   eval      $preturn = 'EOF'
     C                   goto      endgetovrfav
     C                   endif

     C* Look for a slot within the physical slot that was sent.

     C                   if        slwhdp <> $slwhdp or
     C                             slaisl <> $slaisl or
     C                             slloc  <> $slloc  or
     C                             slrlvl <> $slrlvl
     C                   iter
     C                   endif

     C* Calculate quantities.

     C                   exsr      calcqtys

     C* See if we need to loop around and try again.

     C                   if        slavl1 <= 0             and
     C                             slavl2 <= 0             and
     C                             slavl3 <= 0
     C                   eval      noneavail = *on
     C                   eval      savedisp  = sldisp
     C                   iter
     C                   endif

     C* Move record fields into data structure.

     C                   eval      found = *on
     C                   exsr      slot2ds

     C                   leave
     C                   enddo

     C                   select

     C* If record was found, then there is nothing else to do.

     C                   when      found

     C* If a record was found but nothing was available,
     C*   Then send back an error message.

     C                   when      noneavail
     C                   eval      error = *on
     C                   eval      $preturn = 'OVRFNOTAVL'
     C                   exsr      getmsg

     C* Otherwise, no record was found, so send back an error message.

     C                   other
     C                   eval      error = *on
     C                   eval      $preturn = 'OVRFNOTFND'
     C                   exsr      getmsg

     C                   endsl

     C     endgetovrfav  endsr

     *----------------------------------------------------------------
     *  getslot1  Get slot info from file SLOT1.
     *----------------------------------------------------------------

     C     getslot1      begsr
     C                   eval      lockedslot1 = *off

     C* Open slot1 file.

     C                   if        not %open(slot1)
     C                   exsr      openslot1
     C                   if        error
     C                   goto      endgetslot1
     C                   endif
     C                   endif

     C* Get slot1 record

     C                   if        lock
     C     keysl1        chain     slot1
     C                   else
     C     keysl1        chain(n)  slot1
     C                   endif

     C                   if        not %found
     C                   eval      error = *on
     C                   eval      $preturn = 'INVLDSLOT'
     C                   exsr      getmsg
     C                   goto      endgetslot1
     C                   endif

     C                   if        lock
     C                   eval      lockedslot1 = *on
     C                   endif

     C                   exsr      calcqtys

     C     endgetslot1   endsr

     *----------------------------------------------------------------
     *  getslot2  Get slot info from file SLOT2.
     *----------------------------------------------------------------

     C     getslot2      begsr
     C                   eval      lockedslot2 = *off

     C* Open slot2 file.

     C                   if        not %open(slot2)
     C                   exsr      openslot2
     C                   if        error
     C                   goto      endgetslot2
     C                   endif
     C                   endif


     C* Get slot2 record

     C                   if        lock
     C     keysl2        chain     slot2
     C                   else
     C     keysl2        chain(n)  slot2
     C                   endif

     C                   if        not %found
     C                   eval      error = *on
     C                   eval      $preturn = 'INVLDSLOT'
     C                   exsr      getmsg
     C                   goto      endgetslot2
     C                   endif

     C                   if        lock
     C                   eval      lockedslot2 = *on
     C                   endif

     C                   exsr      calcqtys

     C     endgetslot2   endsr

600dA*----------------------------------------------------------------
600dA*  getslot2USR  Define defaults for RCV/STG/OSS/USRIN commands.
700sA*               Add RTN.
730eA*               Add RWO.
600dA*               Re: These do not have base slots.
600dA*----------------------------------------------------------------
600dA
600dAC     getslot2USR   begsr
     C                   eval      lockedslot2 = *off

     C                   clear                   slrec2

     C                   eval      slwhse = $slwhse
     C                   eval      slwhdp = $slwhdp

     C                   select

     *      For RCVIN,
     *        $SLDISP is sent in and should contain the receiving area.
     *        We will start with level 1 looking for a new slot.

     C                   when      $psubcmd = '*RCVIN'
     C                             or $psubcmd = '*USR2RCV'
     C                   eval      slaisl = aisleRCV
650rDC**                 eval      slloc  = 1
     C                   eval      slrlvl = 1
     C                   eval      sldisp = %trim(aisleRCV)
     C                                     + %trim($saToArea)
650rA
650rAC                   call      'GETBFCLOC'
650rAC                   parm      $slwhse       gblwhse           3 0
650rAC                   parm                    $slwhdp
650rAC                   parm                    slaisl
650rAC                   parm                    sldisp
650rAC                   parm      0             gblLoc            3 0
650rAC                   eval      slloc = gblLoc

720 A*      For RPAIN,
720 A*        $SLDISP is sent in and should contain the receiving area.
720 A*        We will start with level 1 looking for a new slot.

720 AC                   when      $psubcmd = '*RPAIN'
720 AC                             or $psubcmd = '*USR2RPA'
720 AC                             or $psubcmd = '*CRTRPA'
720 AC                   eval      slaisl = aisleRPA
700sAC                   eval      slrlvl = 1
720 AC                   eval      sldisp = %trim(aisleRPA)
720 AC                                     + %trim($saToArea)
720 A
720 AC                   call      'GETBFCLOC'
720 AC                   parm      $slwhse       gblwhse           3 0
720 AC                   parm                    $slwhdp
720 AC                   parm                    slaisl
720 AC                   parm                    sldisp
720 AC                   parm      0             gblLoc            3 0
720 AC                   eval      slloc = gblLoc

700sA*      For RTNIN,
700sA*        $SLDISP is sent in and should contain the receiving area.
700sA*        We will start with level 1 looking for a new slot.

700sAC                   when      $psubcmd = '*RTNIN'
700sAC                             or $psubcmd = '*USR2RTNO'
700sAC                   eval      slaisl = aisleRTN
700sAC                   eval      slrlvl = 1
700sAC                   eval      sldisp = %trim(aisleRTN)
700sAC                                     + %trim($saToArea)

700sAC                   call      'GETBFCLOC'
700sAC                   parm      $slwhse       gblwhse           3 0
700sAC                   parm                    $slwhdp
700sAC                   parm                    slaisl
700sAC                   parm                    sldisp
700sAC                   parm      0             gblLoc            3 0
700sAC                   eval      slloc = gblLoc

730eA*      For RWOIN,
730eA*        $SLDISP is sent in and should contain the receiving area.
730eA*        We will start with level 1 looking for a new slot.

730eAC                   when      $psubcmd = '*RWOIN'
730eAC                             or $psubcmd = '*USR2RWO'
730eAC                   eval      slaisl = aisleRWO
730eAC                   eval      slrlvl = 1
730eAC                   eval      sldisp = %trim(aisleRWO)
730eAC                                     + %trim($saToArea)

730eAC                   call      'GETBFCLOC'
730eAC                   parm      $slwhse       gblwhse           3 0
730eAC                   parm                    $slwhdp
730eAC                   parm                    slaisl
730eAC                   parm                    sldisp
730eAC                   parm      0             gblLoc            3 0
730eAC                   eval      slloc = gblLoc

     *      For STGIN,
     *        $SLDISP is sent in and should contain the stage location code.
     *        We will start with level 1 looking for a new slot.

     C                   when      $psubcmd = '*STGIN'
     C                             or $psubcmd = '*USR2STG'
     C                   eval      slaisl = aisleSTG
640aDC**                 eval      slloc  = 1
     C                   eval      slrlvl = 1
     C                   eval      sldisp = %trim(aisleSTG)
     C                                     + %trim($saToArea)
640aA
640aAC                   call      'GETBFCLOC'
640aAC                   parm      $slwhse       gblwhse           3 0
640aAC                   parm                    $slwhdp
640aAC                   parm                    slaisl
640aAC                   parm                    sldisp
640aAC                   parm      0             gblLoc            3 0
640aAC                   eval      slloc = gblLoc

     *      For OSSIN,
     *        $SLDISP is sent in and should contain the outside storage loc cod
     *        We will start with level 1 looking for a new slot.

     C                   when      $psubcmd = '*OSSIN'
     C                             or $psubcmd = '*USR2OSS'
     C                   eval      slaisl = aisleOSS
650oA * convert alpha to numeric for location
650oAc                   eval      OssCode = %trim($saToArea)
650oDC*                  eval      slloc  = 1
650oMC                   eval      slloc  = sllocValue
     C                   eval      slrlvl = 1
     C                   eval      sldisp = %trim(aisleOSS)
     C                                     + %trim($saToArea)

611eA*      For PREIN,
611eA*        The aisle, loc, and level sent in will be used instead of
611eA*        being hard coded.
611eA
611eAC                   when      $psubcmd = '*PREIN'
611eAC                             or $psubcmd = '*CRTPRE'
700dAC                             or $psubcmd = '*AMPIN'
700dAC                             or $psubcmd = '*CRTAMP'
611eA
611hM*        If loc is 0, look for next unused loc number
611eA*        and set level to 1.
611eA
611hMC                   if        $slloc = 0
611eAC                   exsr      getnextloc
611hAC                   if        error
611hAC                   leavesr
611hAC                   endif
611eAC                   eval      $slrlvl = 1
611eAC                   endif
611eA
611hM*        If level is 0, look for next unused
611eA*        level within the aisle/loc.
611eA
611hMC                   if        $slrlvl = 0
611eAC                   exsr      getnextlvl
611hAC                   if        error
611hAC                   leavesr
611hAC                   endif
611eAC                   endif
611eA
611eAC                   eval      slaisl = $slaisl
611eAC                   eval      slloc  = $slloc
611eAC                   eval      slrlvl = $slrlvl
611eAC                   eval      sldisp = %trim($slaisl)
611eAC                                     + '-'
611eAC                                     + %trimL(%editc($slloc:'X'))

     *      For USRIN,

     C                   when      $psubcmd = '*USRIN'
     C                             or $psubcmd = '*TFR2USR'
610sAC                             or $psubcmd = '*TFR2USRR'
640dAC                             or $psubcmd = '*TFR2USRN'
     C                   eval      slaisl = aisleUSR
     C                   eval      slloc  = %dec(%subst(emp#a:1:3):3:0)
     C                   eval      slrlvl = %dec(%subst(emp#a:4:2):2:0)
     C                   eval      sldisp = %trim(aisleUSR)
     C                                    + emp#a + '-'

     C                   endsl

     C                   eval      slhand = ' '
600sDC**                 eval      slstyp = $slstyp
600sMC                   eval      slstyp = 'F'
600sAC                   eval      slsdef = 'BF'
720 Ac                   if        $psubcmd = '*RPAIN'
720 Ac                              or $psubcmd = '*USR2RPA'
720 Ac                              or $psubcmd = '*CRTRPA'
720 Ac                   eval      sldesg = *blanks
720 Ac                   else
600sAC                   eval      sldesg = 'BFC'
720 Ac                   endif
600zAC                   if        $slstat = ' '
600zAC                   eval      slstat = 'A'
600zAC                   else
     C                   eval      slstat = $slstat
600zAC                   endif
     C                   eval      slpick = 'N'
611hAC                   eval      slpseq = slloc

     C                   exsr      calcqtys

     C                   endsr

500gA*----------------------------------------------------------------
500gA*  getslotdef   Get slot definition information.
500gA*----------------------------------------------------------------
500gA
500gAC     getslotdef    begsr

600eMC                   exsr      clr$slotdef

     C                   eval      $sdwhseu = *on
     C                   eval      $sdwhse = slwhse
     C                   eval      $sdcodeu = *on
     C                   eval      $sdcode  = slsdef

600eMC                   eval      $dricommand = 'DRISLOTDEF'
600eMC                   eval      $drisubcmd = '%GET'
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3callerr
     C                   eval      error = *on
     C                   eval      $sdpos = 1
     C                   when      main3rtnerr
     C                   eval      $sdpos = 1
     C                   endsl

     C     endgetslotdef endsr

610rA*----------------------------------------------------------------
610rA*  getfrmsltlic  Get license info for 'from' slot.
610rA*----------------------------------------------------------------
610rA
610rAC     getfrmsltlic  begsr
     C                   eval      error = *off

     C                   exsr      clr$license

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = frm$Slot.$slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = frm$Slot.$slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = frm$Slot.$sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = frm$slot.$sldesg
     C                   eval      $liToItemU = *on
     C                   eval      $liToItem = frm$Slot.$slitem
     C                   eval      $liToSItemU = *on
     C                   eval      $liToSItem = frm$Slot.$slitem

     C                   eval      $dricommand = 'DRILICENSE'
     C                   eval      $drisubcmd  = '%GETSLTLIC'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     C                   select
     C                   when      main3callerr and check4err
     C                   eval      error = *on
     C                   when      main3rtnerr
     C                   eval      $liToLcns = '*NONE'
     C                   eval      $liToPos = 0
     C                   endsl

     C                   endsr

500gA*----------------------------------------------------------------
500gA*  getslotlic   Get license info for slot.
500gA*----------------------------------------------------------------
500gA
500gAC     getslotlic    begsr

600fAC                   exsr      clr$license
600fA
600fAC                   eval      $liToWhseu = *on
600fAC                   eval      $liToWhse = $slwhse
600fAC                   eval      $liToWhdpU = *on
600fAC                   eval      $liToWhdp = $slwhdp
600fAC                   eval      $liToDispU = *on
600lMC                   eval      $liToDisp = tmpdisp
600fAC                   eval      $liToItemU = *on
600lMC                   eval      $liToItem = tmpitem
600fAC                   eval      $liToSItemU = *on
600lMC                   eval      $liToSItem = tmpitem
600fA
600fAC                   eval      $dricommand = 'DRILICENSE'
600fAC                   eval      $drisubcmd  = '%GETSLTLIC'
600fAC                   eval      $drisys2upd = 'D'
600fAC                   exsr      zzzdrimain3
600fA
600fAC                   select
600fAC                   when      main3callerr and check4err
600fAC                   eval      error = *on
600fAC                   when      main3rtnerr
600fAC                   eval      $liToLcns = '*NONE'
600fAC                   eval      $liToPos = 0
600fAC                   endsl

600fDC**                 eval      savever# = $lrver#
600fDC**                 clear                   $lichist
600fDC**                 eval      $lrver# = savever#

     C***                eval      $lremp# = $pempl#
600fDC**                 eval      $lruser = #user
600fDC**                 eval      $lrpgm  = $pprogram
600fDC**                 eval      $lrjob  = #job
600fDC**                 eval      $lrjobn = #jobnbr

600fDC**                 eval      $lrwhseu = *on
600fDC**                 eval      $lrwhse = slwhse
600fDC**                 eval      $lrtwhdu = *on
600fDC**                 eval      $lrtwhd  = slwhdp
600fDC**                 eval      $lrtaslu = *on
600fDC**                 eval      $lrtasl  = slaisl
600fDC**                 eval      $lrtlocu = *on
600fDC**                 eval      $lrtloc  = slloc
600fDC**                 eval      $lrtlvlu = *on
600fDC**                 eval      $lrtlvl  = slrlvl
600fDC**                 eval      $lrthndu = *on
600fDC**                 eval      $lrthnd  = slhand

600fDC**                 eval      drilichist = *on
600fDC**                 call(e)   'DRILICHIST'
600fDC**                 parm      '%GETLIC#'    $drisubcmd
600fDC**                 parm      $pprogram     $driprogram
600fDC**                 parm      ' '           $drireturn
600fDC**                 parm      ' '           $drimessage
600fDC**   $lichist      parm      $lichist      $dridata

600fDC**                 select
600fDC**                 when      %error and
600fDC**                           check4err = *on
600fDC**                 eval      error = *on
600fDC**                 eval      $preturn  = 'CALLERROR'
600fDC**                 eval      $pmessage = 'Error occured on call to '
600fDC**                                     + 'DRILICHIST'
600fDC**                                     + '/' + %trim($drisubcmd)
600fDC**                                     + ' from ' + #prog
600fDC**                 when      $drireturn <> '*OK'
600fDC**                 eval      $lrlcns = ' '
600fDC**                 eval      $lrtslp = 0
600fDC**                 endsl

     C     endgetslotlic endsr

710fA*----------------------------------------------------------------
710fA*  chkslotlic   Get license info for production slot - same dates.
710fA*----------------------------------------------------------------
710fA
710fAC     chkslotlic    begsr

710fAC                   exsr      clr$license
710fA
710fAC                   eval      $liToWhseu = *on
710fAC                   eval      $liToWhse = $slwhse
710fAC                   eval      $liToWhdpU = *on
710fAC                   eval      $liToWhdp = $slwhdp
710fAC                   eval      $liToDispU = *on
710fAC                   eval      $liToDisp = $sldisp
710fAC                   eval      $liToItemU = *on
710fAC                   eval      $liToItem = $slitem
710fAC                   eval      $liToSItemU = *on
710fAC                   eval      $liToSItem = $slitem
710fAC                   eval      $liToExpdU = *on
710fAC                   eval      $liToExpd = in$Slot.$slexpd
710fAC                   eval      $liToEntdU = *on
730dDC*                  eval      $liToEntd = to$Slot.$slentd
730dMC                   eval      $liToEntd = in$Slot.$slentd
710fA
710fAC                   eval      $dricommand = 'DRILICENSE'
710fAC                   eval      $drisubcmd  = '%CHK4PRLIC'
710fAC                   eval      $drisys2upd = 'D'
710fAC                   exsr      zzzdrimain3
710fA
710fAC                   select
710fAC                   when      main3callerr and check4err
710fAC                   eval      error = *on
710fAC                   when      main3rtnerr
710fAC                   eval      savePRLic = '*NONE'
710fAc                   other
710fAc                   eval      savePRlic = $litolcns
710fAC                   endsl

710fAC     endchkslotlic endsr

601aA*----------------------------------------------------------------
601aA*  getSltFifoOpt   Get slot FIFO info options
601aA*                  Default to use First non-expired FIFO
601aA*----------------------------------------------------------------
601aA
601aAC     getSltFifoOpt begsr
     C                   eval      currRoutine = 'getsltfifoopt'
     C                   exsr      phpgmV1V2V3s

     C                   eval      kywhse = $slwhse
     C                   eval      opcode = '*SLTFIFO'
     C     keyop         chain     options
     C                   if        %found
     C                   eval      opdat5 = opdata
     C                   else
     C                   eval      oppff  = 'N'
     C                   eval      oppfnf = 'Y'
     C                   eval      opplf  = 'N'
     C                   endif

     C                   endsr

500gA*----------------------------------------------------------------
500gA*  gettrack  Get tracking options.
500gA*----------------------------------------------------------------
500gA
500gAC     gettrack      begsr
600tAC                   eval      currRoutine = 'gettrack'
600tAC                   exsr      phpgmV1V2V3s

     C                   eval      $lcmd = *blanks
     C                   eval      $lprg = #pgm
     C                   eval      $lwhse = $slwhse
600dDC**                 eval      $ltrackitem = $slitem
600dMC                   eval      $ltrackitem = #senttrack

     C                   call      'GETTRACK'
     C                   parm                    $lparm

     C                   eval      trackitem   = $ltrackitem
     C                   eval      trackpos    = $ltrackpos
     C                   eval      trackposmrg = $lposmrg
     C                   eval      trackposrtn = $lposrtn
     C                   eval      trackpsplit  = $lpsplit
     C                   eval      tracktsplit  = $ltsplit

     C                   endsr

600cA*----------------------------------------------------------------
600cA*  getvirtualopt   Get *VIRTUAL options
600cA*----------------------------------------------------------------
600cA
600cAC     getvirtualopt begsr
600tAC                   eval      currRoutine = 'getvirtualopt'
600tAC                   exsr      phpgmV1V2V3s

     *   Get Virtual slot options

     C                   eval      kywhse = $slwhse
     C                   eval      opcode = '*VIRTUAL'
     C     keyop         chain     options
     C                   if        not %found
     C                   eval      opvpck = 'N'
     C                   eval      opvall = 'N'
     C                   eval      opvslt = 'Y'
     C                   eval      opvexp = 'N'
     C                   eval      opvend = 'N'
     C                   eval      opvsam = 'N'
     C                   eval      opvedf = 'N'
640xAC                   eval      opvovf = 'Y'
     C                   else
     C                   eval      opdat4 = opdata
     C                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  getvslot  Get VSLOT record.
     *----------------------------------------------------------------

     C     getvslot      begsr
600tAC                   eval      currRoutine = 'getvslot'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      lockedvslot = *off

     C* Open vslot file.

     C                   if        not %open(vslot)
     C                   exsr      openvslot
     C                   if        error
     C                   goto      endgetvslot
     C                   endif
     C                   endif

     C* Get vslot record

     C                   if        lock
     C     keyvs         chain     vslot
     C                   else
     C     keyvs         chain(n)  vslot
     C                   endif

     C                   if        not %found
     C                   eval      error = *on
416rAC                   if        check4err = *on
     C                   eval      $preturn = 'INVLDVSLOT'
     C                   exsr      getmsg
416rAC                   endif
     C                   goto      endgetvslot
     C                   endif

     C                   if        lock
     C                   eval      lockedvslot = *on
     C                   endif

416rAC     endgetvslot   tag
416rAC                   eval      check4err = *off
416rMC                   endsr

510dA*----------------------------------------------------------------
510dA*  getrepack  Get repack slot for item.
510dA*----------------------------------------------------------------
510jA
510jAC     getrepack     begsr
600tAC                   eval      currRoutine = 'getrepack'
600tAC                   exsr      phpgmV1V2V3s

     C* Open slot3 file.

     C                   if        not %open(slot3)
     C                   exsr      openslot3
     C                   if        error
     C                   goto      endgetrpk
     C                   endif
     C                   endif

     C* Get repack slot for item.

     C                   eval      kystat = 'RP'
     C     keysl3x       setll     slot3
     C                   dow       forever = forever
     C     keysl3x       reade(n)  slot3

     C                   if        %eof
     C                   eval      error = *on
     C                   eval      $preturn = 'RPKNOTFND'
     C                   exsr      getmsg
     C                   goto      endgetrpk
     C                   endif

650fMC*                  if        slaisl <> 'RPK' or
650fMC                   if        (slaisl <> 'RPK' and
650fAc                                sldisp <> $prslot) or
     C                             slwhdp <> #slotwhdp
     C                   iter
     C                   endif

     C                   leave
     C                   enddo

     C                   exsr      calcqtys

     C     endgetrpk     endsr

650hA*----------------------------------------------------------------
650hA*  getodrrpk  Get repack slot for ODR Item as parent
650hA*----------------------------------------------------------------
650hA
650hAC     getodrrpk     begsr
650hAC                   eval      currRoutine = 'getodrrpk'
650hAC                   exsr      phpgmV1V2V3s

     C* Open slot3 file.

650hAC                   if        not %open(slot3)
650hAC                   exsr      openslot3
650hAC                   if        error
650hAC                   goto      endodrrpk
650hAC                   endif
650hAC                   endif

     C* Get repack slot for item.

650hAC                   eval      kystat = 'A'
650hAC     keyss3x       setll     slot3
650hAC                   dow       forever = forever
650hAC     keyss3x       reade(n)  slot3

650hAC                   if        %eof
650hAC                   eval      error = *on
650hAC                   eval      $preturn = 'ODRNOTFND'
650hAC                   exsr      getmsg
650hAC                   goto      endodrrpk
650hAC                   endif

650hAC                   if        slpick <> 'Y'
650hAC                             or slwhdp <> #sentwhdp
650hAC                   iter
650hAC                   endif

650hAC                   leave
650hAC                   enddo

650hAC                   exsr      calcqtys

650hAC     endodrrpk     endsr

416jA*----------------------------------------------------------------
416jA*  getxdock  Get crossdock slot for item.
416jA*----------------------------------------------------------------
416jA
416jAC     getxdock      begsr
600tAC                   eval      currRoutine = 'getxdock'
600tAC                   exsr      phpgmV1V2V3s

     C* Open slot3 file.

     C                   if        not %open(slot3)
     C                   exsr      openslot3
     C                   if        error
     C                   goto      endgetxdk
     C                   endif
     C                   endif

     C* Get crossdock slot for item.

     C                   eval      kystat = 'XD'
     C     keysl3x       setll     slot3
     C                   dow       forever = forever
     C     keysl3x       reade(n)  slot3

     C                   if        %eof
     C                   eval      error = *on
     C                   eval      $preturn = 'XDKNOTFND'
     C                   exsr      getmsg
     C                   goto      endgetxdk
     C                   endif

611dDC**                 if        slaisl <> 'XDK' or
611dMC                   if        slaisl <> $slaisl or
     C                             slwhdp <> #slotwhdp
     C                   iter
     C                   endif

     C                   leave
     C                   enddo

     C                   exsr      calcqtys

     C     endgetxdk     endsr

501fA*----------------------------------------------------------------
501fA*  look4overflow   Look for item in overflow slot.
501fA*----------------------------------------------------------------
501fA
501fAC     look4overflow begsr
600tAC                   eval      currRoutine = 'look4overflow'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      overflowfound = *off

     *  Make sure appropriate file is open.

700gMC                   exsr      openslot13
700gDC*                  exsr      openslot3
     C                   if        error
     C                   goto      endlook4ovrf
     C                   endif

     *  See if an overflow slot exists.
600dA*    Ignore special slots like RCV and USR.

650iA*  if item is an on-demand item then look at that item only
650iA*  and not the base item
650iA /free
650iA     chain ($itwhse:$sacitem) kititem;
650iA     if %found and kirptp='2';
650iA        $slitem = $sacitem;
650iA     else;
650iA        $slitem = #slotitem;
650iA     endif;
650iA /end-free
500qDC**                 eval      $slitem = $saitem
650iDC**                 eval      $slitem = #slotitem
     C                   eval      $slstat = 'A'
     C                   eval      $slpick = 'N'
700gMC     keysl3p2x     setgt     slot13
700gDC*    keysl3p2      setll     slot3
600dAC                   dow       forever = forever
700gMC     keysl3p2      reade(n)  slot13
700gDC*    keysl3p2      reade(n)  slot3
600dDC**                 if        not %eof
700gMC                   if        %eof(slot13)
700gDC*                  if        %eof(slot3)
600dAC                   leave
600dAC                   endif
600dAC                   if        slaisl = aisleRCV
700sAC                             or slaisl = aisleRTN
730eAC                             or slaisl = aisleRWO
720 AC                             or slaisl = aisleRPA
600dAC                             or slaisl = aisleSTG
600dAC                             or slaisl = aisleOSS
600dAC                             or slaisl = aisleUSR
SFGaAC                             or (client = sgc and slaisl = ' KA')
SFGaAC                             or (client = sgc and slaisl = ' WI')
650gAc                   if        ovrFLWODR
650gAC                   eval      overflowfound = *on
650gAc                   else
600dAC                   iter
650gAc                   endif
600dAC                   endif
     C                   eval      overflowfound = *on
600dAC                   leave
600dDC**                 endif
600dAC                   enddo

     C     endlook4ovrf  endsr

600lA*----------------------------------------------------------------
600lA*  look4pull   Look for item/lp still in "Pulled" slot
600lA*----------------------------------------------------------------

     C     look4pull     begsr
600tAC                   eval      currRoutine = 'look4pull'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      pullFound = *off

     *  If pulled base is not same as TO base, get out.
     *    The pulled base is sent to us because if the pulled
     *    slot was previously deleted, we would not be able to
     *    identify its base slot.

     C                   if        $saPullBase <> baseDisp
     C                   leavesr
     C                   endif

     *  If the slot doesn't exist anymore, get out.
     *    It must have been deleted because the entire qty was
     *    pulled and it was a Virtual slot. Therefore, we will
     *    let a new virtual slot be created.

     C                   if        not pullExists
     C                   leavesr
     C                   endif

     *  If slot is now at 'V' status,
     *    Go ahead and put the item back into it.

     C                   if        pullStat = 'V'
     C                   eval      pullFound = *on
     C                   leavesr
     C                   endif

     *  If slot does not contain the item, get out.
     *    We will let a new virtual slot be created.

600zDC**                 if        slitem <> pullItem
600zMC                   if        $saitem <> pullItem
     C                   leavesr
     C                   endif

     *  If slot is at 'Z' status,
     *    Go ahead and put the item back into it.

     C                   if        pullStat = 'Z'
     C                   eval      pullFound = *on
     C                   leavesr
     C                   endif

     *  For low tracking, we have a match.
     *    Go ahead and put the item back into it.

     C                   if        trackitem = tLow
     C                   eval      pullFound = *on
     C                   leavesr
     C                   endif

     *  If pull license and slot license match,
     *    Go ahead and put the item back into it.

     C                   eval      check4err = *on
601iDC**                 eval      tmpdisp = sldisp
601iDC**                 eval      tmpitem = slitem
601iMC                   eval      tmpdisp = $saPullDisp
601iMC                   eval      tmpitem = $saItem
     C                   exsr      getslotlic
     C                   if        not error
     C                             and $saPullLcns = $liToLcns
     C                   eval      pullFound = *on
     C                   leavesr
     C                   endif
710hA*  For changes to allowing an existing license to be transferred
     *    to offsite storage, we will have created a oss* slot, but
     *    we will not thave created a licactive record for this slot.
     *    So we will get a *NONE returned getslotlic.
     C                   if        not error
     C                             and $liToLcns = '*NONE'
     C                             and %subst($saPullDisp:1:3) = 'OSS'
     C                   eval      pullFound = *on
     C                   leavesr
     C                   endif
     C                   eval      error = *off

     *  We couldn't find a match,
     *    Therefore, we will let a new virtual slot be created.

     C                   endsr

     *----------------------------------------------------------------
     *  look4slot   Look for item in existing slot
     *
     *    Routine was called ZZCKSL in older programs.
     *
     *----------------------------------------------------------------

     C     look4slot     begsr
600tAC                   eval      currRoutine = 'look4slot'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      found = *off

     C                   eval      samepos  = *off
     C                   eval      samewhse = 0
     C                   eval      samewhdp = ' '
     C                   eval      samedisp = ' '

600lDC**                 eval      diffposdiffdte = *off
600lDC**                 eval      diffposdifflot = *off
600lDC**                 eval      diffpossamedte = *off
600lDC**                 eval      diffpossamelot = *off
600lDC**                 eval      sameposdiffdte = *off
600lDC**                 eval      sameposdifflot = *off
600lDC**                 eval      samepossamedte = *off
600lDC**                 eval      samepossamelot = *off
600lA
600lA*  See if we should put qty back into Pull slot.
600lA
600lAC                   if        $saPullDispU
600lAC                   exsr      look4pull
600lAC                   if        pullFound
     C                   eval      found = *on
600lAC                   eval      samepos = *on
600lAC                   eval      samewhse = $slwhse
600uDC**                 eval      samewhdp = $slwhdp
600uMC                   eval      samewhdp = $saPullWhdp
600lAC                   eval      samedisp = $saPullDisp
600lAC                   endif
600lAC                   endif
640xA
640xA*  Get *VIRTUAL options.
640xA
640xAC                   exsr      getvirtualopt
600lA
600lA*  Do not continue to look for an existing slot if ...
600lA*    We are working with and Overflow slot and ...
600lA*      We are dealing with a Medium or High tracked item.
600lA*      Or the client always wants to create a new virtual.
650bA
650bA*  We want to look for an existing slot when desig is *MERG.
650kA*  We want to look for an existing slot when aisle is XDK.
600lA
700fAC                   if        slpick = 'N'
700fAC                             and $saaction = 'TFR'
700fAC                             and slavl1 < 0
700fAC                   else
600lAC                   if        slpick = 'N'
610tAC                             and slstat <> 'RP'
650qAC                             and $slstat <> 'PR'
730gAC                             and sldesg <> '*DROP'
650bAC                             and sldesg <> '*MERG'
650kAC                             and slaisl <> 'XDK'
650wAC                             and slaisl <> 'RPK'
FPRjAC                             or client = FoodPro
FPRjAC                             and slpick = 'N'
FPRjAC                             and slstat <> 'RP'
FPRjAC                             and sldesg <> '*MERG'
FPRjAC                             and slaisl <> 'XDK'
FPRjAC                             and slaisl <> 'RPK'
FPRjAC                             and slaisl <> 'ADJ'
600lAC                   if        trackitem = tHigh
600lAC                             or trackitem = tMedium
720cAC                             or trackitem = tUCI
600lAC                             or opvall = 'Y'
600lAC                   leavesr
600lAC                   endif
600lAC                   endif
700fAC                   endif

     *  Make sure appropriate file is open.

417aAC                   exsr      openvslot2
417aAC                   if        error
417aAC                   goto      endlook4slot
417aaC                   endif

     *  See if item is in base slot (retreived during verify process).

     C                   if        slitem = #slotitem and
     C                             slstat <> 'V' and slstat <> 'Z'
     C                   eval      found = *on
500gAC                   exsr      checkslotpos
     C                   endif

     *  See if item is in virtual slot.

500gMC     keyvs2l4      setll     vslot2
     C                   dow       forever = forever

500gMC     keyvs2l4      reade     vslot2
     C                   if        %eof
     C                   leave
     C                   endif

     C                   eval      lock = *off
     C                   eval      kywhse = vswhse
     C                   eval      kywhdp = vswhdp
     C                   eval      kydisp = vsdisp
     C                   exsr      getslot2

     C                   if        error
417qAC                   eval      error = *off
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   iter
     C                   endif

     C                   if        slitem <> #slotitem or
     C                             slstat = 'V' or  slstat = 'Z'
730dAc                             or $psubcmd = '*CRTPROD' and
730dAc                             in$slot.$slexpd <> slexpd
     C                   iter
     C                   endif

     C                   eval      found = *on
500gAC                   exsr      checkslotpos
640gAC                   leave

     C                   enddo

640hAC                   if        error = *off
640hAC                             and $psubcmd = '*VERIFYPUT'
640hAC                   eval      $slpick = slpick
640hAC                   endif

     C     endlook4slot  endsr

416bA*----------------------------------------------------------------
416bA*  nextprev  Get next/previous slot record.
416bA*----------------------------------------------------------------
416bA
416bAC     nextprev      begsr
600tAC                   eval      currRoutine = 'nextprev'
600tAC                   exsr      phpgmV1V2V3s

     C* Make sure appropriate file is open.

     C                   select

     C                   when      $psubcmd = '*NXTSLOTI' or
     C                             $psubcmd = '*PRVSLOTI'
     C                   exsr      openslot1
     C                   if        error
     C                   goto      endnextprev
     C                   endif

     C                   when      $psubcmd = '*NXTSLOT' or
     C                             $psubcmd = '*PRVSLOT'
     C                   exsr      openslot2
     C                   if        error
     C                   goto      endnextprev
     C                   endif

417aAC                   when      $psubcmd = '*NXTVSLOT' or
417aAC                             $psubcmd = '*PRVVSLOT'
417aAC                   exsr      openslot2
417aAC                   if        error
417aAC                   goto      endnextprev
417aaC                   endif
417aAC                   exsr      openvslot2
417aAC                   if        error
417aAC                   goto      endnextprev
417aaC                   endif

     C                   other
     C                   exsr      openslot3
     C                   if        error
     C                   goto      endnextprev
     C                   endif

     C                   endsl
417lA
417lAC* Set file pointer.
417lA
610fAC                   eval      kywhse = $slwhse
610fAC                   eval      kywhdp = $slwhdp
610fAC                   eval      kydisp = $sldisp
610fA
417lAC                   select
417lA
417lAC                   when      $psubcmd = '*NXTITEM'
500 AC                             or $psubcmd = '*NXTITEMAV'
417lAC                   if        $slpick = ' '
417lAC                   eval      $slpick = *hival
417lAC                   endif
500eAC                   if        $slprty = 0
500eAC                   eval      $slprty = -9
500eAC                   endif
417lAC     keysl3        setgt     slot3
417lA
417lAC                   when      $psubcmd = '*PRVITEM'
417lAC     keysl3        setll     slot3
500bD **
500bDC**                 when      $psubcmd = '*GETOVRFAV'
500bDC**                 eval      $slpick = 'N'
500bDC**   keysl3        setll     slot3
417lA
417lAC                   when      $psubcmd = '*NXTOVRF'
417lAC                             or $psubcmd = '*NXTOVRFAV'
417lAC                   eval      $slpick = 'N'
417lAC     keysl3        setgt     slot3

417lAC                   when      $psubcmd = '*PRVOVRF'
417lAC                   eval      $slpick = 'N'
417lAC     keysl3        setll     slot3
417lA
417lAC                   when      $psubcmd = '*NXTPICK'
417lAC                             or $psubcmd = '*NXTPICKAV'
417lAC                   eval      $slpick = 'Y'
600bAC                   if        $slprty = 0
600bAC                   eval      $slprty = -9
600bAC                   endif
417lAC     keysl3        setgt     slot3
417lA
417lAC                   when      $psubcmd = '*PRVPICK'
417lAC                   eval      $slpick = 'Y'
417lAC     keysl3        setll     slot3
417lA
417lAC                   when      $psubcmd = '*NXTSLOT'
417lAC     keysl2        setgt     slot2
417lA
417lAC                   when      $psubcmd = '*PRVSLOT'
417lAC     keysl2        setll     slot2
417lA
417lAC                   when      $psubcmd = '*NXTSLOTI'
417lAC     keysl1        setgt     slot1
417lA
417lAC                   when      $psubcmd = '*PRVSLOTI'
417lAC     keysl1        setll     slot1
417lA
417lAC                   when      $psubcmd = '*NXTVSLOT'
417lAC     keyvs2$f      setgt     vslot2
417lA
417lAC                   when      $psubcmd = '*PRVVSLOT'
417lAC     keyvs2$f      setll     vslot2
417lA
417lAC                   endsl

416rAC* Create read loop.

416rAC                   dow       forever = forever

     C* Get record.

     C                   select

     C                   when      $psubcmd = '*NXTITEM'
500 AC                             or $psubcmd = '*NXTITEMAV'
417lDC**                 if        $slpick = ' '
417lDC**                 eval      $slpick = *hival
417lDC**                 endif
417lDC**   keysl3        setgt     slot3
     C     keysl3p1      reade(n)  slot3

     C                   when      $psubcmd = '*PRVITEM'
417lDC**   keysl3        setll     slot3
     C     keysl3p1      readpe(n) slot3

     C                   when      $psubcmd = '*NXTOVRF'
417gAC                             or $psubcmd = '*NXTOVRFAV'
500bDC**                           or $psubcmd = '*GETOVRFAV'
417lDC**                 eval      $slpick = 'N'
417lDC**   keysl3        setgt     slot3
     C     keysl3p2      reade(n)  slot3

     C                   when      $psubcmd = '*PRVOVRF'
417lDC**                 eval      $slpick = 'N'
417lDC**   keysl3        setll     slot3
     C     keysl3p2      readpe(n) slot3

     C                   when      $psubcmd = '*NXTPICK'
416rAC                             or $psubcmd = '*NXTPICKAV'
417lDC**                 eval      $slpick = 'Y'
417lDC**   keysl3        setgt     slot3
     C     keysl3p2      reade(n)  slot3

     C                   when      $psubcmd = '*PRVPICK'
417lDC**                 eval      $slpick = 'Y'
417lDC**   keysl3        setll     slot3
     C     keysl3p2      readpe(n) slot3

     C                   when      $psubcmd = '*NXTSLOT'
417lDC**   keysl2        setgt     slot2
     C     keyslp        reade(n)  slot2

     C                   when      $psubcmd = '*PRVSLOT'
417lDC**   keysl2        setll     slot2
     C     keyslp        readpe(n) slot2

     C                   when      $psubcmd = '*NXTSLOTI'
417lDC**   keysl1        setgt     slot1
     C     keyslp        reade(n)  slot1

     C                   when      $psubcmd = '*PRVSLOTI'
417lDC**   keysl1        setll     slot1
     C     keyslp        readpe(n) slot1

417aAC                   when      $psubcmd = '*NXTVSLOT'
417lDC**   keyvs2$f      setgt     vslot2
417aAC     keyvs2$       reade     vslot2

417aAC                   when      $psubcmd = '*PRVVSLOT'
417lDC**   keyvs2$f      setll     vslot2
417aAC     keyvs2$       readpe    vslot2

     C                   endsl

     C* Check for eof.

     C                   if        %eof
     C                   eval      $preturn = 'EOF'
     C                   goto      endnextprev
     C                   endif
417aA
417aAC* Get slot record for *NXTVSLOT/*PRVVSLOT.
417aA
417aAC                   if        $psubcmd = '*NXTVSLOT' or
417aAC                             $psubcmd = '*PRVVSLOT'
417aAC                   eval      lock = *off
417aAC                   eval      kywhse = vswhse
417aAC                   eval      kywhdp = vswhdp
417aAC                   eval      kydisp = vsdisp
417aAC                   eval      check4err = *on
417aAC                   exsr      getslot2
417aAC                   if        error
417aAC                   goto      endnextprev
417aAC                   endif
417aAC                   endif

     C* Calculate quantities.

     C                   exsr      calcqtys

417kDC**Move record fields into data structure.
417kDC**
417kDC**                 exsr      slot2ds
416rA
416rAC* See if we need to loop around and try again.
416rA
416rAC*   Loop if needing a pick slot with avail qty and all qtys <= 0
416rA
416rAC                   if        $psubcmd = '*NXTPICKAV' and
416rAC                             slavl1 <= 0             and
416rAC                             slavl2 <= 0             and
416rAC                             slavl3 <= 0
416rAC                   iter
416rAC                   endif
417gA
417gAC*   Loop if needing a overflow slot with avail qty and all qtys <= 0
417gA
417gAC                   if        $psubcmd = '*NXTOVRFAV' and
417gAC                             slavl1 <= 0             and
417gAC                             slavl2 <= 0             and
417gAC                             slavl3 <= 0
417gAC                   iter
417gAC                   endif
500 A
500 AC*   Loop if needing a item slot with avail qty and all qtys <= 0
500 A
500 AC                   if        $psubcmd = '*NXTITEMAV' and
500 AC                             slavl1 <= 0             and
500 AC                             slavl2 <= 0             and
500 AC                             slavl3 <= 0
500 AC                   iter
500 AC                   endif

417kAC* Move record fields into data structure.
417kA
417kAC                   exsr      slot2ds

416rAC                   leave
416rAC                   enddo

     C     endnextprev   endsr

417eA*----------------------------------------------------------------
417eA*  openslotdgt  Open file SlotDgt
417eA*----------------------------------------------------------------
417eA
417eAC     openslotdgt   begsr

     C                   if        not %open(slotdgt)
     C                   open(e)   slotdgt
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRSCD'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file SLOTDGT in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

417cA*----------------------------------------------------------------
417cA*  opencrossdk  Open file CrossDk
417cA*----------------------------------------------------------------
417cA
417cAC     opencrossdk   begsr

     C                   if        not %open(crossdk)
     C                   open(e)   crossdk
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRXDK'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file CROSSDK in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  openitemadj  Open file ItemAdj
416bA*----------------------------------------------------------------
416bA
416bAC     openitemadj   begsr

     C                   if        not %open(itemadj)
     C                   open(e)   itemadj
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRIADJ'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file ITEMADJ in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  openlabel  Open file Label
416bA*----------------------------------------------------------------
416bA
416bAC     openlabel     begsr

730iMC                   if        not %open(labelw)
730iMC                   open(e)   labelw
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRLBL'
     C                   eval      $pmessage = 'Error occured trying to '
730iMC                                       + 'open file LABELW in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  openslot1  Open file Slot1
416bA*----------------------------------------------------------------
416bA
416bAC     openslot1     begsr

     C                   if        not %open(slot1)
     C                   open(e)   slot1
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRSLT1'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file SLOT1 in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  openslot2  Open file Slot2
416bA*----------------------------------------------------------------
416bA
416bAC     openslot2     begsr

     C                   if        not %open(slot2)
     C                   open(e)   slot2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRSLT2'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file SLOT2 in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  openslot3  Open file Slot3
416bA*----------------------------------------------------------------
416bA
416bAC     openslot3     begsr

     C                   if        not %open(slot3)
     C                   open(e)   slot3
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRSLT3'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file SLOT3 in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

700gA*----------------------------------------------------------------
700gA*  openslot13 Open file Slot13
700gA*----------------------------------------------------------------
700gA
700gAC     openslot13    begsr

700gAC                   if        not %open(slot13)
700gAC                   open(e)   slot13
700gAC                   if        %error
700gAC                   eval      error = *on
700gAC                   eval      $preturn  = 'OPNERRSLT13'
700gAC                   eval      $pmessage = 'Error occured trying to '
700gAC                                       + 'open file SLOT13 in pgm'
700gAC                                       + #prog
700gAC                   endif
700gAC                   endif

700gAC                   endsr

611hA*----------------------------------------------------------------
611hA*  openslot11  Open file Slot11
611hA*----------------------------------------------------------------
611hA
611hAC     openslot11    begsr

     C                   if        not %open(slot11)
     C                   open(e)   slot11
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRSL11'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file SLOT11 in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

417cA*----------------------------------------------------------------
417cA*  openspclord  Open file SpclOrd
417cA*----------------------------------------------------------------
417cA
417cAC     openspclord   begsr

     C                   if        not %open(spclord)
     C                   open(e)   spclord
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRSPCL'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file SPCLORD in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

417cA*----------------------------------------------------------------
417cA*  openvslexcp  Open file VslExcp
417cA*----------------------------------------------------------------
417cA
417cAC     openvslexcp   begsr

     C                   if        not %open(vslexcp)
     C                   open(e)   vslexcp
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNVSLEXP'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file VSLEXCP in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416bA*----------------------------------------------------------------
416bA*  openvslot  Open file VSlot
416bA*----------------------------------------------------------------
416bA
416bAC     openvslot     begsr

     C                   if        not %open(vslot)
     C                   open(e)   vslot
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRVSLT'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file VSLOT in pgm '
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

416aA*----------------------------------------------------------------
417aA*  openvslot2  Open file VSlot2
417aA*----------------------------------------------------------------
417aA
417aAC     openvslot2    begsr

     C                   if        not %open(vslot2)
     C                   open(e)   vslot2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'OPNERRVSL2'
     C                   eval      $pmessage = 'Error occured trying to '
     C                                       + 'open file VSLOT2 in pgm'
     C                                       + #prog
     C                   endif
     C                   endif

     C                   endsr

610gA*----------------------------------------------------------------
610gA*  qty2slt   Transfer qty from USR slot into normal slot
610gA*----------------------------------------------------------------
610gA
610gAC     qty2slt       begsr
     C                   eval      currRoutine = 'qty2slt'
     C                   exsr      phpgmV1V2V3s

     *  Now put qty into slot.

     C                   eval      diffStatus = *on
     C                   exsr      qtyclsrcv
GFCaA*
GFCaAC                   if        client = Glazier
SFGeAC                             or client = SGC
FPRgAC                             or client = FoodPro
GMMdAC                             or client = MenuMaker
GFCaA*
GFCaA*      Call Host interface pgm to update Host pick slot.
GFCaAC                   if            Slitem > ' '
GFCaAC                             and Slpick = 'Y'
GFCcAC                             and Slstat <> 'Z'
GFCcAC                             and Slstat <> 'V'
GFCcAC                             and Slstat <> 'XD'
GFCaA
GFCaA*  Get live status for item's department.
GFCaAC                   call      'CHKLIVE'
GFCdAC                   parm      slwhse        $cwhse
GFCaAC                   parm                    slwhdp
GFCaAC                   parm                    livestat          8
GFCaA
GFCaA*  If department is not live, then read next item.
GFCaAC                   if        livestat = '*LIVE'
GFCaA
GFCaAC                   eval      $rwhse = %editc(slwhse:'X')
GFCaAC                   call      'HIT735CL'
GFCaAC                   parm      '*UPDPCKSLT'  $rcmd            10
GFCaAC                   parm                    $rwhse            3
GFCaAC                   parm      slitem        $ritem           15
GFCaAC                   parm      sldisp        $rdisp           12
700 AC                   parm      slstat        $rstat
GFCaAC                   parm      ' '           $rrtn             8
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*
GFCaAC                   endif
GFCaA*

     *  Send back normal slot information.

     C                   exsr      slot2ds

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2

     *  Last of all, update license tracking.

640tAC                   if        $psubcmd <> '*DPPUT'
     C                   exsr      trackLcnsTo
640tAC                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  qtyadjust   Adjust quantities for *ADJUST/*ADJUSTORD
650pA*              / *ADJUSTREV
710bA*              / *ADJUSTIMP
     *----------------------------------------------------------------

     C     qtyadjust     begsr
600tAC                   eval      currRoutine = 'qtyadjust'
600tAC                   exsr      phpgmV1V2V3s

     *  Open ItemAdj and Label files.

     C                   exsr      openitemadj
     C                   if        error
     C                   goto      endqtyadjust
     C                   endif

     C                   exsr      openlabel
     C                   if        error
     C                   goto      endqtyadjust
     C                   endif

     *  Get current date and time.

     C                   exsr      getdatetime

     *  Update slot and warehouse quantities.
416nA*    Only if Dakota should be updated according to adj code type.

416nAC                   if        $vsys <> 'H'
     C                   exsr      qtystock
     C                   if        error
     C                   goto      endqtyadjust
     C                   endif
416nAC                   endif
416nA
416nA*  Execute routine to write out adjustment and label recs.
416nA*    (code used to be part of this routine)
416nA
600mAC                   if        $psubcmd <> '*ADJUSTOSS'
710bAC                             and $psubcmd <> '*ADJUSTIMP'
416nAC                   exsr      writeadj
600mAC                   endif
600fA
600fA*  Update license tracking.
600fA
600fAC                   if        $vsys <> 'H'
600fAC                   eval      to$Slot = $slot
600fAC                   eval      to$Slot2 = $slot2
710fAC                   eval      savePRLic = '*NONE'
710bAc                   if        $psubcmd = '*ADJUSTIMP'
710fA * need to determine if I have already created a license in this
710fA * slot with the exact same date criteria.
710fAc                   exsr      chkslotlic
710fAc                   if        savePRLic <> '*NONE'
710fAc                   exsr      trackAdjust
710fAc                   else
710bAC                   exsr      trackLcnsTo
710fAc                   endif
710bAc                   else
600fAC                   exsr      trackAdjust
710bAc                   endif
600fAC                   endif

416bA*    See if we should try to create a priority replenishment.

416bAC                   if        $psubcmd = '*ADJUSTORD' and
416bAC                             $vsys <> 'H' and
650cDC*                            $slpick = 'Y' and
650cAC                             ($slpick = 'Y' or $saAction = 'ODR') and
416bAC                             $slavl1 < 0
416bAC                   exsr      crtprtyrpl
416bAC                   endif

     C     endqtyadjust  endsr

416cA*----------------------------------------------------------------
416cA*  qtyalc2pck   Move quantity from allocated to picked.
416cA*----------------------------------------------------------------
416cA
416cAC     qtyalc2pck    begsr
600tAC                   eval      currRoutine = 'qtyalc2pck'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtya2p
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtya2p
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = $saorg1
     C                   eval      #whseorg2 = $saorg2
     C                   eval      #whseorg3 = $saorg3

     *  Update slot ...

     *    Reduce allocated quantites by original quantities.

     C                   eval      slalc1 = slalc1 - $saorg1
     C                   eval      slalc2 = slalc2 - $saorg2
     C                   eval      slalc3 = slalc3 - $saorg3

     *    Increase picked quantites by adjust quantities.

     C                   eval      slpck1 = slpck1 + $saqty1
     C                   eval      slpck2 = slpck2 + $saqty2
     C                   eval      slpck3 = slpck3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtya2p
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtya2p
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtya2p     endsr

416cA*----------------------------------------------------------------
416cA*  qtyallocate  Update allocated quantites.
416cA*----------------------------------------------------------------
416cA
416cAC     qtyallocate   begsr
600tAC                   eval      currRoutine = 'qtyallocate'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtyalc
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtyalc
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update allocated quantites.

     C                   eval      slalc1 = slalc1 + $saqty1
     C                   eval      slalc2 = slalc2 + $saqty2
     C                   eval      slalc3 = slalc3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyalc
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyalc
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyalc     endsr

416cA*----------------------------------------------------------------
416cA*  qtyclspick   Close pick by reducing picked and stock quantities.
416cA*----------------------------------------------------------------
416cA
416cAC     qtyclspick    begsr
600tAC                   eval      currRoutine = 'qtyclspick'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtyclspck
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtyclspck
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = $saorg1
     C                   eval      #whseorg2 = $saorg2
     C                   eval      #whseorg3 = $saorg3

     *  Update slot ...

     *    Reduce picked quantites by original quantities.

     C                   eval      slpck1 = slpck1 - $saorg1
     C                   eval      slpck2 = slpck2 - $saorg2
     C                   eval      slpck3 = slpck3 - $saorg3

     *    Reduce stock quantites by adjust quantities.

     C                   eval      slstk1 = slstk1 - $saqty1
     C                   eval      slstk2 = slstk2 - $saqty2
     C                   eval      slstk3 = slstk3 - $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyclspck
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyclspck
     C                   endif
510aA
510aA*  Update slot date quantities.
510aA
510aAC                   eval      $ucmd  = '*FIFO'
510aAC                   eval      $uqty1 = -($saqty1)
510aAC                   eval      $uqty2 = -($saqty2)
510aAC                   eval      $uqty3 = -($saqty3)
601aDC**                 exsr      updslotdte

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyclspck  endsr

416cA*----------------------------------------------------------------
416cA*  qtyclsrcv    Close rcv by reducing received and increasing stock.
416cA*----------------------------------------------------------------
416cA
416cAC     qtyclsrcv     begsr
600tAC                   eval      currRoutine = 'qtyclsrcv'
600tAC                   exsr      phpgmV1V2V3s

417fA*  For "change" Transfer In's, convert quantity if necessary.
417fA*    (Note: This is duplicated in QTYRECEIVE and VERIFYQTY).

417fAC                   if        $psubcmd = '*TFRINCHG'  or
417hAC                             $psubcmd = '*LETINCHG'  or
417hAC                             $psubcmd = '*PRINCHG'  or
417hAC                             $psubcmd = '*SSINCHG'  or
417fAC                             $psubcmd = '*CLSTFICHG' or
417fAC                             $psubcmd = '*CLSLTICHG' or
417fAC                             $psubcmd = '*CLSPRICHG' or
417fAC                             $psubcmd = '*CLSSSICHG' or
600dAC                             %subst($psubcmd:1:5) = '*USR2' or
500jAC                             $psubcmd = '*VFYCLSTIC' or
500jAC                             $psubcmd = '*VFYCLSLIC' or
500jAC                             $psubcmd = '*VFYCLSPIC' or
500jAC                             $psubcmd = '*VFYCLSSIC'

417fAC                   select

417fAC                   when      #fromtype = ' ' and
417fAC                               (#totype = 'B' or #totype = 'S')
     C                   eval      $saqty1 = $saqty1 * #fromumq2
600hAC                   eval      $saqty1 = $saqty1 + $saqty2
600hAC                   eval      $saqty2 = $saqty3
600hDC**                 eval      $saqty2 = $saqty2 * #fromumq3
500pAC                   eval      $saorg1 = $saorg1 * #fromumq2
600hAC                   eval      $saorg1 = $saorg1 + $saorg2
600hAC                   eval      $saorg2 = $saorg3
600hDC**                 eval      $saorg2 = $saorg2 * #fromumq3

417fAC                   when      (#fromtype = 'B' or #fromtype = 'S')
417fAC                               and #totype = ' '
     C                   if        $saqty1 <> 0 and #toumq2 > 0
     C                   eval      $saqty1 = $saqty1 / #toumq2
417fAC                   endif
     C                   if        $saqty2 <> 0 and #toumq3 > 0
     C                   eval      $saqty2 = $saqty2 / #toumq3
417fAC                   endif
500pAC                   if        $saorg1 <> 0 and #toumq2 > 0
500pAC                   eval      $saorg1 = $saorg1 / #toumq2
500pAC                   endif
500pAC                   if        $saorg2 <> 0 and #toumq3 > 0
500pAC                   eval      $saorg2 = $saorg2 / #toumq3
500pAC                   endif

417fAC                   endsl

417fAC                   endif

     *  Do extra verification ...

     *    When closing to zero we will ignore the following conditions:
     *      - Slot status is 'Z' or 'V'.
     *      - Item is not in the slot.
640tA*    Skip check for *DPPUT because we are not closing to zero,
640tA*    we are putting the item with zero qty into the slot.
700tA*    or when transferring a zero qty

640tAC                   if        $psubcmd <> '*DPPUT'
700tAC                             and $saAllowZero <> 'Y'
     C                   if        $saqty1 = 0 and
     C                             $saqty2 = 0 and
     C                             $saqty3 = 0
     C                   if        slstat = 'Z' or
     C                             slstat = 'V' or
     C                             slitem <> #slotitem
     C                   goto      endqtyclsrcv
     C                   endif
     C                   endif
640tAC                   endif

     *    Calculate new available slot quantities.

     C                   eval      newavlqty1  = slavl1 - $saorg1 + $saqty1
     C                   eval      newavlqty2  = slavl2 - $saorg2 + $saqty2
     C                   eval      newavlqty3  = slavl3 - $saorg3 + $saqty3

500jA*    Skip actual update when verifying.
500jA
500jAC                   if        %subst($psubcmd:1:4) = '*VFY'
500jAC                   goto      endqtyclsrcv
500jAC                   endif

     *  Initialize warehouse updated quantities.
640jA*    Moved #whsestat initialization after status is determined.

640jDC**                 eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = $saorg1
     C                   eval      #whseorg2 = $saorg2
     C                   eval      #whseorg3 = $saorg3

     *  Update slot ...

     *    Update item if blank.

     C                   if        slitem = ' '
500jAC                             or slstat = 'V'
500qMC                   eval      slitem = #slotitem
     C                   endif

     *    Reduce received quantites by original quantities.

     C                   eval      slrcv1 = slrcv1 - $saorg1
     C                   eval      slrcv2 = slrcv2 - $saorg2
     C                   eval      slrcv3 = slrcv3 - $saorg3

     *    Increase stock quantites by adjust quantities.

     C                   eval      slstk1 = slstk1 + $saqty1
     C                   eval      slstk2 = slstk2 + $saqty2
     C                   eval      slstk3 = slstk3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

417iA*    Set dates, priority and status.
417iA
640tA
640tA*  Special handling of status for *DPPUT
700tA*  and transferring a zero qty
640tA
640tAC                   if        $psubcmd = '*DPPUT'
700tAC                             or $saAllowZero = 'Y'
640tAC                   if        slstat = 'V' or slstat = 'Z'
640tAC                   eval      slstat = 'A'
640tAC                   exsr      getdatetime
640tAC                   eval      slsdte = curdate
640tAC                   eval      slstim = curtime
640tAC                   endif
640tAC                   else
650qA*  Special handling of status for Production Transfers
650qAc                   eval      sltc = 0
650qAc                   eval      sltc = %lookup(slaisl:prdslt:1)
650qAC                   if        %subst($psubcmd:1:5) = '*USR2'
650qAc                               and sltc <> 0 and slaisl<>' '
650qAc                   eval      slstat = 'PR'
650qAc                   else
710lA*  Special handling of status for Repack Transfers
710lAC                   if        %subst($psubcmd:1:5) = '*USR2'
710lAc                               and slaisl='RPK'
650qAc                   eval      slstat = 'RP'
710lAc                   else
417rAC                   exsr      setstatus
710lAc                   endif
650qAc                   endif
640tAC                   endif
601aDC**                 exsr      getdateopt
417iAC                   exsr      setentdate
417iAC                   exsr      setexpdate
417iAC                   exsr      setpriority

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyclsrcv
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds
640tA
640tA*  For *DPPUT, we're done, so get out.
640tA
640tAC                   if        $psubcmd = '*DPPUT'
640tAC                   leavesr
640tAC                   endif
417sA
417sA*  Execute routine to write out adjustment and label recs.
417sA
417sAC                   if        $psubcmd = '*CLSRCVADJ'
417sAC                   exsr      writeadj
417sAC                   endif

     *  Update warehouse quantities ...
600dA*    Except when transfering to/from a USR slot.

600dAC                   if        %subst($psubcmd:5:4) <> '2USR'
600dAC                             and %subst($psubcmd:1:4) <> '*USR'
600dAC                             or  itemChanged
600yAC                             or  diffStatus
640jAC                   eval      #whsestat = slstat
650lAC* If status changed from Inactive, update hold qty
650lAC                   if        %subst($slotbefore:53:2) <> 'A'
650lAC                             and %subst($slotbefore:53:2) <> 'Z'
650lAC                             and %subst($slotbefore:53:2) <> 'V'
650lAC                             and slstat = 'Z'
650lAC                   eval      svsubcmd = $psubcmd
650lAC                   eval      $psubcmd = '*HOLD'
650lAC                   exsr      qtywhse
650lAC                   eval      $psubcmd = svsubcmd
650lAC                   endif
     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyclsrcv
     C                   endif
600dAC                   endif
510aA
510aA*  Update slot date quantities.
510aA
510aAC                   eval      $ucmd  = '*DATE'
510aAC                   eval      $uqty1 = $saqty1
510aAC                   eval      $uqty2 = $saqty2
510aAC                   eval      $uqty3 = $saqty3
601aDC**                 exsr      updslotdte

     C     endqtyclsrcv  endsr

416cA*----------------------------------------------------------------
416cA*  qtyclstfrout  Close tfrout by reducing tfr and stock quantities.
416cA*----------------------------------------------------------------
416cA
416cAC     qtyclstfrout  begsr
600tAC                   eval      currRoutine = 'qtyclstfrout'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...
417dA
417dA*    Item type cannot be 'C'.
417dA
417dAC                   if        #slottype = 'C'
417dAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
417dAC                   eval      $preturn  = 'INVLDITYP'
417dAC                   exsr      getmsg
417dAC                   goto      endqtyclstfro
417dAC                   endif
417dA
417dA*    Corresponding item type cannot be 'C'.
417dA
417dAC                   if        #cslottype = 'C'
417dAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
417dAC                   eval      $preturn  = 'INVLDCITYP'
417dAC                   exsr      getmsg
417dAC                   goto      endqtyclstfro
417dAC                   endif

     *    When closing to zero we will ignore the following conditions:
     *      - Slot status is 'Z' or 'V'.
     *      - Item is not in the slot.

     C                   if        $saqty1 = 0 and
     C                             $saqty2 = 0 and
     C                             $saqty3 = 0
     C                   if        slstat = 'Z' or
     C                             slstat = 'V' or
     C                             slitem <> #slotitem
     C                   goto      endqtyclstfro
     C                   endif
     C                   endif

     *    Make sure that slot is not at Verified status.

     C                   if        slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtyclstfro
     C                   endif

     *    Make sure slot is not at Zero status unless all adjustment
     *    quantities are negative (This would indicate user is trying
     *    to undo a previous *CLSTFROUT that set the status to Zero).

     C                   if        slstat = 'Z'
     C                   if        $saqty1 > 0 or
     C                             $saqty2 > 0 or
     C                             $saqty3 > 0
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtyclstfro
     C                   endif
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtyclstfro
     C                   endif

640lA*    New available slot quantities cannot exceed 99,999
640lA
640lAC                   eval      qtytest = slavl1 + $saorg1 - $saqty1
640lAC                   if        qtytest > 99999
640lAC                   eval      error = *on
640lAC                   eval      $saqty1e = '1'
640lAC                   eval      $preturn = 'ADJQTYMAX'
640lAC                   exsr      getmsg
640lAC                   goto      endqtyclstfro
640lAC                   endif

     *    Calculate new available slot qty.

     C                   eval      newavlqty1  = slavl1 + $saorg1 - $saqty1
     C                   eval      newavlqty2  = slavl2 + $saorg2 - $saqty2
     C                   eval      newavlqty3  = slavl3 + $saorg3 - $saqty3
640cAC                   eval      lownewavl = (newavlqty1*#slotumq2* #slotumq3)
640cAC                                       + (newavlqty2 * #slotumq3)
640cAC                                       + newavlqty3

     *    New available slot quantities cannot be negative ...
     *      when reducing the available qty ($saqty is positive)

640cDC*                  if        newavlqty1 < 0 and $saqty1 > 0 or
640cDC*                            newavlqty2 < 0 and $saqty2 > 0 or
640cDC*                            newavlqty3 < 0 and $saqty3 > 0
640cMC                   if        lownewavl < 0
640dAC                             and $psubcmd <> '*TFR2USRN'
     C                   eval      error = *on
     C                   eval      $saqty1e = '1'
     C                   eval      $saqty2e = '1'
     C                   eval      $saqty3e = '1'
     C                   eval      $preturn = 'NEGAVLSLT'
     C                   exsr      getmsg
     C                   goto      endqtyclstfro
     C                   endif

     *    New warehouse available quantity cannot be negative ...
     *      when reducing the available qty ($saqty is positive)

     C                   if        $saqty1 > 0 or
     C                             $saqty2 > 0 or
     C                             $saqty3 > 0
500dDC**                 if        (lowwhavl + lowiaorg - lowiaqty) < 0
500dDC**                 eval      error = *on
500dDC**                 eval      $saqty1e = '1'
500dDC**                 eval      $saqty2e = '1'
500dDC**                 eval      $saqty3e = '1'
500dDC**                 eval      $preturn = 'NEGAVLWHS'
500dDC**                 exsr      getmsg
500dDC**                 goto      endqtyclstfro
500dDC**                 endif
     C                   endif

500jA*    Skip actual update when verifying.
500jA
500jAC                   if        %subst($psubcmd:1:4) = '*VFY'
500jAC                   goto      endqtyclstfro
500jAC                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = $saorg1
     C                   eval      #whseorg2 = $saorg2
     C                   eval      #whseorg3 = $saorg3

     *  Update slot ...

     *    Reduce transfered quantites by original quantities.

     C                   eval      sltfr1 = sltfr1 - $saorg1
     C                   eval      sltfr2 = sltfr2 - $saorg2
     C                   eval      sltfr3 = sltfr3 - $saorg3

     *    Reduce stock quantites by adjust quantities.

     C                   eval      slstk1 = slstk1 - $saqty1
     C                   eval      slstk2 = slstk2 - $saqty2
     C                   eval      slstk3 = slstk3 - $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

600dA*    See if we should delete or update record.
600dA*    Delete record ...
600dA*      - When working with USR slot and all qty's are zero.
600dA
600dAC                   eval      deleteRec = *off
600dAC                   if        %subst($psubcmd:1:4) = '*USR'
600dAC                             or (%subst($psubcmd:5:4) = '2USR'
600dAC                                 and (slaisl = aisleRCV
700sAC                                      or slaisl = aisleRTN
730eAC                                      or slaisl = aisleRWO
720 AC*                                     or slaisl = aisleRPA
600dAC                                      or slaisl = aisleSTG
600dAC                                     )
600dAC                                )
600dAC                   exsr      checkallzero
600dAC                   if        allZero
600dAC                   eval      deleteRec = *on
600dAC                   endif
600dAC                   endif

     *    Update record.

600dAC                   if        not deleteRec
     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyclstfro
     C                   endif
600dA
600dA*    Or delete record.
600dA
600dAC                   else
600dAC                   exsr      deleteslot
600dAC                   if        error
600dAC                   goto      endqtyclstfro
600dAC                   endif
600dAC                   endif

     *  Update warehouse quantities ...
600dA*    Except when transfering to/from a USR slot.

600dAC                   if        %subst($psubcmd:5:4) <> '2USR'
600dAC                             and %subst($psubcmd:1:4) <> '*USR'
     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyclstfro
     C                   endif
600dAC                   endif
510aA
510aA*  Update slot date quantities.
510aA
510aAC                   eval      $ucmd  = '*FIFO'
510aAC                   eval      $uqty1 = -($saqty1)
510aAC                   eval      $uqty2 = -($saqty2)
510aAC                   eval      $uqty3 = -($saqty3)
601aDC**                 exsr      updslotdte

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds
601dA
601dA*  Set Empty flag.
601dA
601dAC                   if        not deleteRec
601dAC                             and slstat = 'Z'
601dAC                   eval      $saFrmEmptyU = *on
601dAC                   eval      $saFrmEmpty = 'Y'
601dAC                   else
601dAC                   eval      $saFrmEmpty = 'N'
601dAC                   endif

     C     endqtyclstfro endsr

416cA*----------------------------------------------------------------
416cA*  qtypck2alc   Move quantity from picked to allocated.
416cA*----------------------------------------------------------------
416cA
416cAC     qtypck2alc    begsr
600tAC                   eval      currRoutine = 'qtypck2alc'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtyp2a
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtyp2a
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = $saorg1
     C                   eval      #whseorg2 = $saorg2
     C                   eval      #whseorg3 = $saorg3

     *  Update slot ...

     *    Reduce picked quantites by original quantities.

     C                   eval      slpck1 = slpck1 - $saorg1
     C                   eval      slpck2 = slpck2 - $saorg2
     C                   eval      slpck3 = slpck3 - $saorg3

     *    Increase allocated quantites by adjust quantities.

     C                   eval      slalc1 = slalc1 + $saqty1
     C                   eval      slalc2 = slalc2 + $saqty2
     C                   eval      slalc3 = slalc3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyp2a
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyp2a
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyp2a     endsr

416cA*----------------------------------------------------------------
416cA*  qtypick      Update picked quantites.
416cA*----------------------------------------------------------------
416cA
416cAC     qtypick       begsr
600tAC                   eval      currRoutine = 'qtypick'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtypck
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtypck
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update allocated quantites.

     C                   eval      slpck1 = slpck1 + $saqty1
     C                   eval      slpck2 = slpck2 + $saqty2
     C                   eval      slpck3 = slpck3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtypck
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtypck
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

416eA*    See if we should try to create a priority replenishment.

416eAC                   if        slpick = 'Y' and  slavl1 < 0
416eAC                   exsr      crtprtyrpl
416eAC                   endif

     C     endqtypck     endsr

416cA*----------------------------------------------------------------
416cA*  qtyreceive   Update received quantities
416cA*----------------------------------------------------------------
416cA
416cAC     qtyreceive    begsr
600tAC                   eval      currRoutine = 'qtyreceive'
600tAC                   exsr      phpgmV1V2V3s

417fA*  For "change" Transfer In's, convert quantity if necessary.
417fA*    (Note: This is duplicated in QTYCLSRCV and VERIFYQTY).

417fAC                   if        $psubcmd = '*TFRINCHG'  or
417hAC                             $psubcmd = '*LETINCHG'  or
417hAC                             $psubcmd = '*PRINCHG'  or
417hAC                             $psubcmd = '*SSINCHG'  or
500jDC**                           $psubcmd = '*CLSTFICHG' or
500jDC**                           $psubcmd = '*CLSLTICHG' or
500jDC**                           $psubcmd = '*CLSPRICHG' or
500jDC**                           $psubcmd = '*CLSSSICHG' or
417fAC                             $psubcmd = '*VFYTFICHG' or
417hAC                             $psubcmd = '*VFYLTICHG' or
417hAC                             $psubcmd = '*VFYPRICHG' or
417hAC                             $psubcmd = '*VFYSSICHG'

417fAC                   select

417fAC                   when      #fromtype = ' ' and
417fAC                               (#totype = 'B' or #totype = 'S')
     C                   eval      $saqty1 = $saqty1 * #fromumq2
600hAC                   eval      $saqty1 = $saqty1 + $saqty2
600hAC                   eval      $saqty2 = $saqty3
600hDC**                 eval      $saqty2 = $saqty2 * #fromumq3
500pAC                   eval      $saorg1 = $saorg1 * #fromumq2
600hAC                   eval      $saorg1 = $saorg1 + $saorg2
600hAC                   eval      $saorg2 = $saorg3
600hDC**                 eval      $saorg2 = $saorg2 * #fromumq3

417fAC                   when      (#fromtype = 'B' or #fromtype = 'S')
417fAC                               and #totype = ' '
     C                   if        $saqty1 <> 0 and #toumq2 > 0
     C                   eval      $saqty1 = $saqty1 / #toumq2
417fAC                   endif
     C                   if        $saqty2 <> 0 and #toumq3 > 0
     C                   eval      $saqty2 = $saqty2 / #toumq3
417fAC                   endif
500pAC                   if        $saorg1 <> 0 and #toumq2 > 0
500pAC                   eval      $saorg1 = $saorg1 / #toumq2
500pAC                   endif
500pAC                   if        $saorg2 <> 0 and #toumq3 > 0
500pAC                   eval      $saorg2 = $saorg2 / #toumq3
500pAC                   endif

417fAC                   endsl

417fAC                   endif

     *  Do extra verification ...

640lA*    New available slot quantities cannot exceed 99,999
750bA*    Ck only for existing slots. Not necessary for new virtuals.
640lA
640lAC                   eval      qtytest = slavl1 + $saqty1
640lAC                   if        qtytest > 99999
750bAC                             and newvs = '0'
640lAC                   eval      error = *on
640lAC                   eval      $saqty1e = '1'
640lAC                   eval      $preturn = 'ADJQTYMAX'
640lAC                   exsr      getmsg
640lAC                   goto      endqtyrcv
640lAC                   endif

     *    Calculate new available slot quantities.

     C                   eval      newavlqty1  = slavl1 + $saqty1
     C                   eval      newavlqty2  = slavl2 + $saqty2
     C                   eval      newavlqty3  = slavl3 + $saqty3

     *    New available slot quantities cannot be negative ...
     *      when reducing the available qty

500rDC**                 if        newavlqty1 < 0 and $saqty1 < 0 or
500rDC**                           newavlqty2 < 0 and $saqty2 < 0 or
500rDC**                           newavlqty3 < 0 and $saqty3 < 0
500rDC**                 eval      error = *on
500rDC**                 eval      $saqty1e = '1'
500rDC**                 eval      $saqty2e = '1'
500rDC**                 eval      $saqty3e = '1'
500rDC**                 eval      $preturn = 'NEGAVLSLT'
500rDC**                 exsr      getmsg
500rDC**                 goto      endqtyrcv
500rDC**                 endif

     *    New warehouse available quantity cannot be negative ...
     *      when reducing the available qty

     C                   if        $saqty1 < 0 or
     C                             $saqty2 < 0 or
     C                             $saqty3 < 0
500dDC**                 if        (lowwhavl - lowiaqty) < 0
500dDC**                 eval      error = *on
500dDC**                 eval      $saqty1e = '1'
500dDC**                 eval      $saqty2e = '1'
500dDC**                 eval      $saqty3e = '1'
500dDC**                 eval      $preturn = 'NEGAVLWHS'
500dDC**                 exsr      getmsg
500dDC**                 goto      endqtyrcv
500dDC**                 endif
     C                   endif

416oA*    Skip actual update when verifying.
416oA
416oAC                   if        $psubcmd = '*VERIFYTFI'
417hAC                             or $psubcmd = '*VERIFYLTI'
417hAC                             or $psubcmd = '*VERIFYPRI'
417hAC                             or $psubcmd = '*VERIFYSSI'
417fAC                             or $psubcmd = '*VFYTFICHG'
417hAC                             or $psubcmd = '*VFYLTICHG'
417hAC                             or $psubcmd = '*VFYPRICHG'
417hAC                             or $psubcmd = '*VFYSSICHG'
500eAC                             or $psubcmd = '*VERIFYPUT'
500xAC                             or $psubcmd = '*VFYSTGPUT'
500eAC                             or $psubcmd = '*VERIFYRTN'
500iAC                             or $psubcmd = '*VERIFYSI'
416oAC                   goto      endqtyrcv
416oAC                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update item if blank.

     C                   if        slitem = ' '
500qDC**                 eval      slitem = $saitem
500qMC                   eval      slitem = #slotitem
     C                   endif
417iDC**
417iDC**   Update expiration date.
417iDC**
417iDC**                 eval      updexpdte = *off
417iDC**
417iDC**    Set expiration date to zero if necessary.
417iDC**
417iDC**                 if        #slotflgd <> 'Y' or not $slexpdu
417iDC**                 eval      $slexpd = 0
417iDC**                 endif
417iDC**
417iDC**    Update if item is not date sensitive.
417iDC**
417iDC**                 if        #slotflgd <> 'Y'
417iDC**                 eval      updexpdte = *on
417iDC**                 endif
417iDC**
417iDC**    Update if status is 'V' or 'Z' or existing date is zero.
417iDC**
417iDC**                 if        slstat = 'V' or
417iDC**                           slstat = 'Z' or
417iDC**                           slexpd = 0
417iDC**                 eval      updexpdte = *on
417iDC**                 endif
417iDC**
417iDC**    Update if stock qty is zero.
417iDC**
417iDC**                 if        slstk1 <= 0 and
417iDC**                           slstk2 <= 0 and
417iDC**                           slstk3 <= 0
417iDC**                 eval      updexpdte = *on
417iDC**                 endif
417iDC**
417iDC**    Update if stock qty is not zero and older expiraton date
417iDC**      (date sent in comes before existing date)
417iDC**
417iDC**                 if        slstk1 >= 0 or
417iDC**                           slstk2 >= 0 or
417iDC**                           slstk3 >= 0
417iDC**                 if        $slexpd < slexpd
417iDC**                 eval      updexpdte = *on
417iDC**                 endif
417iDC**                 endif
417iDC**
417iDC**    Update date.
417iDC**
417iDC**                 if        updexpdte
417iDC**                 eval      slexpd = $slexpd
417iDC**                 endif
417iDC**
417iDC**  Update priority.
417iDC**
417iDC**                 eval      updprty = *off
417iDC**
417iDC**    Set priority to zero if necessary.
417iDC**
417iDC**                 if        not $slprtyu or
417iDC**                           $slpick = 'Y' and $slrsrv = 'Y'
417iDC**                 eval      $slprty = 0
417iDC**                 endif
417iDC**
417iDC**    Make sure priority is less than or equal to zero.
417iDC**
417iDC**                 if        $slprty > 0
417iDC**                 eval      $slprty = -($slprty)
417iDC**                 endif
417iDC**
417iDC**    Update if status is 'V' or 'Z'.
417iDC**
417iDC**                 if        slstat = 'V' or
417iDC**                           slstat = 'Z'
417iDC**                 eval      updprty = *on
417iDC**                 endif
417iDC**
417iDC**    Update if higher priority than existing priority.
417iDC**
417iDC**                 if        %abs($slprty) > %abs(slprty)
417iDC**                 eval      updprty = *on
417iDC**                 endif
417iDC**
417iDC**    Update priority.
417iDC**
417iDC**                 if        updprty
417iDC**                 eval      slprty = $slprty
417iDC**                 endif

     *    Update received quantites.

     C                   eval      slrcv1 = slrcv1 + $saqty1
     C                   eval      slrcv2 = slrcv2 + $saqty2
     C                   eval      slrcv3 = slrcv3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn
417iDC**
417iDC**  See if status should change.
417iDC**
417iDC**    if status sent in, use it.
417iDC**    otherwise call routine to see if it should change.
417iDC**
417iDC**                 if        $slstatu and $slstat <> ' '
417iDC**                 eval      slstat = $slstat
417iDC**                 exsr      getdatetime
417iDC**                 eval      slsdte = curdate
417iDC**                 eval      slstim = curtime
417iDC**                 else
417iDC**                 exsr      checkstatus
417iDC**                 endif
417iDC**
417iDC**  Check for zero entered date.
417iDC**
417iDC**                 if        slentd <= 0
417iDC**                 exsr      getdatetime
417iDC**                 eval      slentd = curdate
417iDC**                 endif

417iA*    Set dates, priority and status.
417iA
417rAC                   exsr      setstatus
601aDC**                 exsr      getdateopt
417iAC                   exsr      setentdate
417iAC                   exsr      setexpdate
417iAC                   exsr      setpriority
417rDC**                 exsr      setstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyrcv
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyrcv
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyrcv     endsr

600dA*----------------------------------------------------------------
600dA*  qtyIn    Put qty into special RCV/STG/OSS/USR slot
600dA*----------------------------------------------------------------
600dA
600dAC     qtyIn         begsr
600tAC                   eval      currRoutine = 'qtyin'
600tAC                   exsr      phpgmV1V2V3s

     *  Update slot ...

     *    Update item if blank.

     C                   if        slitem = ' '
     C                   eval      slitem = #slotitem
     C                   endif

     *    Update stock quantites.

     C                   eval      slstk1 = slstk1 + $saqty1
     C                   eval      slstk2 = slstk2 + $saqty2
     C                   eval      slstk3 = slstk3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    Set Entered date

     *      If date wasn't sent or is zero,
     *        set to current date.
     *      Otherwise, set it to the date that was sent.

     C                   if        not $slentdu or $slentd = 0
     C                   exsr      getdatetime
     C                   eval      slentd = curdate
     C                   else
     C                   eval      slentd = $slentd
     C                   endif

     *    Set Expiration date

     *      If date wasn't sent or item not date sensitive,
     *        set to zero.
     *      Otherwise, set it to the date that was sent.

     C                   if        #slotflgd <> 'Y'
     C                             or not $slexpdu
     C                   eval      slexpd = 0
     C                   else
     C                   eval      slexpd = $slexpd
     C                   endif

     *    Set Priority to zero.

     C                   eval      slprty = 0

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyin
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyin      endsr

600dA*----------------------------------------------------------------
600dA*  qtyInWhse    Put qty into special RCV/STG/OSS/USR slot & Whse
600dA*----------------------------------------------------------------
600dA
600dAC     qtyInWhse     begsr
600tAC                   eval      currRoutine = 'qtyinwhse'
600tAC                   exsr      phpgmV1V2V3s

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update item if blank.

     C                   if        slitem = ' '
     C                   eval      slitem = #slotitem
     C                   endif

     *    Update stock quantites.

     C                   eval      slstk1 = slstk1 + $saqty1
     C                   eval      slstk2 = slstk2 + $saqty2
     C                   eval      slstk3 = slstk3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    Set Entered date

     *      If date wasn't sent or is zero,
     *        set to current date.
     *      Otherwise, set it to the date that was sent.

     C                   if        not $slentdu or $slentd = 0
     C                   exsr      getdatetime
     C                   eval      slentd = curdate
     C                   else
     C                   eval      slentd = $slentd
     C                   endif

     *    Set Expiration date

     *      If date wasn't sent or item not date sensitive,
     *        set to zero.
     *      Otherwise, set it to the date that was sent.

     C                   if        #slotflgd <> 'Y'
     C                             or not $slexpdu
     C                   eval      slexpd = 0
     C                   else
     C                   eval      slexpd = $slexpd
     C                   endif

     *    Set Priority to zero.

     C                   eval      slprty = 0

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtyinwhse
     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtyinwhse
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyinwhse  endsr

600dA*----------------------------------------------------------------
600dA*  qtyOut   Remove qty from special RCV/STG/OSS/USR slot
600dA*----------------------------------------------------------------
600dA
600dAC     qtyOut        begsr
600tAC                   eval      currRoutine = 'qtyout'
600tAC                   exsr      phpgmV1V2V3s

     *  If item changed, call routine that will change whse qty.

     C                   if        itemChanged
     C                   exsr      qtyOutWhse
     C                   leavesr
     C                   endif

     *  Update slot ...

     *    Update stock quantites.

     C                   eval      slstk1 = slstk1 - $saqty1
     C                   eval      slstk2 = slstk2 - $saqty2
     C                   eval      slstk3 = slstk3 - $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    Update record.

     *      If all qty's zero, then delete slot

     C                   exsr      checkAllZero
     C                   if        allZero

     C                   exsr      deleteslot
     C                   if        error
     C                   leavesr
     C                   endif

     *      Otherwise, update record.

     C                   else

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyout     endsr

600dA*----------------------------------------------------------------
600dA*  qtyOutWhse   Remove qty from special RCV/STG/OSS/USR slot & Whse
600dA*----------------------------------------------------------------
600dA
600dAC     qtyOutWhse    begsr
600tAC                   eval      currRoutine = 'qtyoutwhse'
600tAC                   exsr      phpgmV1V2V3s

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = -($saqty1)
     C                   eval      #whseadj2 = -($saqty2)
     C                   eval      #whseadj3 = -($saqty3)

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update stock quantites.

     C                   eval      slstk1 = slstk1 - $saqty1
     C                   eval      slstk2 = slstk2 - $saqty2
     C                   eval      slstk3 = slstk3 - $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    Update record.

     *      If all qty's zero, then delete slot

     C                   exsr      checkAllZero
     C                   if        allZero

     C                   exsr      deleteslot
     C                   if        error
     C                   leavesr
     C                   endif

     *      Otherwise, update record.

     C                   else

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtyoutwhse2
     C                   if        error
     C                   leavesr
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtyoutwhse endsr

600dA*----------------------------------------------------------------
600dA*  qtyoutwhse2   Update warehouse quantites for qtyoutwhse
600dA*----------------------------------------------------------------
600dA
600dAC     qtyoutwhse2   begsr
600tAC                   eval      currRoutine = 'qtyoutwhse2'
600tAC                   exsr      phpgmV1V2V3s

     *  Pass along subcommand & quantities sent in ...

     C                   eval      $drisubcmd = $psubcmd

     *  Add some slot and item information ...

     C                   eval      $iqwhseu = *on
     C                   eval      $iqwhse = slwhse
     C                   eval      $iqitemu = *on
     C                   eval      $iqitem = #fromitem
     C                   eval      $iqstatu = *on
     C                   eval      $iqstat = #whsestat
     C                   eval      $iqumq2u = *on
     C                   eval      $iqumq2 = #fromumq2
     C                   eval      $iqumq3u = *on
     C                   eval      $iqumq3 = #fromumq3

     *  Don't forget the quantities ...

     C                   eval      $iqfixu = *on
     C                   eval      $iqfix1 = #whsefix1
     C                   eval      $iqfix2 = #whsefix2
     C                   eval      $iqfix3 = #whsefix3
     C                   eval      $iqadju = *on
     C                   eval      $iqadj1 = #whseadj1
     C                   eval      $iqadj2 = #whseadj2
     C                   eval      $iqadj3 = #whseadj3
     C                   eval      $iqorgu = *on
     C                   eval      $iqorg1 = #whseorg1
     C                   eval      $iqorg2 = #whseorg2
     C                   eval      $iqorg3 = #whseorg3

     *  And throw in some fields for tracking.

     C                   if        $satrn#u
     C                   eval      $iqtrn#u = *on
     C                   eval      $iqtrn#  = $satrn#
     C                   endif

     C                   if        $saFrmLcnsu
     C                   eval      $iqlic#u = *on
     C                   eval      $iqlic#  = $saFrmLcns
     C                   endif

     C                   if        $satasku
     C                   eval      $iqtasku = *on
     C                   eval      $iqtask  = $satask
     C                   endif

     *  Then call interface to do the update.

     C                   eval      $dricommand = 'DRIITEMQTY'
650pAC                   if        $psubcmd = '*ADJUSTREV'
650qAc                              or $psubcmd = '*ADJUSTPRD'
710bAc                              or $psubcmd = '*ADJUSTIMP'
650pAC                   eval      $drisubcmd = '*ADJUST   '
650pAC                   else
     C                   eval      $drisubcmd = $psubcmd
650pAC                   endif
     C                   exsr      zzzdrimain3

     C                   select
     C                   when      main3callerr
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   when      main3rtnerr
     C                   eval      error = *on
     C                   eval      $saiteme = '1'
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   endsl

     C                   eval      lockeditemqty = *off

     C                   endsr


610dA*----------------------------------------------------------------
610dA*  setlicfifo  Change LICACTIVE FIFO - Pick Priority, Expiration
610dA*              Date, Entered Date.
610dA*----------------------------------------------------------------
610dA
610dAC     setLicFifo    begsr
610dA
640pAC                   eval      currRoutine = 'setLicFifo'
640pAC                   exsr      phpgmV1V2V3s
640pAC                   eval      error = *off
640pA
640pAC                   exsr      clr$license
640pA
640pAC                   eval      $liLTrnU = *on
640pAC                   eval      $liLTrn = 0
640pA
610dAC                   eval      $liToWhseu = *on
610dAC                   eval      $liToWhse = $slwhse
610dAC                   eval      $liToWhdpU = *on
610dAC                   eval      $liToWhdp = $slwhdp
640kAC                   eval      $liToItemU = *on
640kAC                   eval      $liToitem = $slitem
640kAC                   eval      $liToSItemU = *on
640kAC                   eval      $liToSitem = $slitem
610dAC                   eval      $liToDispU = *on
610dAC                   eval      $liToDisp = $sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = $sldesg
610dAC                   eval      $liToLcnsU = *on
610dAC                   eval      $liToLcns = $saToLcns
610dAC                   eval      $liToPrtyU = *on
610dAC                   eval      $liToPrty = $slPrty
610dAC                   eval      $liToEntdU = *on
610dAC                   eval      $liToEntd = $slEntd
610dAC                   eval      $liToExpdU = *on
610dAC                   eval      $liToExpd = $slExpd
640pAC                   eval      $liTrn#U = *on
640pAC                   eval      $liTrn# = $saTrn#
640pAC                   eval      $liActionU = *on
640pAC                   eval      $liAction = $saAction
640pAC                   eval      $liOLcnsU = *on
640pAC                   eval      $liOLcns = $saOLcns
610dA
610dAC                   eval      $dricommand = 'DRILICENSE'
610dAC                   eval      $drisubcmd  = '%SETFIFO'
610dAC                   eval      $drisys2upd = 'D'
610dA
610dAC                   exsr      zzzdrimain3
610dA
610dAC                   select
610dA
610dAC                   when      $drireturn = '*OK'
610dA
610dA*    See if slot FIFO info needs to be updated from licenses
610dA
610dAC                   exsr      slot2ds
610dAC                   eval      to$Slot = $Slot
610dAC                   eval      to$Slot2 = $Slot2
610dAC                   exsr      updSlotFifo
610dA
610dAC                   other
610dA
610dAC                   endSl
610dA
610dAC     endsetfifo    endsr

710kA*----------------------------------------------------------------
710kA*  setlicolcns Change LICACTIVE original License.
710kA*              also sets FIFO - Pick Priority, Expiration
710kA*              Date, Entered Date.
710kA*----------------------------------------------------------------
710kA
710kAC     setLicOLcns   begsr
710kA
710kAC                   eval      currRoutine = 'setLicOLcns'
710kAC                   exsr      phpgmV1V2V3s
710kAC                   eval      error = *off
710kA
710kAC                   exsr      clr$license
710kA
710kAC                   eval      $liLTrnU = *on
710kAC                   eval      $liLTrn = 0
710kA
710kAC                   eval      $liToWhseu = *on
710kAC                   eval      $liToWhse = $slwhse
710kAC                   eval      $liToWhdpU = *on
710kAC                   eval      $liToWhdp = $slwhdp
710kAC                   eval      $liToItemU = *on
710kAC                   eval      $liToitem = $slitem
710kAC                   eval      $liToSItemU = *on
710kAC                   eval      $liToSitem = $slitem
710kAC                   eval      $liToDispU = *on
710kAC                   eval      $liToDisp = $sldisp
710kAC                   eval      $liToDesgU = *on
710kAC                   eval      $liToDesg = $sldesg
710kAC                   eval      $liToLcnsU = *on
710kAC                   eval      $liToLcns = $saToLcns
710kAC                   eval      $liToPrtyU = *on
710kAC                   eval      $liToPrty = $slPrty
710kAC                   eval      $liToEntdU = *on
710kAC                   eval      $liToEntd = $slEntd
710kAC                   eval      $liToExpdU = *on
710kAC                   eval      $liToExpd = $slExpd
710kAC                   eval      $liTrn#U = *on
710kAC                   eval      $liTrn# = $saTrn#
710kAC                   eval      $liActionU = *on
710kAC                   eval      $liAction = $saAction
710kAC                   eval      $liOLcnsU = *on
710kAC                   eval      $liOLcns = $saOLcns
710kA
710kAC                   if        $saFrmLcnsU = *On
710kAC                   eval      $liFrmOldLcnsU = *on
710kAC                   eval      $liFrmOldLcns = $saFrmLcns
710kAc                   endif

710kAC                   eval      $dricommand = 'DRILICENSE'
710kAC                   eval      $drisubcmd  = '%SETOLCNS'
710kAC                   eval      $drisys2upd = 'D'
710kA
710kAC                   exsr      zzzdrimain3
710kA
710kAC                   select
710kA
710kAC                   when      $drireturn = '*OK'
710kA
710kA*    See if slot FIFO info needs to be updated from licenses
710kA
710kAC                   exsr      slot2ds
710kAC                   eval      to$Slot = $Slot
710kAC                   eval      to$Slot2 = $Slot2
710kAC                   exsr      updSlotFifo
710kA
710kAC                   other
710kA
710kAC                   endSl
710kA
710kAC     endsetOLcns   endsr

600iA*----------------------------------------------------------------
600iA*  stuffdlt    Delete slots that correspond to sent in base
600iA*              slot, that contain sent in item.
600iA*----------------------------------------------------------------
600iA
600iAC     stuffdlt      begsr
600tAC                   eval      currRoutine = 'stuffdlt'
600tAC                   exsr      phpgmV1V2V3s

     *  Open file

     C                   exsr      openslot1
     C                   if        error
     C                   leavesr
     C                   endif

     *  Loop through corresponding slots for base slot sent in.

     C                   eval      $slaisl = slaisl
     C                   eval      $slloc  = slloc
     C                   eval      $slrlvl = slrlvl
     C     keysl1p       setll     slot1

     C                   dow       forever = forever

     C     keysl1p       reade     slot1

     C                   if        %eof
     C                   leavesr
     C                   endif

     *    Skip 'V' slots.

     C                   if        slstat = 'V'
     C                   iter
     C                   endif

     *    Skip slots that don't contain the item sent in.
611bA*    Do not do this check for RP slots. We do not want
611bA*    to create a virtual for an RP slot, so we clear it.

     C                   if        slitem <> $slitem
611bAC                             and slstat <> 'RP'
     C                   iter
     C                   endif

     *    Skip slots that don't match slot sent in.
CPJaA*    for CPJ Stuffit.
CPJaAC                   if        client = cpj
CPJaAC                             and clientloc = cpjjamaica
CPJaAC                             and sldisp <> $sldisp
CPJaAC                   iter
CPJaAC                   endif
     *    Skip normal slots that don't match slot sent in.

     C                   if        sldisp <> $sldisp
     C                             and slrsrv <> 'V'
     C                   iter
     C                   endif

     *    Call routine to adjust qty out of slot (non-'Z' status only)
     *      (Discovered taht SU140y out of slot (non-'Z' status only)

     C**                 if        slstat <> 'Z'
     C**                 eval      $saitem = $slitem
     C**                 eval      $saqty1 = -(slstk1)
     C**                 eval      $saqty2 = -(slstk2)
     C**                 eval      $saqty3 = -(slstk3)
     C**                 eval      $saqty3 = -(slstk3)
     C**                 exsr      qtyAdjust
     C**                 endif
611cA
611cA*  Update warehouse qty if necessary.
611cA
611cAC                   if        slstk1 <> 0
611cAC                             or slstk2 <> 0
611cAC                             or slstk3 <> 0
611cAC                             or slalc1 <> 0
611cAC                             or slalc2 <> 0
611cAC                             or slalc3 <> 0
611cAC                             or sltfr1 <> 0
611cAC                             or sltfr2 <> 0
611cAC                             or sltfr3 <> 0
611cAC                             or slpck1 <> 0
611cAC                             or slpck2 <> 0
611cAC                             or slpck3 <> 0
611cAC                             or slrcv1 <> 0
611caC                             or slrcv2 <> 0
611cAC                             or slrcv3 <> 0
611cAC                   eval      qtyChanged = *on
611cAC                   eval      origItem = slitem
611cAC                   else
611cAC                   eval      qtyChanged = *off
611cAC                   endif

     *    Clear item, dates and qtys from slot record.
     *    Because this is a StuffIt situation, for a non-virtual
     *    slot that is set to a 'Z' automatically set it to 'V'.

     C                   eval      slitem = ' '
     C                   eval      slentd = 0
     C                   eval      slexpd = 0
     C                   eval      slprty = 0
     C                   eval      slstk1 = 0
     C                   eval      slstk2 = 0
     C                   eval      slstk3 = 0
     C                   eval      slalc1 = 0
     C                   eval      slalc2 = 0
     C                   eval      slalc3 = 0
     C                   eval      sltfr1 = 0
     C                   eval      sltfr2 = 0
     C                   eval      sltfr3 = 0
     C                   eval      slpck1 = 0
     C                   eval      slpck2 = 0
     C                   eval      slpck3 = 0
     C                   eval      slrcv1 = 0
     C                   eval      slrcv2 = 0
     C                   eval      slrcv3 = 0
     C                   exsr      checkstatus

     C                   if        slrsrv <> 'V' and slstat = 'Z'
CPJaAC                             or client = cpj
CPJaAC                             and clientloc = cpjjamaica
     C                   eval      slstat = 'V'
     C                   endif

     C                   update    slrec

     *    Delete virtual slot that is at a status of 'Z'

     C                   if        slrsrv = 'V' and slstat = 'Z'
     C                   eval      $sldisp = sldisp
     C                   exsr      deleteslot
     C                   endif
611cA
611cA*    Recalculate item qty if slot qty was affected.
611cA
611cAC                   if        qtyChanged
611cAC                   call      'UT812'
611cAC                   parm      slwhse        utWhse
611cAC                   parm                    origItem
611cAC                   parm      'N'           utJobq
611cAC                   parm      #pgm          $lprg
611cAC                   parm      ' '           $lrtn
611cAC                   parm      ' '           $lmsg
611cAC                   endif

     *    Delete any license plates for slot/item
611cM*    Revised to delete all license plates for the slot.
611cM*    Since we are clearing the slot, we should clear the licenses.

     C                   exsr      clr$license

     C                   if        in$Slot2.$saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = in$Slot2.$saAction
     C                   endif

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = sldesg
611cDC**                 eval      $liToAislu = *on
611cDC**                 eval      $liToAisl = slaisl
611cDC**                 eval      $liToLocU = *on
611cDC**                 eval      $liToLoc = slloc
611cDC**                 eval      $liToRlvlU = *on
611cDC**                 eval      $liToRlvl = slrlvl
611cDC**                 eval      $liToHandU = *on
611cDC**                 eval      $liToHand = slhand
611cDC**                 eval      $liToBaseU = *on
611cDC**                 eval      $liToBase = in$slot.$sldisp
611cDC**                 eval      $liToItemU = *on
611cDC**                 eval      $liToItem = #sentitem
611cDC**                 eval      $liToITypeU = *on
611cDC**                 eval      $liToIType = #senttype

611cDC**                 eval      $liToSItemU = *on
611cDC**                 eval      $liToSItem = #slotitem
611cDC**                 eval      $liToSITypeU = *on
611cDC**                 eval      $liToSIType = #slottype

     C                   eval      $dricommand = 'DRILICENSE'
611cDC**                 eval      $drisubcmd  = '%DLTSLTITM'
611cMC                   eval      $drisubcmd  = '%DELETESLT'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     C                   enddo

     C                   endsr

600dA*----------------------------------------------------------------
600dA*  stuffIt   Process *STUFFIT
600dA*----------------------------------------------------------------
600dA
600dAC     stuffIt       begsr
600tAC                   eval      currRoutine = 'stuffit'
600tAC                   exsr      phpgmV1V2V3s

     *  Call routine to put qty into slot.

600yAC                   eval      diffStatus = *off
     C                   exsr      qtyclsrcv

     *  Send back normal slot information.

     C                   exsr      slot2ds

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2

     *  Update license tracking.

     C                   exsr      trackLcnsTo

     C                   endsr

600dA*----------------------------------------------------------------
600dA*  synclcns   Synchronize LICACTIVE file with slot qty
600dA*----------------------------------------------------------------
600dA
600dAC     synclcns      begsr
600tAC                   eval      currRoutine = 'synclcns'
600tAC                   exsr      phpgmV1V2V3s

     *  Open file

     C                   exsr      openslot2
     C                   if        error
     C                   leavesr
     C                   endif

     *  Loop through slots.

601hAC**                 eval      kywhse = $slwhse
601hAC**                 eval      kywhdp = ' '
601hAC**                 eval      kydisp = ' '
610lMC                   eval      kyswhse = $slwhse
610lMC                   eval      kyswhdp = ' '
610lMC                   eval      kysdisp = ' '
601hAC                   if        $slwhdpu and $slwhdp <> ' '
601hAC**                 eval      kywhdp = $slwhdp
610lMC                   eval      kyswhdp = $slwhdp
601hAC                   endif
601hMC                   if        $sldispu and $sldisp <> ' '
601hAC**                 eval      kydisp = $sldisp
610lMC                   eval      kysdisp = $sldisp
601hMC                   endif
601hA
     C                   select
601hMC**                 when      kydisp <> ' '
     C**   keysl2disp    setll     slot2
601hMC**                 when      kywhdp <> ' '
     C**   keysl2whdp    setll     slot2
     C**                 other
     C**   keysl2whse    setll     slot2
610lMC                   when      kysdisp <> ' '
610lMC     Ksyncdisp     setll     slot2
610lMC                   when      kyswhdp <> ' '
610lMC     Ksyncwhdp     setll     slot2
     C                   other
610lMC     Ksyncwhse     setll     slot2
     C                   endsl
     C                   eval      savedisp = $sldisp

     C                   dow       forever = forever

     C                   eval      $sldisp = savedisp
     C                   select
601hMC*                  when      kydisp <> ' '
     C*    keysl2disp    reade(n)  slot2
601hMC*                  when      kywhdp <> ' '
     C*    keysl2whdp    reade(n)  slot2
     C*                  other
     C*    keysl2whse    reade(n)  slot2
610lMC                   when      kysdisp <> ' '
610lMC     Ksyncdisp     reade(n)  slot2
610lMC                   when      kyswhdp <> ' '
610lMC     Ksyncwhdp     reade(n)  slot2
     C                   other
610lMC     Ksyncwhse     reade(n)  slot2
     C                   endsl

     C                   if        %eof
640bDC**                 leavesr
640bMC                   leave
     C                   endif

     *    Get base slot

     C                   exsr      getbaseslot

     *    If slot status is not 'V' or 'Z' then get item information.

     C                   if        slstat <> 'V' and slstat <> 'Z'
     C                   eval      check4err = *off
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = slitem
     C                   exsr      getitem
601aAC                   eval      #slotitem = $ititem
601aAC                   eval      #slotflgd = $itflgd
     C                   endif

     *    Call license program

     C                   exsr      clr$license

     C                   if        in$Slot2.$saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = in$Slot2.$saAction
     C                   endif

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   if        in$Slot2.$saToLcnsU
     C                   eval      $liToLcnsU = *on
     C                   eval      $liToLcns = in$slot2.$saToLcns
     C                   endif

     C                   eval      $liAQty1U = *on
     C                   eval      $liAQty1 = slstk1
     C                   eval      $liAQty2 = slstk2
     C                   eval      $liAQty3 = slstk3

     C                   eval      $liToRQty1U = *on
     C                   eval      $liToRQty1 = slstk1
     C                   eval      $liToRQty2 = slstk2
     C                   eval      $liToRQty3 = slstk3

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = sldesg
     C                   eval      $liToAislu = *on
     C                   eval      $liToAisl = slaisl
     C                   eval      $liToLocU = *on
     C                   eval      $liToLoc = slloc
     C                   eval      $liToRlvlU = *on
     C                   eval      $liToRlvl = slrlvl
     C                   eval      $liToHandU = *on
     C                   eval      $liToHand = slhand
640yAC                   eval      $liToStatU = *on
640yAC                   eval      $liToStat = slstat
     C                   eval      $liToPrtyU = *on
     C                   eval      $liToPrty = slprty
     C                   eval      $liToBaseU = *on
600mMC                   eval      $liToBase = baseDisp
     C                   eval      $liToItemU = *on
     C                   eval      $liToItem = slitem
     C                   eval      $liToITypeU = *on
     C                   eval      $liToIType = $ittype

     C                   eval      $liToSItemU = *on
     C                   eval      $liToSItem = slitem
     C                   eval      $liToSITypeU = *on
     C                   eval      $liToSIType = $ittype

     C                   eval      $liToEntDU = *on
     C                   eval      $liToEntD = slentd
     C                   eval      $liToExpDU = *on
     C                   eval      $liToExpD = slexpd
650qA **  Pass Production Module variables
650qAc                   if        in$Slot2.$saMfgLneu
650qAc                   eval      $liMfgLneu = *on
650qAc                   eval      $liMfgLne = in$Slot2.$saMfgLne
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saGS1u
650qAc                   eval      $liGS1u = *on
650qAc                   eval      $liGS1 = in$Slot2.$saGS1
650qAc                   endif
710aAc
710aAc                   if        in$Slot2.$saRmUciU
710aAc                   eval      $liRmUciu = *on
710aAc                   eval      $liRmUci = in$Slot2.$saRmUci
710aAc                   endif
650qAc
650qAc                   if        in$Slot2.$saPrdSitmu
650qAc                   eval      $liPrdSitmu = *on
650qAc                   eval      $liPrdSitm = in$Slot2.$saPrdSitm
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saSer#u
650qAc                   eval      $liSer#u = *on
650qAc                   eval      $liSer# = in$Slot2.$saSer#
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saPrdWgtu
650qAc                   eval      $liPrdWgtu = *on
650qAc                   eval      $liPrdWgt = in$Slot2.$saPrdWgt
650qAc                   else
650qAc                   if        in$Slot.$saCwtau
650qAc                   eval      $liPrdWgtu = *on
650qAc                   eval      $liPrdWgt = in$Slot.$saCwta
650qAc                   endif
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saPrdWou
650qAc                   eval      $liPrdWou = *on
650qAc                   eval      $liPrdWo = in$Slot2.$saPrdWo
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saTareWgtu
650qAc                   eval      $liTareWgtu = *on
650qAc                   eval      $liTareWgt = in$Slot2.$saTareWgt
650qAc                   endif
650qAc

     C                   if        in$Slot.$satrn#U
     C                   eval      $liTrn#U = *on
     C                   eval      $liTrn# = in$Slot.$saTrn#
     C                   endif

     C                   if        in$Slot2.$saLbl#U
     C                   eval      $liLbl#U = *on
     C                   eval      $liLbl# = in$Slot2.$saLbl#
     C                   endif

     C                   if        in$Slot2.$saToOrdU
     C                   eval      $liToOrdU = *on
     C                   eval      $liToOrd = in$Slot2.$saToOrd
     C                   endif

     C                   if        in$Slot2.$saToSeqU
     C                   eval      $liToSeqU = *on
     C                   eval      $liToSeq = in$Slot2.$saToSeq
     C                   endif

     C                   if        in$Slot2.$saExcdU
     C                   eval      $liExcdU = *on
     C                   eval      $liExcd = in$Slot2.$saExcd
     C                   endif

     *    If slot status 'V' or 'Z' then get delete any existing records

     C                   if        slstat = 'V' or slstat = 'Z'
     C                   eval      $drisubcmd  = '%DELETESLT'
     C                   else
     C                   eval      $drisubcmd  = '%ADJSLTDTE'
     C                   endif

     C                   eval      $dricommand = 'DRILICENSE'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

601aA*    See if slot FIFO info needs to be updated from licenses
601aA
601aAC                   exsr      slot2ds
601aAC                   eval      to$Slot = $Slot
601aAC                   eval      to$Slot2 = $Slot2
601aAC                   exsr      updSlotFifo

     C                   enddo
640bA
640bA*    Last of all, clean up orphaned license plates.
640bA

     C                   exsr      clr$license

     C                   if        in$Slot2.$saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = in$Slot2.$saAction
     C                   endif

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   if        in$Slot2.$saToLcnsU
     C                   eval      $liToLcnsU = *on
     C                   eval      $liToLcns = in$slot2.$saToLcns
     C                   endif

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = kyswhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = kyswhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = kysdisp

     C                   if        in$Slot.$satrn#U
     C                   eval      $liTrn#U = *on
     C                   eval      $liTrn# = in$Slot.$saTrn#
     C                   endif

     C                   if        in$Slot2.$saLbl#U
     C                   eval      $liLbl#U = *on
     C                   eval      $liLbl# = in$Slot2.$saLbl#
     C                   endif

     C                   if        in$Slot2.$saToOrdU
     C                   eval      $liToOrdU = *on
     C                   eval      $liToOrd = in$Slot2.$saToOrd
     C                   endif

     C                   if        in$Slot2.$saToSeqU
     C                   eval      $liToSeqU = *on
     C                   eval      $liToSeq = in$Slot2.$saToSeq
     C                   endif

     C                   if        in$Slot2.$saExcdU
     C                   eval      $liExcdU = *on
     C                   eval      $liExcd = in$Slot2.$saExcd
     C                   endif

     C                   eval      $drisubcmd  = '%DLTORPHAN'
     C                   eval      $dricommand = 'DRILICENSE'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     C                   endsr

600dA*----------------------------------------------------------------
600dA*  tfr2usr   Transfer qty into USR slot
600dA*----------------------------------------------------------------
600dA
600dAC     tfr2usr       begsr
600tAC                   eval      currRoutine = 'tfr2usr'
600tAC                   exsr      phpgmV1V2V3s

     *  If From slot is already a USR slot,
     *    then get out because there is nothing to do.

     C                   if        %subst(sldisp:1:3) = 'USR'
     C                   leavesr
     C                   endif

     *  Save necessary fields.

     C                   eval      frmSLREC = slrecds

     *  Create USR slot.

     C                   exsr      getslot2USR
     C                   exsr      crtUSR
     C                   if        error
     C                   leavesr
     C                   endif

     *  Save USR slot information.

     C                   eval      toSLREC = slrecds

     *  Get and lock 'From' slot.

     C                   eval      $slaisl = frmSLREC.slaisl
     C                   eval      $slrlvl = frmSLREC.slrlvl
     C                   eval      $sldisp = frmSLREC.sldisp

     C                   eval      lock = *on
     C                   eval      kywhse = frmSLREC.slwhse
     C                   eval      kywhdp = frmSLREC.slwhdp
     C                   eval      kydisp = frmSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Transfer qty out of sent slot using qtyclstfrout.

     C                   exsr      qtyclstfrout
     C                   if        error
     C                   leavesr
     C                   endif
700 A
700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *on
700 AC                   exsr      writeLicAdj


     C                   eval      frm$Slot = $slot
     C                   eval      frm$Slot2 = $slot2

     *  Get and lock USR slot.

     C                   eval      lock = *on
     C                   eval      kywhse = toSLREC.slwhse
     C                   eval      kywhdp = toSLREC.slwhdp
     C                   eval      kydisp = toSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Now put qty into slot.

     C                   eval      $slentdu = *on
     C                   eval      $slentd = frmSLREC.slentd
     C                   eval      $slexpdu = *on
     C                   eval      $slexpd = frmSLREC.slexpd
     C                   exsr      qtyIn

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2
600fA
600fA*  Last of all, update license tracking.
600fA
600fAC                   exsr      trackLcnsTfr
640eA
640eA*  If From slot qty went negative,
640eA*    Then call sync routine to create *NG license.
640eA
640eAC                   if        lownewavl < 0
640eAC                   eval      $sldisp = frmSLREC.sldisp
640eAC                   exsr      synclcns
640eAC                   eval      $sldisp = toSLREC.sldisp
640eAC                   endif
610rA
610rA*  Now the last thing is to update FIFO info for From slot.
610rA
610rAC                   exsr      updSlotFifoFrm

     C     endtfr2usr    endsr

600fA*----------------------------------------------------------------
600fA*  trackAdjust    Update License information for an adjustment
600fA*----------------------------------------------------------------
600fA
600fAC     trackAdjust   begsr
600tAC                   eval      currRoutine = 'trackadjust'
600tAC                   exsr      phpgmV1V2V3s

     C                   exsr      clr$license

     C                   eval      $liLTrnU = *on
     C                   eval      $liLTrn = 0

     C                   if        $saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = $saAction
     C                   endif

     C                   eval      $liAQty1U = *on
     C                   eval      $liAQty1 = $saqty1
     C                   eval      $liAQty2 = $saqty2
     C                   eval      $liAQty3 = $saqty3

     C                   if        $saTrn#U
     C                   eval      $liTrn#U = *on
     C                   eval      $liTrn# = $saTrn#
     C                   endif

     C                   if        $saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = $saETrn#
     C                   endif

     C                   eval      $liLbl#U = *on
     C                   eval      $liLbl# = lblbl#

     C                   eval      $liToRQty1U = *on
     C                   eval      $liToRQty1 = $slstk1
     C                   eval      $liToRQty2 = $slstk2
     C                   eval      $liToRQty3 = $slstk3

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = $slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = $slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = $sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = $sldesg
     C                   eval      $liToAislu = *on
     C                   eval      $liToAisl = $slaisl
     C                   eval      $liToLocU = *on
     C                   eval      $liToLoc = $slloc
     C                   eval      $liToRlvlU = *on
     C                   eval      $liToRlvl = $slrlvl
     C                   eval      $liToHandU = *on
     C                   eval      $liToHand = $slhand
640yAC                   eval      $liToStatU = *on
640yAC                   eval      $liToStat = $slstat
     C                   eval      $liToBaseU = *on
     C                   eval      $liToBase = $sacdsp
     C                   eval      $liToItemU = *on
     C                   eval      $liToItem = #sentitem
     C                   eval      $liToITypeU = *on
     C                   eval      $liToIType = #senttype

700jA * xdk needs to get dates to licesne
710aDc*                  if        $psubcmd = '*ADJUSTOSS'  and
710aDc*                            to$slot.$slstat = 'XD'
710aAc                   if        ($psubcmd = '*ADJUSTOSS'  and
710aAc                             to$slot.$slstat = 'XD') or
710aAc                             ($psubcmd = '*ADJUST'  and
710aAc                             to$slot.$slstat = 'PR') or
750hAc                             ($psubcmd = '*ADJUST'  and
750hAc                             to$slot.$slexpd <> 0) or
710bAc                             ($psubcmd = '*ADJUSTIMP'  and
710bAc                             to$slot.$slstat = 'PR')
700jAc                   eval      $liToEntdU = '1'
700jAc                   eval      $liToEntD = to$slot.$slentd
700jAc                   if        to$slot.$slexpdu = '1'
700jAc                   eval      $liToExpdU = '1'
700jAc                   eval      $liToexpd = to$slot.$slexpd
700jAc                   endif
700jAC                   endif

650qA **  Pass Production Module variables
650qAc                   if        in$Slot2.$saMfgLneu
650qAc                   eval      $liMfgLneu = *on
650qAc                   eval      $liMfgLne = in$Slot2.$saMfgLne
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saGS1u
650qAc                   eval      $liGS1u = *on
650qAc                   eval      $liGS1 = in$Slot2.$saGS1
650qAc                   endif
710aAc
710aAc                   if        in$Slot2.$saRmUciU
710aAc                   eval      $liRmUCiU = *on
710aAc                   eval      $liRmUci = in$Slot2.$saRmUci
710aAc                   endif
650qAc
650qAc                   if        in$Slot2.$saPrdSitmu
650qAc                   eval      $liPrdSitmu = *on
650qAc                   eval      $liPrdSitm = in$Slot2.$saPrdSitm
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saSer#u
650qAc                   eval      $liSer#u = *on
650qAc                   eval      $liSer# = in$Slot2.$saSer#
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saPrdWgtu
650qAc                   eval      $liPrdWgtu = *on
650qAc                   eval      $liPrdWgt = in$Slot2.$saPrdWgt
650qAc                   else
650qAc                   if        in$Slot.$saCwtau
650qAc                   eval      $liPrdWgtu = *on
650qAc                   eval      $liPrdWgt = in$Slot.$saCwta
650qAc                   endif
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saPrdWou
650qAc                   eval      $liPrdWou = *on
650qAc                   eval      $liPrdWo = in$Slot2.$saPrdWo
650qAc                   endif
650qAc
650qAc                   if        in$Slot2.$saTareWgtu
650qAc                   eval      $liTareWgtu = *on
650qAc                   eval      $liTareWgt = in$Slot2.$saTareWgt
650qAc                   endif
650qAc
     C                   eval      $liToSItemU = *on
     C                   eval      $liToSItem = #slotitem
     C                   eval      $liToSITypeU = *on
     C                   eval      $liToSIType = #slottype

600zAC                   if        $saToLcnsU = *on
600zAC                   eval      $liToLcnsU = *on
710fAc                   if        savePRLic <> '*NONE'
710fAC                   eval      $saToLcns = savePRLic
710fAc                   endif
600zAC                   eval      $liToLcns = $saToLcns
600zAC                   endif

600zAC                   if        $saOLcnsU = *on
600zAC                   eval      $liOLcnsU = *on
600zAC                   eval      $liOLcns = $saOLcns
600zAC                   endif

640zAC                   if        $saItmChgU = *on
640zAC                   eval      $liItmChgU = *on
640zAC                   eval      $liItmChg = $saItmChg
640zAC                   endif

     C                   if        in$Slot2.$saExcdU
     C                   eval      $liExcdU = *on
     C                   eval      $liExcd = in$Slot2.$saExcd
     C                   endif

720cA * UCI Tracking
720cAc                   if        in$Slot2.$saUCItsu
720cAC                   eval      $liUCItsu = *on
720cAC                   eval      $liUCIts = in$Slot2.$saUCIts
720cAc                   endif

720cA * UCI Tracking - adjustment type
720cAc                   if        in$Slot2.$saUCItypeu
720cAC                   eval      $liUCItypeu = *on
720cAC                   eval      $liUCItype = in$Slot2.$saUCItype
720cAc                   endif

740fAc                   if        $psubcmd = '*ADJUSTORD'
740fAc                             and $saToOrdU = *on
740fAc                   eval      $liToOrdU = *on
740fAc                   eval      $liToOrd = $saToOrd
740fAc                   endif

     C                   eval      $dricommand = 'DRILICENSE'
650pAC                   if        $psubcmd = '*ADJUSTREV'
650pAC                   eval      $drisubcmd  = '%ADJSLTREV'
650pAC                   else
     C                   eval      $drisubcmd  = '%ADJSLTDTE'
650pAC                   endif
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

601aA*  See if slot FIFO info needs to be updated from licenses
601aA
601aAC                   exsr      updSlotFifo

     C                   endsr

601aA*----------------------------------------------------------------
601aA*  trackLcnsFifo   Update license FIFO information for a slot
601aA*----------------------------------------------------------------
601aA
601aAC     trackLcnsFifo begsr
     C                   eval      currRoutine = 'tracklcnsfifo'
     C                   exsr      phpgmV1V2V3s

     C                   exsr      clr$license

     C                   eval      $liLTrnU = *on
     C                   eval      $liLTrn = 0

     C                   if        in$Slot2.$saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = in$Slot2.$saAction
     C                   endif

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = to$Slot.$slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = to$Slot.$slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = to$Slot.$sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = to$Slot.$sldesg
     C                   eval      $liToAislu = *on
     C                   eval      $liToAisl = to$Slot.$slaisl
     C                   eval      $liToLocU = *on
     C                   eval      $liToLoc = to$Slot.$slloc
     C                   eval      $liToRlvlU = *on
     C                   eval      $liToRlvl = to$Slot.$slrlvl
     C                   eval      $liToHandU = *on
     C                   eval      $liToHand = to$Slot.$slhand
640yAC                   eval      $liToStatU = *on
640yAC                   eval      $liToStat = to$Slot.$slStat
     C                   eval      $liToItemU = *on
     C                   eval      $liToItem = to$Slot.$slitem

     C                   eval      $liToSItemU = *on
     C                   eval      $liToSItem = to$Slot.$slitem
     C                   eval      $liToPrtyU = *on
     C                   eval      $liToPrty = to$Slot.$slprty
     C                   eval      $liToEntDU = *on
     C                   eval      $liToEntD = to$Slot.$slentd
     C                   eval      $liToExpDU = *on
     C                   eval      $liToExpD = to$Slot.$slexpd

640zAC                   if        $saItmChgU = *on
640zAC                   eval      $liItmChgU = *on
640zAC                   eval      $liItmChg = $saItmChg
640zAC                   endif

     C                   eval      $liExcd = 'CHGFIFO'

     C                   eval      $dricommand = 'DRILICENSE'
     C                   eval      $drisubcmd  = '%CHGSLTFIF'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     *  See if slot FIFO info needs to be updated from licenses

     C                   exsr      updSlotFifo

     C                   endsr

640yA*----------------------------------------------------------------
640yA*  trackLcnsStat   Send slot status change to DRILICENSE
640yA *----------------------------------------------------------------
640yA
640yAC     trackLcnsStat begsr
     C                   eval      currRoutine = 'tracklcnsstat'
     C                   exsr      phpgmV1V2V3s

     C                   exsr      clr$license

     C                   eval      $liLTrnU = *on
     C                   eval      $liLTrn = 0

     C                   eval      $liActionU = *on
     C                   eval      $liAction = 'STS'

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = to$Slot.$slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = to$Slot.$slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = to$Slot.$sldisp
     C                   eval      $liToAislu = *on
     C                   eval      $liToAisl = to$Slot.$slaisl
     C                   eval      $liToLocU = *on
     C                   eval      $liToLoc = to$Slot.$slloc
     C                   eval      $liToRlvlU = *on
     C                   eval      $liToRlvl = to$Slot.$slrlvl
     C                   eval      $liToHandU = *on
     C                   eval      $liToHand = to$Slot.$slhand
     C                   eval      $liToStatU = *on
     C                   eval      $liToStat = to$Slot.$slstat
     C                   eval      $liFrmStatU = *on
     C                   eval      $liFrmStat = origStat
     C                   eval      $liToItemU = *on
     C                   eval      $liToItem = to$Slot.$slitem

     C                   eval      $liToSItemU = *on
     C                   eval      $liToSItem = to$Slot.$slitem
     C                   eval      $liToPrtyU = *on
     C                   eval      $liToPrty = to$Slot.$slprty
     C                   eval      $liToEntDU = *on
     C                   eval      $liToEntD = to$Slot.$slentd
     C                   eval      $liToExpDU = *on
     C                   eval      $liToExpD = to$Slot.$slexpd

640zAC                   if        $saItmChgU = *on
640zAC                   eval      $liItmChgU = *on
640zAC                   eval      $liItmChg = $saItmChg
640zAC                   endif

     C                   eval      $liExcd = 'CHGSTAT'

     C                   eval      $dricommand = 'DRILICENSE'
     C                   eval      $drisubcmd  = '%CHGSLTSTS'
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     C                   endsr

600fA*----------------------------------------------------------------
600fA*  trackLcnsTfr    Transfer license
600fA*----------------------------------------------------------------
600fA
600fAC     trackLcnsTfr  begsr
600tAC                   eval      currRoutine = 'tracklcnstfr'
600tAC                   exsr      phpgmV1V2V3s

     *  Initialize parms

     C                   exsr      clr$license

     *  Fill in general fields


     C                   eval      $liLTrnU = *on
     C                   eval      $liLTrn = 0

     C                   if        in$Slot2.$saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = in$Slot2.$saAction
     C                   endif

     C                   eval      $liAQty1U = *on
610bDC**                 eval      $liAQty1 = in$Slot.$saqty1
610bDC**                 eval      $liAQty2 = in$Slot.$saqty2
610bDC**                 eval      $liAQty3 = in$Slot.$saqty3
610fDC**                 eval      $liAQty1 = $saqty1
610fDC**                 eval      $liAQty2 = $saqty2
610fDC**                 eval      $liAQty3 = $saqty3
640fMC                   eval      $liAQty1 = frm$Slot.$saqty1
640fMC                   eval      $liAQty2 = frm$Slot.$saqty2
640fMC                   eval      $liAQty3 = frm$Slot.$saqty3

     C                   if        in$Slot.$saTrn#U
     C                   eval      $liTrn#U = *on
     C                   eval      $liTrn# = in$Slot.$saTrn#
     C                   endif

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   if        in$Slot2.$saLbl#U
     C                   eval      $liLbl#U = *on
     C                   eval      $liLbl# = in$Slot2.$saLbl#
     C                   endif

     C                   if        in$Slot2.$saOLcnsU
     C                   eval      $liOLcnsU = *on
     C                   eval      $liOLcns = in$Slot2.$saOLcns
     C                   endif

     *  Fill in To fields

     C                   if        in$Slot2.$saToLcnsU
     C                   eval      $liToLcnsU = *on
     C                   eval      $liToLcns = in$Slot2.$saToLcns
     C                   endif

     C                   if        in$Slot2.$saToVrfyU
     C                   eval      $liToVrfyU = *on
     C                   eval      $liToVrfy = in$Slot2.$saToVrfy
     C                   endif

     C                   eval      $liToRQty1U = *on
     C                   eval      $liToRQty1 = to$Slot.$slstk1
     C                   eval      $liToRQty2 = to$Slot.$slstk2
     C                   eval      $liToRQty3 = to$Slot.$slstk3

     C                   if        in$Slot2.$saToPosU
     C                   eval      $liToPosU = *on
     C                   eval      $liToPos = in$Slot2.$saToPos
     C                   endif

     C                   eval      $liToCodeu = *on
     C                   eval      $liToCode = in$Slot2.$saToCode

     C                   eval      $liToAreaU = *on
     C                   eval      $liToArea = in$Slot2.$saToArea

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = to$Slot.$slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = to$Slot.$slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = to$Slot.$sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = to$Slot.$sldesg
     C                   eval      $liToAislu = *on
     C                   eval      $liToAisl = to$Slot.$slaisl
     C                   eval      $liToLocU = *on
     C                   eval      $liToLoc = to$Slot.$slloc
     C                   eval      $liToRlvlU = *on
     C                   eval      $liToRlvl = to$Slot.$slrlvl
     C                   eval      $liToHandU = *on
     C                   eval      $liToHand = to$Slot.$slhand
640yAC                   eval      $liToStatU = *on
640yAC                   eval      $liToStat = to$Slot.$slstat
     C                   eval      $liToBaseU = *on
     C                   eval      $liToBase = to$Slot.$sacdsp
     C                   eval      $liToItemU = *on
601gDC**                 eval      $liToItem = #sentitem
601gMC                   eval      $liToItem = #tosentitem
     C                   eval      $liToITypeU = *on
601gDC**                 eval      $liToIType = #senttype
601gMC                   eval      $liToIType = #tosenttype

     C                   eval      $liToSItemU = *on
601gDC**                 eval      $liToSItem = #slotitem
601gMC                   eval      $liToSItem = #toitem
     C                   eval      $liToSITypeU = *on
601gDC**                 eval      $liToSIType = #slottype
601gMC                   eval      $liToSIType = #totype
640rDC*                  eval      $liToPrtyU = *on
640rMC                   eval      $liToPrtyU = in$Slot.$slprtyu
640rDC*                  eval      $liToPrty = to$Slot.$slprty
640rMC                   eval      $liToPrty = in$Slot.$slprty

     *  Fill in From fields

     C                   if        in$Slot2.$saToLcnsU
     C                   eval      $liFrmNewLcnsU = *on
     C                   eval      $liFrmNewLcns = in$Slot2.$saToLcns
     C                   endif

     C                   if        in$Slot.$saFrmLcnsU
     C                   eval      $liFrmOldLcnsU = *on
     C                   eval      $liFrmOldLcns = in$Slot.$saFrmLcns
     C                   else
640fAC                   if        in$Slot2.$saToLcnsU
     C                   eval      $liFrmOldLcnsU = *on
     C                   eval      $liFrmOldLcns = in$Slot2.$saToLcns
640fAC                   endif
     C                   endif

     C                   if        in$Slot.$saFrmVrfyU
     C                   eval      $liFrmVrfyU = *on
     C                   eval      $liFrmVrfy = in$Slot.$saFrmVrfy
     C                   else
640fAC                   if        in$Slot2.$saToVrfyU
     C                   eval      $liFrmVrfyU = *on
     C                   eval      $liFrmVrfy = in$Slot2.$saToVrfy
640fAC                   endif
     C                   endif

     C                   eval      $liFrmRQty1U = *on
     C                   eval      $liFrmRQty1 = frm$Slot.$slstk1
     C                   eval      $liFrmRQty2 = frm$Slot.$slstk2
     C                   eval      $liFrmRQty3 = frm$Slot.$slstk3

     C                   eval      $liFrmPosU = *on
     C                   eval      $liFrmPos = frm$Slot2.$saToPos

     C                   eval      $liFrmWhseu = *on
     C                   eval      $liFrmWhse = frm$Slot.$slwhse
     C                   eval      $liFrmWhdpU = *on
     C                   eval      $liFrmWhdp = frm$Slot.$slwhdp
     C                   eval      $liFrmDispU = *on
     C                   eval      $liFrmDisp = frm$Slot.$sldisp
650aAC                   eval      $liFrmDesgU = *on
650aAC                   eval      $liFrmDesg = frm$Slot.$sldesg
     C                   eval      $liFrmAislu = *on
     C                   eval      $liFrmAisl = frm$Slot.$slaisl
     C                   eval      $liFrmLocU = *on
     C                   eval      $liFrmLoc = frm$Slot.$slloc
     C                   eval      $liFrmRlvlU = *on
     C                   eval      $liFrmRlvl = frm$Slot.$slrlvl
     C                   eval      $liFrmHandU = *on
     C                   eval      $liFrmHand = frm$Slot.$slhand
     C                   eval      $liFrmBaseU = *on
     C                   eval      $liFrmBase = frm$Slot.$sacdsp
     C                   eval      $liFrmItemU = *on
601gDC**                 eval      $liFrmItem = #csentitem
601gMC                   eval      $liFrmItem = #fromsentitem
     C                   eval      $liFrmITypeU = *on
601gDC**                 eval      $liFrmIType = #csenttype
601gMC                   eval      $liFrmIType = #fromsenttype

     C                   eval      $liFrmSItemU = *on
601gDC**                 eval      $liFrmSItem = #cslotitem
601gMC                   eval      $liFrmSItem = #fromitem
     C                   eval      $liFrmSITypeU = *on
601gDC**                 eval      $liFrmSIType = #cslottype
601gMC                   eval      $liFrmSIType = #fromtype

     C                   eval      $liPullLcnsU = in$Slot2.$saPullLcnsU
     C                   eval      $liPullLcns = in$Slot2.$saPullLcns

640zAC                   if        $saItmChgU = *on
640zAC                   eval      $liItmChgU = *on
640zAC                   eval      $liItmChg = $saItmChg
640zAC                   endif

     C                   if        in$Slot2.$saExcdU
     C                   eval      $liExcdU = *on
     C                   eval      $liExcd = in$Slot2.$saExcd
     C                   endif
650qA
650qAC                   if        in$Slot2.$saPrdWgtu
650qAC                   eval      $liPrdWgtu = *on
650qAC                   eval      $liPrdWgt = in$Slot2.$saPrdWgt
650qAc                   else
650qAc                   if        in$Slot.$saCwtau
650qAc                   eval      $liPrdWgtu = *on
650qAc                   eval      $liPrdWgt = in$Slot.$saCwta
650qAc                   endif
650qAC                   endif
650qA
650qAC                   if        in$Slot2.$saSer#u
650qAC                   eval      $liSer#u = *on
650qAC                   eval      $liSer# = in$Slot2.$saSer#
650qAC                   endif
650qA
650qAC                   if        in$Slot2.$sags1u
650qAC                   eval      $liGs1u = *on
650qAC                   eval      $liGs1 = in$Slot2.$saGs1
650qAC                   endif
710aA
710aAC                   if        in$Slot2.$saRmUciU
710aAC                   eval      $liRmUCiU = *on
710aAC                   eval      $liRmUci = in$Slot2.$saRmUci
710aAC                   endif
650qA
650qAC                   if        in$Slot2.$saMfgLneu
650qAC                   eval      $liMfgLneu = *on
650qAC                   eval      $liMfgLne = in$Slot2.$saMfgLne
650qAC                   endif

720cA * UCI Tracking
720cAc                   if        in$Slot2.$saUCItsu
720cAC                   eval      $liUCItsu = *on
720cAC                   eval      $liUCIts = in$Slot2.$saUCIts
720cAc                   endif

720cA * UCI Tracking  - adjustment type
720cAc                   if        in$Slot2.$saUCItypeu
720cAC                   eval      $liUCItypeu = *on
720cAC                   eval      $liUCItype = in$Slot2.$saUCItype
720cAc                   endif


CBIcA * Need to send new expiration date for CBI CLR to TFR.
CBIcAc                   if        client = cheney and $liItmChgU
CBIcAc                             and CBIClrFrz
CBIcAc                   eval      $litoexpd = calpdktexpd
CBIcAc                   eval      $litoexpdu = *on
CBIcAc                   endif
     C                   eval      $dricommand = 'DRILICENSE'
610sDC**                 if        frm$Slot.$slaisl <> 'USR'
610sDC**                           and frm$Slot.$slpick = 'Y'
610sAC                   if        $psubcmd = '*TFR2USRR'
610iAC                   eval      $drisubcmd  = '%TFRSLTREV'
610iAC                   else
     C                   eval      $drisubcmd  = '%TFRSLTDTE'
610iAC                   endif
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     C                   eval      $saToLcns = $liToLcns

601aA*  See if slot FIFO info needs to be updated from licenses
601aA
601aAC                   exsr      updSlotFifo

     C                   endsr

600fA*----------------------------------------------------------------
600fA*  trackLcnsTo  Update To license information for a license
600fA*----------------------------------------------------------------
600fA
600fAC     trackLcnsTo   begsr
600tAC                   eval      currRoutine = 'tracklcnsto'
600tAC                   exsr      phpgmV1V2V3s

     C                   exsr      clr$license

     C                   eval      $liLTrnU = *on
     C                   eval      $liLTrn = 0

     C                   if        in$Slot2.$saActionU
     C                   eval      $liActionU = *on
     C                   eval      $liAction = in$Slot2.$saAction
     C                   endif

     C                   eval      $liAQty1U = *on
     C                   eval      $liAQty1 = in$Slot.$saqty1
     C                   eval      $liAQty2 = in$Slot.$saqty2
     C                   eval      $liAQty3 = in$Slot.$saqty3

     C                   if        in$Slot.$saTrn#U
     C                   eval      $liTrn#U = *on
     C                   eval      $liTrn# = in$Slot.$saTrn#
     C                   endif

     C                   if        in$Slot2.$saETrn#U
     C                   eval      $liETrn#U = *on
     C                   eval      $liETrn# = in$Slot2.$saETrn#
     C                   endif

     C                   if        in$Slot2.$saLbl#U
     C                   eval      $liLbl#U = *on
     C                   eval      $liLbl# = in$Slot2.$saLbl#
     C                   endif

     C                   if        in$Slot2.$saOLcnsU
     C                   eval      $liOLcnsU = *on
     C                   eval      $liOLcns = in$Slot2.$saOLcns
     C                   endif

     C                   if        in$Slot.$saFrmLcnsU
     C                   eval      $liFrmOldLcnsU = *on
     C                   eval      $liFrmOldLcns = in$Slot.$saFrmLcns
     C                   endif

     C                   if        in$Slot2.$saToLcnsU
     C                   eval      $liToLcnsU = *on
     C                   eval      $liToLcns = in$Slot2.$saToLcns
     C                   endif

     C                   if        in$Slot2.$saToVrfyU
     C                   eval      $liToVrfyU = *on
     C                   eval      $liToVrfy = in$Slot2.$saToVrfy
     C                   endif

     C                   if        in$Slot2.$saToPosU
     C                   eval      $liToPosU = *on
     C                   eval      $liToPos = in$Slot2.$saToPos
     C                   endif

     C                   eval      $liToRQty1U = *on
651bAc                   if        $psubcmd = '*STUFFIT'
710bAc                             or $psubcmd = '*ADJUSTIMP'
740dAc                             or $psubcmd = '*QTY2PUT0' and
740dAc                                $liAction = 'LAC'
651bAC                   eval      $liToRQty1 = in$Slot.$saqty1
651bAC                   eval      $liToRQty2 = in$Slot.$saqty2
651bAC                   eval      $liToRQty3 = in$Slot.$saqty3
651bAc                   else
     C                   eval      $liToRQty1 = to$Slot.$slstk1
     C                   eval      $liToRQty2 = to$Slot.$slstk2
     C                   eval      $liToRQty3 = to$Slot.$slstk3
651bAc                   endif

     C***                if        in$Slot2.$saToCodeu
     C                   eval      $liToCodeu = *on
     C                   eval      $liToCode = in$Slot2.$saToCode
     C***                endif

     C***                if        in$Slot2.$saToAreaU
     C                   eval      $liToAreaU = *on
     C                   eval      $liToArea = in$Slot2.$saToArea
     C***                endif

     C                   eval      $liToWhseu = *on
     C                   eval      $liToWhse = to$Slot.$slwhse
     C                   eval      $liToWhdpU = *on
     C                   eval      $liToWhdp = to$Slot.$slwhdp
     C                   eval      $liToDispU = *on
     C                   eval      $liToDisp = to$Slot.$sldisp
650aAC                   eval      $liToDesgU = *on
650aAC                   eval      $liToDesg = to$Slot.$sldesg
     C                   eval      $liToAislu = *on
     C                   eval      $liToAisl = to$Slot.$slaisl
     C                   eval      $liToLocU = *on
     C                   eval      $liToLoc = to$Slot.$slloc
     C                   eval      $liToRlvlU = *on
     C                   eval      $liToRlvl = to$Slot.$slrlvl
     C                   eval      $liToHandU = *on
     C                   eval      $liToHand = to$Slot.$slhand
640yAC                   eval      $liToStatU = *on
640yAC                   eval      $liToStat = to$Slot.$slstat
     C                   eval      $liToBaseU = *on
     C                   eval      $liToBase = to$Slot.$sacdsp
     C                   eval      $liToItemU = *on
     C                   eval      $liToItem = #sentitem
     C                   eval      $liToITypeU = *on
     C                   eval      $liToIType = #senttype

     C                   eval      $liToSItemU = *on
     C                   eval      $liToSItem = #slotitem
     C                   eval      $liToSITypeU = *on
     C                   eval      $liToSIType = #slottype
     C                   eval      $liToPrtyU = *on
     C                   eval      $liToPrty = to$Slot.$slprty
730dAc                   if        $psubcmd = '*ADJUSTIMP'
730dAC                   eval      $liToEntDU = *on
730dAC                   eval      $liToEntD = in$Slot.$slentd
730dAc                   else
     C                   eval      $liToEntDU = *on
     C                   eval      $liToEntD = to$Slot.$slentd
730dAc                   endif
710eAc                   if        $psubcmd = '*ADJUSTIMP'
710eAC                   eval      $liToExpDU = *on
710eAC                   eval      $liToExpD = in$Slot.$slexpd
710eAc                   else
     C                   eval      $liToExpDU = *on
     C                   eval      $liToExpD = to$Slot.$slexpd
710eAc                   endif

640zAC                   if        $saItmChgU = *on
640zAC                   eval      $liItmChgU = *on
640zAC                   eval      $liItmChg = $saItmChg
640zAC                   endif

     C                   if        in$Slot2.$saExcdU
     C                   eval      $liExcdU = *on
     C                   eval      $liExcd = in$Slot2.$saExcd
     C                   endif

     C                   eval      $dricommand = 'DRILICENSE'
710hAc                   if        $psubcmd = '*OSSIN' and
710haC                             $litolcns = ' '
710hAc** we don't want to create a licactive record with a blank
710hAc** license. allowing the user to transfer existing license
710hAc** to off site storage requires we omit this step.
710hAc                   else
600rAC                   if        $psubcmd = '*OSSIN'
611eAC                             or $psubcmd = '*PREIN'
700dAC                             or $psubcmd = '*AMPIN'
610gAC                             or $psubcmd = '*QTY2PUT0'
600rAC                   eval      $drisubcmd  = '%SETLCNS0'
600rAC                   else
     C                   eval      $drisubcmd  = '%SETLCNS'
600rAC                   endif
     C                   eval      $drisys2upd = 'D'
     C                   exsr      zzzdrimain3

     *    If the license comes back changed, pass it back to calling pgm.
     *    Note, we are assuming that the in$Slot2 fields have the $slot2 info.

     C                   if        in$Slot2.$saToLcns <> $liToLcns
     C                   eval      $saToLcns = $liToLcns
     C                   endif

601aA*  See if slot FIFO info needs to be updated from licenses
601aA
601aAC                   exsr      updSlotFifo
710hAc                   endif

     C                   endsr

600dA*----------------------------------------------------------------
600dA*  usr2oss   Transfer USR qty into OSS slot
600dA*----------------------------------------------------------------
600dA
600dAC     usr2oss       begsr
600tAC                   eval      currRoutine = 'usr2oss'
600tAC                   exsr      phpgmV1V2V3s

     *  Save necessary fields.

     C                   eval      frmSLREC = slrecds

     *  Create OSS slot.

     C                   exsr      getslot2USR
     C                   exsr      crtOSS
     C                   if        error
     C                   leavesr
     C                   endif

     *  Save OSS slot information.

     C                   eval      toSLREC = slrecds

     *  Get and lock 'From' slot.

     C                   eval      $slaisl = frmSLREC.slaisl
     C                   eval      $slrlvl = frmSLREC.slrlvl
     C                   eval      $sldisp = frmSLREC.sldisp

     C                   eval      lock = *on
     C                   eval      kywhse = frmSLREC.slwhse
     C                   eval      kywhdp = frmSLREC.slwhdp
     C                   eval      kydisp = frmSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Transfer qty out of USR slot.

600zDC**                 exsr      qtyOut
600zMC                   exsr      qtyOutWhse
     C                   if        error
     C                   leavesr
     C                   endif

     C                   eval      frm$Slot = $slot
     C                   eval      frm$Slot2 = $slot2

     *  Get and lock the OSS slot to be used.

     C                   eval      lock = *on
     C                   eval      kywhse = toSLREC.slwhse
     C                   eval      kywhdp = toSLREC.slwhdp
     C                   eval      kydisp = toSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Now put qty into OSS slot.

     C                   eval      $slentdu = *on
     C                   eval      $slentd = frmSLREC.slentd
     C                   eval      $slexpdu = *on
     C                   eval      $slexpd = frmSLREC.slexpd
600zDC**                 exsr      qtyIn
600zMC                   exsr      qtyInWhse

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2
600fA
600fA*  Last of all, update license tracking.
600fA
600fAC                   exsr      trackLcnsTfr

     C     endusr2oss    endsr

600dA*----------------------------------------------------------------
600dA*  usr2rcv   Transfer USR qty into RCV slot
600dA*----------------------------------------------------------------
600dA
600dAC     usr2rcv       begsr
600tAC                   eval      currRoutine = 'usr2rcv'
600tAC                   exsr      phpgmV1V2V3s

     *  Save necessary fields.

     C                   eval      frmSLREC = slrecds

     *  Create RCV slot.

     C                   exsr      getslot2USR
     C                   exsr      crtRCV
     C                   if        error
     C                   leavesr
     C                   endif

     *  Save RCV slot information.

     C                   eval      toSLREC = slrecds

     *  Get and lock 'From' slot.

     C                   eval      $slaisl = frmSLREC.slaisl
     C                   eval      $slrlvl = frmSLREC.slrlvl
     C                   eval      $sldisp = frmSLREC.sldisp

     C                   eval      lock = *on
     C                   eval      kywhse = frmSLREC.slwhse
     C                   eval      kywhdp = frmSLREC.slwhdp
     C                   eval      kydisp = frmSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Transfer qty out of USR slot.

600zDC**                 exsr      qtyOut
600zMC                   exsr      qtyOutWhse
     C                   if        error
     C                   leavesr
     C                   endif

     C                   eval      frm$Slot = $slot
     C                   eval      frm$Slot2 = $slot2

     *  Get and lock the RCV slot to be used.

     C                   eval      lock = *on
     C                   eval      kywhse = toSLREC.slwhse
     C                   eval      kywhdp = toSLREC.slwhdp
     C                   eval      kydisp = toSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Now put qty into RCV slot.

     C                   eval      $slentdu = *on
     C                   eval      $slentd = frmSLREC.slentd
     C                   eval      $slexpdu = *on
     C                   eval      $slexpd = frmSLREC.slexpd
600zDC**                 exsr      qtyIn
600zMC                   exsr      qtyInWhse
700 A
700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *off
700 AC                   exsr      writeLicAdj

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2
600fA
600fA*  Last of all, update license tracking.
600fA
600fAC                   exsr      trackLcnsTfr

     C     endusr2rcv    endsr

720 A*----------------------------------------------------------------
720 A*  usr2rpa   Transfer USR qty into RPA slot
720 A*----------------------------------------------------------------
720 A
720 AC     usr2rpa       begsr
720 AC                   eval      currRoutine = 'usr2rpa'
720 AC                   exsr      phpgmV1V2V3s
720 A
720 A*  Save necessary fields.
720 A
     C*   Saving from sldisp which has USR slot coming in
720 AC                   eval      frmSLREC = slrecds
720 A
720 A*  Create RPA slot.
720 A
720 Ac*  If RPA slot passed in is found then use it, otherwise get new RPADOCK virtual
720 AC                   eval      lock = *on
720 AC                   eval      kywhse = frmSLREC.slwhse
720 AC                   eval      kywhdp = frmSLREC.slwhdp
720 AC                   eval      kydisp = $saPullDisp
720 AC                   eval      check4err = *on
720 AC                   exsr      getslot2
720 AC                   if        error
720 AC                   exsr      getslot2USR
720 AC                   exsr      crtRPA
720 AC                   if        error
720 AC                   leavesr
720 AC                   endif
720 AC                   endif
720 A
720 A*  Save RCV slot information.
720 A
     C*  save RPADOCK slot fields in toSLREC
720 AC                   eval      toSLREC = slrecds
720 A
720 A*  Get and lock 'From' slot.
720 A
720 AC                   eval      $slaisl = frmSLREC.slaisl
720 AC                   eval      $slrlvl = frmSLREC.slrlvl
720 AC                   eval      $sldisp = frmSLREC.sldisp
720 A
720 AC                   eval      lock = *on
720 AC                   eval      kywhse = frmSLREC.slwhse
720 AC                   eval      kywhdp = frmSLREC.slwhdp
720 AC                   eval      kydisp = frmSLREC.sldisp
720 AC                   eval      check4err = *on
720 AC                   exsr      getslot2
720 AC                   if        error
720 AC                   eval      $slwhdpe = '1'
720 AC                   eval      $sldispe = '1'
720 AC                   leavesr
720 AC                   endif
720 A
720 A*  Transfer qty out of USR slot.
720 A
720 AC**                 exsr      qtyOut
720 AC                   exsr      qtyOutWhse
720 AC                   if        error
720 AC                   leavesr
720 AC                   endif
720 A
720 AC                   eval      frm$Slot = $slot
720 AC                   eval      frm$Slot2 = $slot2
720 A
720 A*  Get and lock the RPA slot to be used.
720 A
720 AC                   eval      lock = *on
720 AC                   eval      kywhse = toSLREC.slwhse
720 AC                   eval      kywhdp = toSLREC.slwhdp
720 AC                   eval      kydisp = toSLREC.sldisp
720 AC                   eval      check4err = *on
720 AC                   exsr      getslot2
720 AC                   if        error
720 AC                   eval      $slwhdpe = '1'
720 AC                   eval      $sldispe = '1'
720 AC                   leavesr
720 AC                   endif
720 A
720 A*  Now put qty into RCV slot.
720 A
720 AC                   eval      $slentdu = *on
720 AC                   eval      $slentd = frmSLREC.slentd
720 AC                   eval      $slexpdu = *on
720 AC                   eval      $slexpd = frmSLREC.slexpd
720 AC**                 exsr      qtyIn
720 AC                   exsr      qtyInWhse
720 A
720 A*  Write LicAdj record.
720 AC                   eval      negLicAdj = *off
720 AC                   exsr      writeLicAdj
720 A
720 AC                   eval      to$Slot = $slot
720 AC                   eval      to$Slot2 = $slot2
720 A
720 A*  Last of all, update license tracking.
720 A
720 AC                   exsr      trackLcnsTfr
720 A
720 AC     endusr2rpa    endsr

700sA*----------------------------------------------------------------
700sA*  usr2rtno  Transfer USR qty into RTN slot
700sA*----------------------------------------------------------------
700sA
700sAC     usr2rtno      begsr
700sAC                   eval      currRoutine = 'usr2rcv'
700sAC                   exsr      phpgmV1V2V3s

700sA*  Save necessary fields.

700sAC                   eval      frmSLREC = slrecds

700sA*  Create RTN slot.

700sAC                   exsr      getslot2USR
700sAC                   exsr      crtRTNO
700sAC                   if        error
700sAC                   leavesr
700sAC                   endif

700sA*  Save RTN slot information.

700sAC                   eval      toSLREC = slrecds

700sA*  Get and lock 'From' slot.

700sAC                   eval      $slaisl = frmSLREC.slaisl
700sAC                   eval      $slrlvl = frmSLREC.slrlvl
700sAC                   eval      $sldisp = frmSLREC.sldisp

700sAC                   eval      lock = *on
700sAC                   eval      kywhse = frmSLREC.slwhse
700sAC                   eval      kywhdp = frmSLREC.slwhdp
700sAC                   eval      kydisp = frmSLREC.sldisp
700sAC                   eval      check4err = *on
700sAC                   exsr      getslot2
700sAC                   if        error
700sAC                   eval      $slwhdpe = '1'
700sAC                   eval      $sldispe = '1'
700sAC                   leavesr
700sAC                   endif

700sA*  Transfer qty out of USR slot.

700sAC                   exsr      qtyOutWhse
700sAC                   if        error
700sAC                   leavesr
700sAC                   endif

700sAC                   eval      frm$Slot = $slot
700sAC                   eval      frm$Slot2 = $slot2

700sA*  Get and lock the RTN slot to be used.

700sAC                   eval      lock = *on
700sAC                   eval      kywhse = toSLREC.slwhse
700sAC                   eval      kywhdp = toSLREC.slwhdp
700sAC                   eval      kydisp = toSLREC.sldisp
700sAC                   eval      check4err = *on
700sAC                   exsr      getslot2
700sAC                   if        error
700sAC                   eval      $slwhdpe = '1'
700sAC                   eval      $sldispe = '1'
700sAC                   leavesr
700sAC                   endif

700sA*  Now put qty into RTN slot.

700sAC                   eval      $slentdu = *on
700sAC                   eval      $slentd = frmSLREC.slentd
700sAC                   eval      $slexpdu = *on
700sAC                   eval      $slexpd = frmSLREC.slexpd
700sAC                   exsr      qtyInWhse
700sA
700sA*  Write LicAdj record.
700sAC                   eval      negLicAdj = *off
700sAC                   exsr      writeLicAdj

700sAC                   eval      to$Slot = $slot
700sAC                   eval      to$Slot2 = $slot2
700sA
700sA*  Last of all, update license tracking.
700sA
700sAC                   exsr      trackLcnsTfr

700sAC     endusr2rtno   endsr

730eA*----------------------------------------------------------------
730eA*  usr2rwo   Transfer USR qty into RWO slot
730eA*----------------------------------------------------------------
730eA
730eAC     usr2rwo       begsr
730eAC                   eval      currRoutine = 'usr2rwo'
730eAC                   exsr      phpgmV1V2V3s

730eA*  Save necessary fields.

730eAC                   eval      frmSLREC = slrecds

730eA*  Create RWO slot.

730eAC                   exsr      getslot2USR
730eAC                   exsr      crtRWO
730eAC                   if        error
730eAC                   leavesr
730eAC                   endif

730eA*  Save RTN slot information.

730eAC                   eval      toSLREC = slrecds

730eA*  Get and lock 'From' slot.

730eAC                   eval      $slaisl = frmSLREC.slaisl
730eAC                   eval      $slrlvl = frmSLREC.slrlvl
730eAC                   eval      $sldisp = frmSLREC.sldisp

730eAC                   eval      lock = *on
730eAC                   eval      kywhse = frmSLREC.slwhse
730eAC                   eval      kywhdp = frmSLREC.slwhdp
730eAC                   eval      kydisp = frmSLREC.sldisp
730eAC                   eval      check4err = *on
730eAC                   exsr      getslot2
730eAC                   if        error
730eAC                   eval      $slwhdpe = '1'
730eAC                   eval      $sldispe = '1'
730eAC                   leavesr
730eAC                   endif

730eA*  Transfer qty out of USR slot.

730eAC                   exsr      qtyOutWhse
730eAC                   if        error
730eAC                   leavesr
730eAC                   endif

730eAC                   eval      frm$Slot = $slot
730eAC                   eval      frm$Slot2 = $slot2

730eA*  Get and lock the RWO slot to be used.

730eAC                   eval      lock = *on
730eAC                   eval      kywhse = toSLREC.slwhse
730eAC                   eval      kywhdp = toSLREC.slwhdp
730eAC                   eval      kydisp = toSLREC.sldisp
730eAC                   eval      check4err = *on
730eAC                   exsr      getslot2
730eAC                   if        error
730eAC                   eval      $slwhdpe = '1'
730eAC                   eval      $sldispe = '1'
730eAC                   leavesr
730eAC                   endif

730eA*  Now put qty into RWO slot.

730eAC                   eval      $slentdu = *on
730eAC                   eval      $slentd = frmSLREC.slentd
730eAC                   eval      $slexpdu = *on
730eAC                   eval      $slexpd = frmSLREC.slexpd
730eAC                   exsr      qtyInWhse
730eA
730eA*  Write LicAdj record.
730eAC                   eval      negLicAdj = *off
730eAC                   exsr      writeLicAdj

730eAC                   eval      to$Slot = $slot
730eAC                   eval      to$Slot2 = $slot2
730eA
730eA*  Last of all, update license tracking.
730eA
730eAC                   exsr      trackLcnsTfr

730eAC     endusr2rwo    endsr

600dA*----------------------------------------------------------------
600dA*  usr2slt   Transfer qty from USR slot into normal slot
600dA*----------------------------------------------------------------
600dA
600dAC     usr2slt       begsr
600tAC                   eval      currRoutine = 'usr2slt'
600tAC                   exsr      phpgmV1V2V3s

     *  Save RCV slot information.

     C                   eval      toSLREC = slrecds

     *  Get and lock USR slot.

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $sacwhd
     C                   eval      kydisp = $sacdsp
     C                   eval      lock = *on
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $preturn = 'INVLDUSLOT'
     C                   exsr      getmsg
     C                   eval      $sacwhde = '1'
     C                   leavesr
     C                   endif

     *  Transfer qty out of USR slot.

600zDC**                 exsr      qtyout
600zMC                   exsr      qtyOutWhse
     C                   if        error
     C                   leavesr
     C                   endif

     C                   eval      frm$Slot = $slot
     C                   eval      frm$Slot2 = $slot2

     *  Get and lock normal slot.

     C                   eval      lock = *on
     C                   eval      kywhse = toSLREC.slwhse
     C                   eval      kywhdp = toSLREC.slwhdp
     C                   eval      kydisp = toSLREC.sldisp
     C                   eval      lock = *on
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Now put qty into slot.

600yAC*****              if        frm$Slot.$slstat <> toSLREC.slstat
600yAC                   eval      diffStatus = *on
600yAC****               else
600yAC****               eval      diffStatus = *off
600yAC****               endif

     C                   exsr      qtyclsrcv
700 A
700 A*  Write LicAdj record.
700 AC*                  eval      negLicAdj = *off
700 AC*                  exsr      writeLicAdj
GFCbA*
GFCbAC                   if        client = Glazier
SFGeAC                             or client = SGC
FPR AC                             or client = FoodPro
GMMdAC                             or client = MenuMaker
GFCbA*
GFCbA*      Call Host interface pgm to update Host pick slot.
GFCbAC                   if            Slitem > ' '
GFCbAC                             and Slpick = 'Y'
GFCcAC                             and Slstat <> 'Z'
GFCcAC                             and Slstat <> 'V'
GFCcAC                             and Slstat <> 'XD'
FPRfA*
FPRfAC                             or client = FoodPro
FPRfAC                             and Slpick = 'N'
FPRfAC                             and (%subst(sldisp:1:4) = 'WHS2'
FPRfAC                               or %subst(sldisp:1:4) = 'WHS4')
FPRfAC                             and Slstat <> 'Z'
FPRfAC                             and Slstat <> 'V'
FPRfAC                             and Slstat <> 'XD'
GFCbA
GFCbA*  Get live status for item's department.
GFCbAC                   call      'CHKLIVE'
GFCdAC                   parm      slwhse        $cwhse
GFCbAC                   parm                    slwhdp
GFCbAC                   parm                    livestat          8
GFCbA
GFCbA*  If department is not live, then read next item.
GFCbAC                   if        livestat = '*LIVE'
GFCbA
GFCbAC                   eval      $rwhse = %editc(slwhse:'X')
GFCbAC                   call      'HIT735CL'
GFCbAC                   parm      '*UPDPCKSLT'  $rcmd            10
GFCbAC                   parm                    $rwhse            3
GFCbAC                   parm      slitem        $ritem           15
GFCbAC                   parm      sldisp        $rdisp           12
700 AC                   parm      slstat        $rstat
GFCbAC                   parm      ' '           $rrtn             8
GFCbA*
GFCbAC                   endif
GFCbA*
GFCbAC                   endif
GFCbA*
GFCbAC                   endif
GFCbA*

     *  Send back normal slot information.

     C                   exsr      slot2ds

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2
600fA
600fA*  Last of all, update license tracking.
600fA
600fAC                   exsr      trackLcnsTfr
700 A *
700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *off
700 AC                   exsr      writeLicAdj

     C                   endsr

600dA*----------------------------------------------------------------
600dA*  usr2stg   Transfer USR qty into STG slot
600dA*----------------------------------------------------------------
600dA
600dAC     usr2stg       begsr
600tAC                   eval      currRoutine = 'usr2stg'
600tAC                   exsr      phpgmV1V2V3s

     *  Save necessary fields.

     C                   eval      frmSLREC = slrecds

     *  Create STG slot.

     C                   exsr      getslot2USR
     C                   exsr      crtSTG
     C                   if        error
     C                   leavesr
     C                   endif

     *  Save STG slot information.

     C                   eval      toSLREC = slrecds

     *  Get and lock 'From' slot.

     C                   eval      $slaisl = frmSLREC.slaisl
     C                   eval      $slrlvl = frmSLREC.slrlvl
     C                   eval      $sldisp = frmSLREC.sldisp

     C                   eval      lock = *on
     C                   eval      kywhse = frmSLREC.slwhse
     C                   eval      kywhdp = frmSLREC.slwhdp
     C                   eval      kydisp = frmSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Transfer qty out of USR slot.

600zDC**                 exsr      qtyOut
600zMC                   exsr      qtyOutWhse
     C                   if        error
     C                   leavesr
     C                   endif

     C                   eval      frm$Slot = $slot
     C                   eval      frm$Slot2 = $slot2

     *  Get and lock the STG slot to be used.

     C                   eval      lock = *on
     C                   eval      kywhse = toSLREC.slwhse
     C                   eval      kywhdp = toSLREC.slwhdp
     C                   eval      kydisp = toSLREC.sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Now put qty into STG slot.

     C                   eval      $slentdu = *on
     C                   eval      $slentd = frmSLREC.slentd
     C                   eval      $slexpdu = *on
     C                   eval      $slexpd = frmSLREC.slexpd
600aDC**                 exsr      qtyIn
600zMC                   exsr      qtyInWhse

     C                   eval      to$Slot = $slot
     C                   eval      to$Slot2 = $slot2
600fA
600fA*  Last of all, update license tracking.
600fA
600fAC                   exsr      trackLcnsTfr

     C     endusr2stg    endsr

416cA*----------------------------------------------------------------
416cA*  Qtystock     Update stock quantites.
416cA*----------------------------------------------------------------
416cA
416cAC     qtystock      begsr
600tAC                   eval      currRoutine = 'qtystock'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtystk
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtystk
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update allocated quantites.

     C                   eval      slstk1 = slstk1 + $saqty1
     C                   eval      slstk2 = slstk2 + $saqty2
     C                   eval      slstk3 = slstk3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

610mA*    See if we should delete or update record.
610mA*    Delete record ...
610mA*      - When working with USR slot and all qty's are zero.
610mA
610mAC                   eval      deleteRec = *off
610mAC                   if        slaisl = aisleOSS
610mAC                             or slaisl = aisleRCV
700sAC                             or slaisl = aisleRTN
730eAC                             or slaisl = aisleRWO
720 AC                             or slaisl = aisleRPA
610mAC                             or slaisl = aisleSTG
610mAC                             or slaisl = aisleUSR
611lAC                             or slstyp = 'X'
610mAC                   exsr      checkallzero
610mAC                   if        allZero
610mAC                   eval      deleteRec = *on
610mAC                   endif
610mAC                   endif
DRYaAc                   if        client = dairyland
DRYaAc                             and slaisl = aisleOSS
DRYaAc                             and $psubcmd = '*ADJUSTOSS'
DRYaAc                             and slstat = 'O'
DRYaAc                   eval      slstat = 'A'
DRYaAc                   endif

     *    Update record.

611lA*    Change to always update record, then delete if necessary
611lA*    To allow cross dock slots to be zero verified.
610m C                   if        not deleteRec
611lAC                             or slstyp = 'X'
611lAC                             and deleteRec = *on
710oAC                             or slaisl = aisleOSS
     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtystk
     C                   endif
611lAC                   endif
610mA
610mA*    Or delete record.
610mA
611lAC                   if        deleteRec
611lAC                   if        slstyp = 'X'
710oAC                             or slaisl = aisleOSS
611lAC                   eval      getagain = *on
611lAC                   endif
611lDC**                 else
610mAC                   exsr      deleteslot
610mAC                   if        error
610mAC                   goto      endqtystk
610mAC                   endif
610mAC                   endif

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtystk
     C                   endif
510aA
510aA*  Update slot date quantities.
510aA
510aAC                   eval      $ucmd  = '*FIFO'
510aAC                   eval      $uqty1 = $saqty1
510aAC                   eval      $uqty2 = $saqty2
510aAC                   eval      $uqty3 = $saqty3
601aDC**                 exsr      updslotdte

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endqtystk     endsr

416cA*----------------------------------------------------------------
416cA*  qtytfrout    Update transfer quantities
416cA*----------------------------------------------------------------
416cA
416cAC     qtytfrout     begsr
600tAC                   eval      currRoutine = 'qtytfrout'
600tAC                   exsr      phpgmV1V2V3s

     *  Do extra verification ...
417dA
417dA*    Item type cannot be 'C'.
417dA
417dAC                   if        #slottype = 'C'
417dAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
417dAC                   eval      $preturn  = 'INVLDITYP'
417dAC                   exsr      getmsg
417dAC                   goto      endqtytfro
417dAC                   endif
417dA
417dA*    Corresponding item type cannot be 'C'.
417dA
417dAC                   if        #cslottype = 'C'
417dAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
417dAC                   eval      $preturn  = 'INVLDCITYP'
417dAC                   exsr      getmsg
417dAC                   goto      endqtytfro
417dAC                   endif

     *    Make sure that slot is active.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
500oDC*                  eval      $slwhdp = '1'
500oMC                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn  = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endqtytfro
     C                   endif

     *    Make sure that slot contains "slot" item.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endqtytfro
     C                   endif

640lA*    New available slot quantities cannot exceed 99,999
640lA
640lAC                   eval      qtytest = slavl1 - $saqty1
640lAC                   if        qtytest > 99999
640lAC                   eval      error = *on
640lAC                   eval      $saqty1e = '1'
640lAC                   eval      $preturn = 'ADJQTYMAX'
640lAC                   exsr      getmsg
640lAC                   goto      endqtytfro
640lAC                   endif

     *    Calculate new available slot quantities.

     C                   eval      newavlqty1  = slavl1 - $saqty1
     C                   eval      newavlqty2  = slavl2 - $saqty2
     C                   eval      newavlqty3  = slavl3 - $saqty3
640cAC                   eval      lownewavl = (newavlqty1*#slotumq2* #slotumq3)
640cAC                                       + (newavlqty2 * #slotumq3)
640cAC                                       + newavlqty3

     *    New available slot quantities cannot be negative ...
     *      when reducing the available qty ($saqty is positive)

500xAC                   if        $pprogram <> 'LT107'
640cDC*                  if        newavlqty1 < 0 and $saqty1 > 0 or
640cDC*                            newavlqty2 < 0 and $saqty2 > 0 or
640cDC*                            newavlqty3 < 0 and $saqty3 > 0
640cMC                   if        lownewavl < 0
     C                   eval      error = *on
     C                   eval      $saqty1e = '1'
     C                   eval      $saqty2e = '1'
     C                   eval      $saqty3e = '1'
     C                   eval      $preturn = 'NEGAVLSLT'
     C                   exsr      getmsg
     C                   goto      endqtytfro
     C                   endif
500xAC                   endif

     *    New warehouse available quantity cannot be negative ...
     *      when reducing the available qty ($saqty is positive)

     C                   if        $saqty1 > 0 or
     C                             $saqty2 > 0 or
     C                             $saqty3 > 0
500dDC**                 if        (lowwhavl - lowiaqty) < 0
500dDC**                 eval      error = *on
500dDC**                 eval      $saqty1e = '1'
500dDC**                 eval      $saqty2e = '1'
500dDC**                 eval      $saqty3e = '1'
500dDC**                 eval      $preturn = 'NEGAVLWHS'
500dDC**                 exsr      getmsg
500dDC**                 goto      endqtytfro
500dDC**                 endif
     C                   endif

     *    Skip actual update when verifying.
600fA*      Set $saqty's to newavlqty's so calling program can determine
600fA*      if slot will go to zero.

     C                   if        $psubcmd = '*VERIFYTFO'
417hAC                             or $psubcmd = '*VERIFYLTO'
417hAC                             or $psubcmd = '*VERIFYPRO'
417hAC                             or $psubcmd = '*VERIFYSSO'
417fAC                             or $psubcmd = '*VFYTFOCHG'
417hAC                             or $psubcmd = '*VFYLTOCHG'
417hAC                             or $psubcmd = '*VFYPROCHG'
417hAC                             or $psubcmd = '*VFYSSOCHG'
600fAC                   eval      $slavl1 = newavlqty1
600fAC                   eval      $slavl2 = newavlqty2
600fAC                   eval      $slavl3 = newavlqty3
     C                   goto      endqtytfro
     C                   endif

     *  Initialize warehouse updated quantities.

     C                   eval      #whsestat = slstat

     C                   eval      #whsefix1 = 0
     C                   eval      #whsefix2 = 0
     C                   eval      #whsefix3 = 0

     C                   eval      #whseadj1 = $saqty1
     C                   eval      #whseadj2 = $saqty2
     C                   eval      #whseadj3 = $saqty3

     C                   eval      #whseorg1 = 0
     C                   eval      #whseorg2 = 0
     C                   eval      #whseorg3 = 0

     *  Update slot ...

     *    Update transfer quantites.

     C                   eval      sltfr1 = sltfr1 + $saqty1
     C                   eval      sltfr2 = sltfr2 + $saqty2
     C                   eval      sltfr3 = sltfr3 + $saqty3

     *    Fix breakdown quantities.

     C                   exsr      fixbrkdn

     *    See if status should change.

     C                   exsr      checkstatus

     *    Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   goto      endqtytfro
     C                   endif

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     *  Update warehouse quantities ...

     C                   exsr      qtywhse
     C                   if        error
     C                   goto      endqtytfro
     C                   endif

     C     endqtytfro    endsr

416cA*----------------------------------------------------------------
416cA*  qtywhse      Update warehouse quantites.
416cA*----------------------------------------------------------------
416cA
416cAC     qtywhse       begsr
600tAC                   eval      currRoutine = 'qtywhse'
600tAC                   exsr      phpgmV1V2V3s
500kA
500kA*  For simple PR repl, SS repl and transfers we do not want
500kA*  to update the warehouse quantities.
600yA*  Always update for *HOLD.
500kA
600yAC                   if        $psubcmd <> '*HOLD'
500aAC                   if        $psubcmd = '*TFROUT'   or
500aAC                             $psubcmd = '*PROUT'   or
500aAC                             $psubcmd = '*SSOUT'   or
500aAC                             $psubcmd = '*CLSTFROUT' or
500aAC                             $psubcmd = '*CLSPROUT' or
500aAC                             $psubcmd = '*CLSSSOUT' or
500aAC                             $psubcmd = '*TFRIN'    or
500aAC                             $psubcmd = '*PRIN'    or
500aAC                             $psubcmd = '*SSIN'    or
500aAC                             $psubcmd = '*CLSTFRIN' or
500aAC                             $psubcmd = '*CLSPRIN' or
500aAC                             $psubcmd = '*CLSSSIN'
500aAC                   goto      endqtywhse
500aAC                   endif
600yAC                   endif
500kA
500kA*  For "change" PR repl, SS repl and transfers we only want to
500kA*  update the warehouse when the item is actually changed.
600yA*  Always update for *HOLD.
500kA
600yAC                   if        $psubcmd <> '*HOLD'
500aAC                   if        $psubcmd = '*TFROUTCHG' or
500aAC                             $psubcmd = '*PROUTCHG' or
500aAC                             $psubcmd = '*SSOUTCHG' or
500aAC                             $psubcmd = '*CLSTFOCHG' or
500aAC                             $psubcmd = '*CLSPROCHG' or
500aAC                             $psubcmd = '*CLSSSOCHG' or
500aAC                             $psubcmd = '*TFRINCHG' or
500aAC                             $psubcmd = '*PRINCHG' or
500aAC                             $psubcmd = '*SSINCHG' or
500aAC                             $psubcmd = '*CLSTFICHG' or
500aAC                             $psubcmd = '*CLSPRICHG' or
500aAC                             $psubcmd = '*CLSSSICHG'
600zDC******                       $psubcmd = '*USR2PUT' or
600zDC******                       $psubcmd = '*USR2RTN'
500aAC                   if        not $sacitemu
500aAC                             or $sacitem = $saitem
600zDC******             if        not itemChanged
600zDC******                       and not diffStatus
500aAC                   goto      endqtywhse
500aAC                   endif
500aAC                   endif
600yAC                   endif

     *  Pass along subcommand & quantities sent in ...

650pAC                   if        $psubcmd = '*ADJUSTREV'
650qAc                              or $psubcmd = '*ADJUSTPRD'
710bAc                              or $psubcmd = '*ADJUSTIMP'
650pAC                   eval      $drisubcmd = '*ADJUST   '
650pAC                   else
     C                   eval      $drisubcmd = $psubcmd
650pAC                   endif

     *  Add some slot and item information ...

     C                   eval      $iqwhseu = *on
     C                   eval      $iqwhse = $slwhse
     C                   eval      $iqitemu = *on
     C                   eval      $iqitem = #slotitem
     C                   eval      $iqstatu = *on
     C                   eval      $iqstat = #whsestat
     C                   eval      $iqumq2u = *on
601bDC**                 eval      $iqumq2 = #slotumq2
601bMC                   eval      $iqumq2 = #slotumq2orig
     C                   eval      $iqumq3u = *on
601bDC**                 eval      $iqumq3 = #slotumq3
601bMC                   eval      $iqumq3 = #slotumq3orig

     *  Don't forget the quantities ...

     C                   eval      $iqfixu = *on
     C                   eval      $iqfix1 = #whsefix1
     C                   eval      $iqfix2 = #whsefix2
     C                   eval      $iqfix3 = #whsefix3
     C                   eval      $iqadju = *on
     C                   eval      $iqadj1 = #whseadj1
     C                   eval      $iqadj2 = #whseadj2
     C                   eval      $iqadj3 = #whseadj3
     C                   eval      $iqorgu = *on
     C                   eval      $iqorg1 = #whseorg1
     C                   eval      $iqorg2 = #whseorg2
     C                   eval      $iqorg3 = #whseorg3

     *  And throw in some fields for tracking.

     C                   if        $satrn#u
     C                   eval      $iqtrn#u = *on
     C                   eval      $iqtrn#  = $satrn#
     C                   endif

     C                   if        $saFrmLcnsu
     C                   eval      $iqlic#u = *on
600fMC                   eval      $iqlic#  = $saFrmLcns
     C                   endif

     C                   if        $satasku
     C                   eval      $iqtasku = *on
     C                   eval      $iqtask  = $satask
     C                   endif

     *  Then call interface to do the update.

600eMC                   eval      $dricommand = 'DRIITEMQTY'
650pAC                   if        $psubcmd = '*ADJUSTREV'
710 Ac                              or $pSubcmd = '*ADJUSTPRD'
710bAc                              or $pSubcmd = '*ADJUSTIMP'
650pAC                   eval      $drisubcmd = '*ADJUST   '
650pAC                   else
600eMC                   eval      $drisubcmd = $psubcmd
650pAC                   endif
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3callerr
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   when      main3rtnerr
     C                   eval      error = *on
     C                   eval      $saiteme = '1'
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   goto      endqtywhse
     C                   endsl

     C                   eval      lockeditemqty = *off

     C     endqtywhse    endsr

     *----------------------------------------------------------------
     *  rightadj  Right adjust slot fields.
     *----------------------------------------------------------------

     C     rightadj      begsr

      *  Aisle

     C                   if        $slaislu
     C                   call      'ADJUST'
     C                   parm      '*RIGHT  '    $ccmd             8
     C                   parm      $slaisl       $cstr            30
     C                   move      $cstr         $slaisl
     C                   endif

      *  Handstack

     C                   if        $slhandu
     C                   call      'ADJUST'
     C                   parm      '*RIGHT  '    $ccmd
     C                   parm      $slhand       $cstr            30
     C                   move      $cstr         $slhand
     C                   endif

     C                   endsr

416eA*----------------------------------------------------------------
416eA*  savebefore   Save before image of slot.
416eA*----------------------------------------------------------------

416eAC     savebefore    begsr

     *  Move information about slot into ds fields.

     C                   exsr      slot2ds

     *  Save as before image.

     C                   eval      $slotbefore = $slot

     *  Restore original input (saved at beginning of program).

600fDC**                 eval      $slot = $slotinput
600fMC                   eval      $slot = in$slot
600fMC                   eval      $slot2 = in$slot2

     C                   endsr

     *----------------------------------------------------------------
     *  set2vfy   Set slot to verified state.
     *----------------------------------------------------------------

     C     set2vfy       begsr
600tAC                   eval      currRoutine = 'set2vfy'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  Get and lock slot.

417cAC                   if        $psubcmd <> '*ZEROVFY'

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2

     C                   if        error
     C                   goto      endset2vfy
     C                   endif

417cAC                   endif

     *  Make sure fields are cleaned up.

417cAC                   eval      slstat = 'V'
     C                   eval      slitem = ' '
     C                   eval      slentd = 0
     C                   eval      slexpd = 0
     C                   eval      slprty = 0
     C                   eval      slstk1 = 0
     C                   eval      slstk2 = 0
     C                   eval      slstk3 = 0
     C                   eval      slalc1 = 0
     C                   eval      slalc2 = 0
     C                   eval      slalc3 = 0
     C                   eval      sltfr1 = 0
     C                   eval      sltfr2 = 0
     C                   eval      sltfr3 = 0
     C                   eval      slpck1 = 0
     C                   eval      slpck2 = 0
     C                   eval      slpck3 = 0
     C                   eval      slrcv1 = 0
     C                   eval      slrcv2 = 0
     C                   eval      slrcv3 = 0

417cAC                   exsr      getdatetime
417cAC                   eval      slsdte = curdate
417cAC                   eval      slstim = curtime

     *  Update record

417cDC**                 update(e) slrec
417cMC                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'ERRUPDREC'
     C                   eval      $pmessage = 'Err on "Upd '
     C                                       + 'Slt" cmd '
     C                                       + '('
     C                                       + %Trim(%editc(slwhse:'Z'))
     C                                       + '/'
     C                                       + %trim(slwhdp)
     C                                       + '/'
     C                                       + %trim(sldisp)
     C                                       + ')'
417cMC                                       + '-' + f2messageid
417cDC**                                     + '-' + f1messageid

     C                   goto      endset2vfy
     C                   endif
510aA
510aA*  Delete slot date quantities.
510aA
510aAC                   exsr      deleteslotdte
610oA
610oA*  Delete license for slot.
610oA
610oAC                   exsr      deletelcns

     C     endset2vfy    endsr

417iA*----------------------------------------------------------------
417iA*  setentdate  Set slot entered date.
417iA*----------------------------------------------------------------
417iA
417iAC     setentdate    begsr
600tAC                   eval      currRoutine = 'setentdte'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  If entered date wasn't sent or is zero,
     *    set input field to current date.

     C                   if        not $slentdu or $slentd = 0
601aAC                   eval      $slentdu = *on
     C                   exsr      getdatetime
     C                   eval      $slentd = curdate
     C                   endif

     *  Determine if and how expiration date should be set.

     *    Set to From (Sent) date if one of the following ...
     *      - Existing date is zero.
     *      - Current (before) status is 'V' or 'Z'.
     *      - Stock qty is less than or equal to zero.
601aD **     - Doing a transfer and date option is set to '1'.
601aD **     - Doing a letdown and date option is set to '1'.
601aD **     - Doing a priority replenishment and date option is set to '1'.
601aD **     - Doing a specific slot repl and date option is set to '1'.
601aD **     - Doing a receiving/putaway and date option is set to '1'.
601aD **     - Doing a return and date option is set to '1'.

     C                   if        slentd = 0
     C                             or (slstat = 'V' or slstat = 'Z')
     C                             or (slstk1 <= 0
     C                                 and slstk2 <= 0
     C                                 and slstk3 <= 0)
601aDC**                           or (($psubcmd = '*TFRIN'
601aDC**                                or $psubcmd = '*TFRINCHG'
601aDC**                                or $psubcmd = '*CLSTFRIN'
601aDC**                                or $psubcmd = '*CLSTFICHG')
601aDC**                               and opsltf = '1')
601aDC**                           or (($psubcmd = '*LETIN'
601aDC**                                or $psubcmd = '*LETINCHG'
601aDC**                                or $psubcmd = '*CLSLETIN'
601aDC**                                or $psubcmd = '*CLSLTICHG')
601aDC**                               and opltdn = '1')
601aDC**                           or (($psubcmd = '*PRIN'
601aDC**                                or $psubcmd = '*PRINCHG'
601aDC**                                or $psubcmd = '*CLSPRIN'
601aDC**                                or $psubcmd = '*CLSPRICHG')
601aDC**                               and opodrp = '1')
601aDC**                           or (($psubcmd = '*SSIN'
601aDC**                                or $psubcmd = '*SSINCHG'
601aDC**                                or $psubcmd = '*CLSSSIN'
601aDC**                                or $psubcmd = '*CLSSSICHG')
601aDC**                               and opodrp = '1')
601aDC**                           or (($psubcmd = '*RECEIVE'
601aDC**                                or $psubcmd = '*PUTAWAY'
601aDC**                                or $psubcmd = '*STAGEPUT'
601aDC**                                or $psubcmd = '*CLSRCV'
601aDC**                                or $psubcmd = '*CLSRCVADJ'
601aDC**                                or $psubcmd = '*CLSPUTAWY'
601aDC**                                or $psubcmd = '*CLSSTGPUT')
601aDC**                               and opparc = '1')
601aDC**                           or (($psubcmd = '*RETURN'
601aDC**                                or $psubcmd = '*CLSRTN')
601aDC**                               and oppart = '1')
     C                   eval      slentd = $slentd
     C                   goto      endsetentdate
     C                   endif

     *    Otherwise, set to oldest date.

     C                   if        $slentd < slentd
     C                   eval      slentd = $slentd
     C                   goto      endsetentdate
     C                   endif

     C     endsetentdate endsr

417iA*----------------------------------------------------------------
417iA*  setexpdate  Set slot expiration/entered dates.
417iA*----------------------------------------------------------------
417iA
417iAC     setexpdate    begsr
600tAC                   eval      currRoutine = 'setexpdte'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  Determine if and how expiration date should be set.

     *    Set to zero if ...
     *      Item is not date sensitive

     C                   if        #slotflgd <> 'Y'
     C                   eval      slexpd = 0
     C                   goto      endsetexpdate
     C                   endif

     *    Do nothing if Sent (From) date is zero or wasn't sent.

     C                   if        $slexpd = 0 or not $slexpdu
     C                   goto      endsetexpdate
     C                   endif

     *    Set to From (Sent) date if one of the following ...
     *      - Existing date is zero.
     *      - Current (before) status is 'V' or 'Z'.
     *      - Stock qty is less than or equal to zero.
601aD **     - Doing a transfer and date option is set to '1'.
601aD **     - Doing a letdown and date option is set to '1'.
601aD **     - Doing a priority replenishment and date option is set to '1'.
601aD **     - Doing a specific slot repl and date option is set to '1'.
601aD **     - Doing a receiving/putaway and date option is set to '1'.
601aD **     - Doing a return and date option is set to '1'.

     C                   if        slexpd = 0
     C                             or (slstat = 'V' or slstat = 'Z')
     C                             or (slstk1 <= 0
     C                                 and slstk2 <= 0
     C                                 and slstk3 <= 0)
601aDC**                           or (($psubcmd = '*TFRIN'
601aDC**                                or $psubcmd = '*TFRINCHG'
601aDC**                                or $psubcmd = '*CLSTFRIN'
601aDC**                                or $psubcmd = '*CLSTFICHG')
601aDC**                               and opsltf = '1')
601aDC**                           or (($psubcmd = '*LETIN'
601aDC**                                or $psubcmd = '*LETINCHG'
601aDC**                                or $psubcmd = '*CLSLETIN'
601aDC**                                or $psubcmd = '*CLSLTICHG')
601aDC**                               and opltdn = '1')
601aDC**                           or (($psubcmd = '*PRIN'
601aDC**                                or $psubcmd = '*PRINCHG'
601aDC**                                or $psubcmd = '*CLSPRIN'
601aDC**                                or $psubcmd = '*CLSPRICHG')
601aDC**                               and opodrp = '1')
601aDC**                           or (($psubcmd = '*SSIN'
601aDC**                                or $psubcmd = '*SSINCHG'
601aDC**                                or $psubcmd = '*CLSSSIN'
601aDC**                                or $psubcmd = '*CLSSSICHG')
601aDC**                               and opodrp = '1')
601aDC**                           or (($psubcmd = '*RECEIVE'
601aDC**                                or $psubcmd = '*PUTAWAY'
601aDC**                                or $psubcmd = '*STAGEPUT'
601aDC**                                or $psubcmd = '*CLSRCV'
601aDC**                                or $psubcmd = '*CLSRCVADJ'
601aDC**                                or $psubcmd = '*CLSPUTAWY'
601aDC**                                or $psubcmd = '*CLSSTGPUT')
601aDC**                               and opparc = '1')
601aDC**                           or (($psubcmd = '*RETURN'
601aDC**                                or $psubcmd = '*CLSRTN')
601aDC**                               and oppart = '1')
     C                   eval      slexpd = $slexpd
     C                   goto      endsetexpdate
     C                   endif

     *    Otherwise, set to oldest date.

     C                   if        $slexpd < slexpd
     C                   eval      slexpd = $slexpd
     C                   goto      endsetexpdate
     C                   endif

     C     endsetexpdate endsr

417iA*----------------------------------------------------------------
417iA*  setpriority  Set slot priority.
417iA*----------------------------------------------------------------
417iA
417iAC     setpriority   begsr
600tAC                   eval      currRoutine = 'setpriority'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off
     C                   eval      updprty = *off

     *  If priority wasn't sent, set input field to zero.

640iDC**                 if        not $slprtyu
640iMC                   if        not in$slot.$slprtyu
601aAC                   eval      $slprtyu = *on
     C                   eval      $slprty = 0
640iAC                   else
640iAC                   eval      $slprty = in$slot.$slprty
     C                   endif

     *  Make sure priority is less than or equal to zero.

     C                   if        $slprty > 0
     C                   eval      $slprty = -($slprty)
     C                   endif

     *  Set to From (Sent) priority if one of the following ...
     *    - Current (before) status is 'V' or 'Z'.
     *    - From priority is higher that existing priority.

     C                   if        (slstat = 'V' or slstat = 'Z')
     C                             or %abs($slprty) > %abs(slprty)
     C                   eval      slprty = $slprty
     C                   goto      endsetprty
     C                   endif

TPCaA*    Set slot priority for TPC cone house transfers for bulk pick
600dDC**                 if        $psubcmd = '*CLSTFICHG' and
600dMC                   if        %subst($psubcmd:1:5) = '*USR2' and
TPCaAC                             client = 'TPC    '
TPCaAC                   if        sldisp = '07-100-A'  or
TPCaAC                             sldisp = '07-102-A'  or
TPCaAC                             sldisp = '07-104-A'
TPCaAC                   eval      slprty = -(9)
TPCaAC                   endif
TPCaAC                   endif

     C     endsetprty    endsr

417iA*----------------------------------------------------------------
417iA*  setstatus    Set slot status
417iA*----------------------------------------------------------------
417iA
417iAC     setstatus     begsr
600tAC                   eval      currRoutine = 'setstatus'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      error = *off

     *  See if status should change.

     *    if status sent in, use it.
     *    otherwise call routine to see if it should change.

     C                   if        $slstatu and $slstat <> ' '
     C                   eval      slstat = $slstat
     C                   exsr      getdatetime
     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime
     C                   else
     C                   exsr      checkstatus
     C                   endif

     C     endstatus     endsr

416eA*----------------------------------------------------------------
416eA*  seqprtyrpl   Sequence priority replenishments
416eA*----------------------------------------------------------------

416eAC     seqprtyrpl    begsr
600tAC                   eval      currRoutine = 'seqprtyrpl'
600tAC                   exsr      phpgmV1V2V3s

     *  Initialize data structure

600eMC                   exsr      clr$prtyrpl

     *  Initialize fields

     C                   eval      $prwhseu = *on
     C                   eval      $prwhse  = $slwhse

600eMC                   eval      $dricommand = 'DRIPRTYRPL'
600eMC                   eval      $drisubcmd = $psubcmd
600eMC                   exsr      zzzdrimain3

     C                   select
     C                   when      main3callerr
     C                   eval      error = *on
     C                   eval      $preturn  = $drireturn
     C                   eval      $pmessage = $drimessage
     C                   endsl

     C                   endsr

416pA*----------------------------------------------------------------
416pA*  shiftssbqty   Shift quantities for SSB item.
416pA*----------------------------------------------------------------

416pAC     shiftssbqty   begsr

     *  Shift quantities if sent item is an SSB item.

650aAC                   if        $sldesg = 'BFC'
650aAc                   else
     C                   if        #senttype = 'S'
     C                   eval      $saqty3 = $saqty2
     C                   eval      $saqty2 = $saqty1
     C                   eval      $saqty1 = 0
     C                   eval      $saorg3 = $saorg2
     C                   eval      $saorg2 = $saorg1
     C                   eval      $saorg1 = 0
     C                   endif
650aAc                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  slot2ds  Move slot fields to data structure fields
     *----------------------------------------------------------------

     C     slot2ds       begsr

     C* Move information to data structure.

     C                   eval      $slwhse = slwhse
     C                   eval      $slwhdp = slwhdp
     C                   eval      $sldisp = sldisp
     C                   eval      $slaisl = slaisl
     C                   eval      $slloc  = slloc
     C                   eval      $slrlvl = slrlvl
     C                   eval      $slhand = slhand
     C                   eval      $slside = slside
     C                   eval      $slstyp = slstyp
     C                   eval      $slstat = slstat
     C                   eval      $slsdte = slsdte
     C                   eval      $slstim = slstim
     C                   eval      $slsdef = slsdef
     C                   eval      $sldesg = sldesg
     C                   eval      $slactv = slactv
     C                   eval      $slbld  = slbld
     C                   eval      $slpick = slpick
     C                   eval      $slpseq = slpseq
     C                   eval      $slprty = slprty
     C                   eval      $slentd = slentd
     C                   eval      $slexpd = slexpd
     C                   eval      $slslfd = slslfd
     C                   eval      $slrsrv = slrsrv
     C                   eval      $slitem = slitem
     C                   eval      $slstk1 = slstk1
     C                   eval      $slstk2 = slstk2
     C                   eval      $slstk3 = slstk3
     C                   eval      $slalc1 = slalc1
     C                   eval      $slalc2 = slalc2
     C                   eval      $slalc3 = slalc3
     C                   eval      $sltfr1 = sltfr1
     C                   eval      $sltfr2 = sltfr2
     C                   eval      $sltfr3 = sltfr3
     C                   eval      $slpck1 = slpck1
     C                   eval      $slpck2 = slpck2
     C                   eval      $slpck3 = slpck3
     C                   eval      $slrcv1 = slrcv1
     C                   eval      $slrcv2 = slrcv2
     C                   eval      $slrcv3 = slrcv3
     C                   eval      $slphy1 = slphy1
     C                   eval      $slphy2 = slphy2
     C                   eval      $slphy3 = slphy3
     C                   eval      $slavl1 = slavl1
     C                   eval      $slavl2 = slavl2
     C                   eval      $slavl3 = slavl3
     C                   eval      $sladj1 = sladj1
     C                   eval      $sladj2 = sladj2
     C                   eval      $sladj3 = sladj3
417eA
417eA*  Get slot check digit.
417eA
417eAC                   eval      lock = *off
417eAC                   exsr      getchkdigit
417eAC                   eval      $scddgt = scddgt
416rA
416rA*  Get base slot for some operations.
500jA*    Also get license information.
416rA
416rAC                   if        $psubcmd = '*GET'  or
650eAC                             $psubcmd = '*GET2' or
416rAC                             $psubcmd = '*GETI' or
416bAC                             %subst($psubcmd:1:4) = '*NXT' or
417aMC                             %subst($psubcmd:1:4) = '*PRV' or
417aAC                             $psubcmd = '*GETCHKV' or
601dAC                             $psubcmd = '*GETCHKVX' or
417aAC                             $psubcmd = '*GETICHKV' or
610eAC                             $psubcmd = '*GETITEMAV' or
610eAC                             $psubcmd = '*GETOVRFAV' or
600iAC                             $psubcmd = '*STUFFIT' or
610uAC                             $psubcmd = '*GETREPACK' or
600dAC                             %subst($psubcmd:1:4) = '*USR' or
600dAC                             %subst($psubcmd:1:4) = '*RCV' or
730eAC                             %subst($psubcmd:1:4) = '*RWO' or
600dAC                             %subst($psubcmd:1:4) = '*STG' or
600dAC                             %subst($psubcmd:5:4) = '2USR'
416rAC                   exsr      getbaseslot
600mAC                   eval      $sacdsp = baseDisp

600fDC**                 eval      check4err = *on
600fDC**                 exsr      getslotlic
600fDC**                 if        error
600fDC**                 eval      error = *off
600fDC**                 eval      $saToLcns  = ' '
600fDC**                 eval      $saToPos = 0
600fDC**                 else
600fDC**                 eval      $saToLcns  = $lrlcns
600fDC**                 eval      $saToslpos = $lrtslp
600fDC**                 endif

416rDC                   endif
600fA
600fA*  For some operations, get license information.
600fA
600fAC                   if        $psubcmd = '*GET'  or
650eAC                             $psubcmd = '*GET2' or
600fAC                             $psubcmd = '*GETI' or
600fAC                             %subst($psubcmd:1:4) = '*NXT' or
600fAC                             %subst($psubcmd:1:4) = '*PRV' or
600fAC                             $psubcmd = '*GETCHKV' or
601dAC                             $psubcmd = '*GETCHKVX' or
600fAC                             $psubcmd = '*GETICHKV' or
610eAC                             $psubcmd = '*GETITEMAV' or
610uAC                             $psubcmd = '*GETREPACK' or
610eAC                             $psubcmd = '*GETOVRFAV'
600fAC                   eval      check4err = *on
600lAC                   eval      tmpdisp = $sldisp
600lAC                   eval      tmpitem = $slitem
600fAC                   exsr      getslotlic
600fAC                   if        error
600fAC                   eval      error = *off
600fAC                   eval      $saToLcns  = ' '
600fAC                   eval      $saToPos = 0
600fAC                   else
600fAC                   eval      $saOLcns  = $liOLcns
600fAC                   eval      $saToLcns  = $liToLcns
600fAC                   eval      $saToPos = $liToPos
600fAC                   endif
600fAC                   endif
417aA
417aA*  For some operations, check for virtual associated with base.
417aA
417aAC                   if        $psubcmd = '*GETCHKV'  or
601dAC                             $psubcmd = '*GETCHKVX'  or
417bMC                             $psubcmd = '*GETICHKV' or
417bAC                             %subst($psubcmd:1:4) = '*NXT' or
417bAC                             %subst($psubcmd:1:4) = '*PRV'
417aAC                   exsr      check4virtual
417aAC                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  unlock         Unlock records.
     *----------------------------------------------------------------

     C     unlock        begsr

     C                   if        lockeditemqty
     C                   eval      $drisubcmd = '*UNLOCK'
600eMC                   eval      $dricommand = 'DRIITEMQTY'
600eMC                   exsr      zzzdrimain3
     C                   endif

     C                   if        lockedslot1
     C                   unlock    slot1
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        lockedslot2
     C                   unlock    slot2
     C                   if        %error
     C                   endif
     C                   endif


     C                   if        lockedvslot
     C                   unlock    vslot
     C                   if        %error
     C                   endif
     C                   endif

     C                   endsr

416cA*----------------------------------------------------------------
416cA*  updqty     Update slot quantities.
416cA*----------------------------------------------------------------
416cA
416cAC     updqty        begsr
600tAC                   eval      currRoutine = 'updqty'
600tAC                   exsr      phpgmV1V2V3s
     C                   move      *off          error

     *  Update slot quantities.

     C                   eval      slstk1 = slstk1 + $slstk1
     C                   eval      slstk2 = slstk2 + $slstk2
     C                   eval      slstk3 = slstk3 + $slstk3

     C                   eval      slalc1 = slalc1 + $slalc1
     C                   eval      slalc2 = slalc2 + $slalc2
     C                   eval      slalc3 = slalc3 + $slalc3

     C                   eval      sltfr1 = sltfr1 + $sltfr1
     C                   eval      sltfr2 = sltfr2 + $sltfr2
     C                   eval      sltfr3 = sltfr3 + $sltfr3

     C                   eval      slpck1 = slpck1 + $slpck1
     C                   eval      slpck2 = slpck2 + $slpck2
     C                   eval      slpck3 = slpck3 + $slpck3

     C                   eval      slrcv1 = slrcv1 + $slrcv1
     C                   eval      slrcv2 = slrcv2 + $slrcv2
     C                   eval      slrcv3 = slrcv3 + $slrcv3

     *  See if status should change.

     C                   call      'CHKSTAT'
600oDC**                 parm                    slwhse
600oMC                   parm      slwhse        $uwhse
     C                   parm                    slitem
     C                   parm                    slstyp
     C                   parm                    slrsrv
     C                   parm                    slpick
     C                   parm                    slstat
530aAC                   parm                    sldesg
     C                   parm                    slstk1
     C                   parm                    slstk2
     C                   parm                    slstk3
     C                   parm                    slalc1
     C                   parm                    slalc2
     C                   parm                    slalc3
     C                   parm                    sltfr1
     C                   parm                    sltfr2
     C                   parm                    sltfr3
     C                   parm                    slpck1
     C                   parm                    slpck2
     C                   parm                    slpck3
     C                   parm                    slrcv1
     C                   parm                    slrcv2
     C                   parm                    slrcv3
     C                   parm                    $cnewstat         2
     C                   parm                    $creturn          8

     C                   if        $creturn  = '*CHANGED'
     C                   eval      slstat = $cnewstat
     C                   exsr      getdatetime
     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime
     C                   if        slstat = 'A'
     C                   eval      slentd = curdate
     C                   endif
     C                   endif

     *  Get item information.

     C                   eval      check4err = *off
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = slitem
     C                   exsr      getitem

     *  Try to "up" breakdown quantities.

     C                   dow       $itumq3 > 0 and slavl3 > $itumq3
     C                   eval      slstk3 = slstk3 - $itumq3
     C                   eval      slavl3 = slavl3 - $itumq3
     C                   eval      slstk2 = slstk2 + 1
     C                   eval      slavl2 = slavl2 + 1
     C                   enddo

     C                   dow       $itumq2 > 0 and slavl2 > $itumq2
     C                   eval      slstk2 = slstk2 - $itumq2
     C                   eval      slavl2 = slavl2 - $itumq2
     C                   eval      slstk1 = slstk1 + 1
     C                   eval      slavl1 = slavl1 + 1
     C                   enddo

     *  Update record.

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDSTKERR'
     C                   exsr      getmsg
     C                   goto      endupdqty
     C                   endif
510aA
510aA*  Update slot date quantities.
510aA
510aAC                   eval      $ucmd  = '*FIFO'
510aAC                   eval      $uqty1 = $slstk1
510aAC                   eval      $uqty2 = $slstk2
510aAC                   eval      $uqty3 = $slstk3
601aDC**                 exsr      updslotdte

     *  Recalculate slot quantities.

     C                   exsr      calcqtys
     C                   exsr      slot2ds

     C     endupdqty     endsr

510aA*----------------------------------------------------------------
510aA*  updslotdte  Update slotdte records.
601aD*  **** NOT USED ANY MORE STARTING WITH ver 6.00 ****
510aA*----------------------------------------------------------------
510aA
510aAC     updslotdte    begsr
600tAC                   eval      currRoutine = 'updslotdte'
600tAC                   exsr      phpgmV1V2V3s

     C                   call      'UPDSLTDTE'
     C                   parm                    $ucmd             8
     C                   parm      $pprogram     $upgm            10
     C                   parm      #prog         $upgm2           10
     C                   parm      slwhse        $uwhse            3 0
     C                   parm      slwhdp        $uwhdp            5
     C                   parm      sldisp        $uslot           12
     C                   parm      slpick        $upick            1
     C                   parm      slitem        $uitem           15
     C                   parm      ' '           $unewi           15
     C                   parm      slentd        $uentd            8 0
     C                   parm      slexpd        $uexpd            8 0
     C                   parm                    $uqty1            5 0
     C                   parm                    $uqty2            5 0
     C                   parm                    $uqty3            5 0
     C                   parm      ' '           $urtn             8

     C                   endsr

601aA*----------------------------------------------------------------
601aA*  updslotfifo  Update slot fifo fields from license's
601aA*
601aA*    This routine assumes that the last call to DRILICENSE
601aA*    returned the FIFO information for the slot.
601aA*
601aA*    This routine assumes that to$Slot/to$Slot2 contain the
601aA*    latest information on the slot just updated.
601aA*
601aA*----------------------------------------------------------------
601aA
601aAC     updslotfifo   begsr
     C                   eval      currRoutine = 'updslotfifo'
     C                   exsr      phpgmV1V2V3s

     C                   eval      updateFifo = *off

     *  Nothing to do if slot is at status V or Z.

     C                   if        to$Slot.$slstat = 'V'
     C                             or to$Slot.$slstat = 'Z'
     C                   leavesr
     C                   endif

     *  Get out if First Fifo entered date is zero

     C                   if        $liFirstFifoEntd = 0
     C                   leavesr
     C                   endif

     *  Retrieve item if necessary

     C                   if        to$Slot.$slitem <> #slotitem
     C                   eval      check4err = *off
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = to$Slot.$slitem
     C                   exsr      getitem
     C                   eval      #slotitem = $ititem
     C                   eval      #slotflgd = $itflgd
     C                   endif

     *  Get FIFO update options

     C                   exsr      getSltFifoOpt

     *  Use First Fifo license
610pA*    (Overflow slots always use this license)

     C                   if        oppff = 'Y'
610pAC                             or to$Slot.$slpick <> 'Y'
     C                   if        to$Slot.$slprty <> $liFirstFifoPrty
     C                             or to$Slot.$slexpd <> $liFirstFifoExpD
     C                             or to$Slot.$slentd <> $liFirstFifoEntd
     C                   eval      updateFifo = *on
     C                   eval      to$Slot.$slprty = $liFirstFifoPrty
     C                   eval      to$Slot.$slexpd = $liFirstFifoExpD
     C                   eval      to$Slot.$slentd = $liFirstFifoEntd
     C                   endif
     C                   endif

     *  Use First non-expired Fifo license

     C                   if        oppfnf = 'Y'
     C                             and $liFirstNEFifoEntd <> 0
     C                   if        to$Slot.$slprty <> $liFirstNEFifoPrty
     C                             or to$Slot.$slexpd <> $liFirstNEFifoExpD
     C                             or to$Slot.$slentd <> $liFirstNEFifoEntd
     C                   eval      updateFifo = *on
     C                   eval      to$Slot.$slprty = $liFirstNEFifoPrty
     C                   eval      to$Slot.$slexpd = $liFirstNEFifoExpD
     C                   eval      to$Slot.$slentd = $liFirstNEFifoEntd
     C                   endif
     C                   endif

     *  Use Last Fifo license

     C                   if        opplf = 'Y'
     C                   if        to$Slot.$slprty <> $liLastFifoPrty
     C                             or to$Slot.$slexpd <> $liLastFifoExpD
     C                             or to$Slot.$slentd <> $liLastFifoEntd
     C                   eval      updateFifo = *on
     C                   eval      to$Slot.$slprty = $liLastFifoPrty
     C                   eval      to$Slot.$slexpd = $liLastFifoExpD
     C                   eval      to$Slot.$slentd = $liLastFifoEntd
     C                   endif
     C                   endif

     *  If item not date sensitive, set expiration date to zero.

     C                   if        #slotflgd <> 'Y'
     C                             and to$Slot.$slexpd <> 0
     C                   eval      updateFifo = *on
     C                   eval      to$Slot.$slexpd = 0
     C                   endif

     *  If slot doesn't need to be updated, get out.

     C                   if        not updateFifo
     C                   leavesr
     C                   endif

     *  Otherwise, update slot.

     *    Get and lock normal slot.

     C                   eval      lock = *on
     C                   eval      kywhse = to$Slot.$slwhse
     C                   eval      kywhdp = to$Slot.$slwhdp
     C                   eval      kydisp = to$Slot.$sldisp
     C                   eval      lock = *on
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *    Update FIFO fields

     C                   eval      slprty = to$Slot.$slprty
     C                   eval      slexpd = to$Slot.$slexpd
     C                   eval      slentd = to$Slot.$slentd

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   eval      $Slot = to$Slot

     C                   endsr

610aA*----------------------------------------------------------------
610aA*  updslotfifofm  Update 'from' slot fifo fields from license's
610aA*
610aA*    This routine assumes that frm$Slot/frm$Slot2 contain the
610aA*    latest information on the slot just transferred from.
610aA*
610aA*----------------------------------------------------------------
610aA
610aAC     updslotfifofrmbegsr
     C                   eval      currRoutine = 'updslotfifofrm'
     C                   exsr      phpgmV1V2V3s

     C                   eval      updateFifo = *off

     *  Nothing to do if slot is at status V or Z.

     C                   if        frm$Slot.$slstat = 'V'
     C                             or frm$Slot.$slstat = 'Z'
     C                   leavesr
     C                   endif

     *  Get license info for From slot.

     C                   eval      check4err = *on
     C                   exsr      getfrmsltlic
     C                   if        error
     C                   eval      error = *off
     C                   leavesr
     C                   endif

     *  Get out if First Fifo entered date is zero

     C                   if        $liFirstFifoEntd = 0
     C                   leavesr
     C                   endif

     *  Retrieve item if necessary

     C                   if        frm$Slot.$slitem <> #slotitem
640oAc                             and frm$slot.$slitem <> ' '
     C                   eval      check4err = *off
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = frm$Slot.$slitem
     C                   exsr      getitem
     C                   eval      #slotitem = $ititem
     C                   eval      #slotflgd = $itflgd
     C                   endif

     *  Get FIFO update options

     C                   exsr      getSltFifoOpt

     *  Use First Fifo license
610pA*    (Overflow slots always use this license)

     C                   if        oppff = 'Y'
610pAC                             or frm$Slot.$slpick <> 'Y'
     C                   if        frm$Slot.$slprty <> $liFirstFifoPrty
     C                             or frm$Slot.$slexpd <> $liFirstFifoExpD
     C                             or frm$Slot.$slentd <> $liFirstFifoEntd
     C                   eval      updateFifo = *on
     C                   eval      frm$Slot.$slprty = $liFirstFifoPrty
     C                   eval      frm$Slot.$slexpd = $liFirstFifoExpD
     C                   eval      frm$Slot.$slentd = $liFirstFifoEntd
     C                   endif
     C                   endif

     *  Use First non-expired Fifo license

     C                   if        oppfnf = 'Y'
     C                             and $liFirstNEFifoEntd <> 0
     C                   if        frm$Slot.$slprty <> $liFirstNEFifoPrty
     C                             or frm$Slot.$slexpd <> $liFirstNEFifoExpD
     C                             or frm$Slot.$slentd <> $liFirstNEFifoEntd
     C                   eval      updateFifo = *on
     C                   eval      frm$Slot.$slprty = $liFirstNEFifoPrty
     C                   eval      frm$Slot.$slexpd = $liFirstNEFifoExpD
     C                   eval      frm$Slot.$slentd = $liFirstNEFifoEntd
     C                   endif
     C                   endif

     *  Use Last Fifo license

     C                   if        opplf = 'Y'
     C                   if        frm$Slot.$slprty <> $liLastFifoPrty
     C                             or frm$Slot.$slexpd <> $liLastFifoExpD
     C                             or frm$Slot.$slentd <> $liLastFifoEntd
     C                   eval      updateFifo = *on
     C                   eval      frm$Slot.$slprty = $liLastFifoPrty
     C                   eval      frm$Slot.$slexpd = $liLastFifoExpD
     C                   eval      frm$Slot.$slentd = $liLastFifoEntd
     C                   endif
     C                   endif

     *  If item not date sensitive, set expiration date to zero.

     C                   if        #slotflgd <> 'Y'
     C                             and frm$Slot.$slexpd <> 0
     C                   eval      updateFifo = *on
     C                   eval      frm$Slot.$slexpd = 0
     C                   endif

     *  If slot doesn't need to be updated, get out.

     C                   if        not updateFifo
     C                   leavesr
     C                   endif

     *  Otherwise, update slot.

     *    Get and lock normal slot.

     C                   eval      lock = *on
     C                   eval      kywhse = frm$Slot.$slwhse
     C                   eval      kywhdp = frm$Slot.$slwhdp
     C                   eval      kydisp = frm$Slot.$sldisp
     C                   eval      lock = *on
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *    Update FIFO fields

     C                   eval      slprty = frm$Slot.$slprty
     C                   eval      slexpd = frm$Slot.$slexpd
     C                   eval      slentd = frm$Slot.$slentd

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  updstock   Update stock quantities.
     *----------------------------------------------------------------

     C     updstock      begsr
600tAC                   eval      currRoutine = 'updstock'
600tAC                   exsr      phpgmV1V2V3s
     C                   move      *off          error

     *  Update stock quantities.

     C                   eval      slstk1 = $slstk1
     C                   eval      slstk2 = $slstk2
     C                   eval      slstk3 = $slstk3

     *  See if status should change.

     C                   call      'CHKSTAT'
600oDC**                 parm                    slwhse
600oMC                   parm      slwhse        $uwhse
     C                   parm                    slitem
     C                   parm                    slstyp
     C                   parm                    slrsrv
     C                   parm                    slpick
     C                   parm                    slstat
530aAC                   parm                    sldesg
     C                   parm                    slstk1
     C                   parm                    slstk2
     C                   parm                    slstk3
     C                   parm                    slalc1
     C                   parm                    slalc2
     C                   parm                    slalc3
     C                   parm                    sltfr1
     C                   parm                    sltfr2
     C                   parm                    sltfr3
     C                   parm                    slpck1
     C                   parm                    slpck2
     C                   parm                    slpck3
     C                   parm                    slrcv1
     C                   parm                    slrcv2
     C                   parm                    slrcv3
     C                   parm                    $cnewstat         2
     C                   parm                    $creturn          8

     C                   if        $creturn  = '*CHANGED'
     C                   eval      slstat = $cnewstat
     C                   exsr      getdatetime
     C                   eval      slsdte = curdate
     C                   eval      slstim = curtime
     C                   if        slstat = 'A'
     C                   eval      slentd = curdate
     C                   endif
     C                   endif

     *  Get item information.

     C                   eval      check4err = *off
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = slitem
     C                   exsr      getitem

     *  Try to "up" breakdown quantities.

     C                   dow       $itumq3 > 0 and slavl3 > $itumq3
     C                   eval      slstk3 = slstk3 - $itumq3
     C                   eval      slavl3 = slavl3 - $itumq3
     C                   eval      slstk2 = slstk2 + 1
     C                   eval      slavl2 = slavl2 + 1
     C                   enddo

     C                   dow       $itumq2 > 0 and slavl2 > $itumq2
     C                   eval      slstk2 = slstk2 - $itumq2
     C                   eval      slavl2 = slavl2 - $itumq2
     C                   eval      slstk1 = slstk1 + 1
     C                   eval      slavl1 = slavl1 + 1
     C                   enddo

     *  Update record.

416aMC                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDSTKERR'
     C                   exsr      getmsg
     C                   goto      endupdslot
     C                   endif
510aA
510aA*  Update slot date quantities.
510aA
510aAC                   eval      $ucmd  = '*FIFO'
510aAC                   eval      $uqty1 = $slstk1
510aAC                   eval      $uqty2 = $slstk2
510aAC                   eval      $uqty3 = $slstk3
601aDC**                 exsr      updslotdte

416aA*  Recalculate slot quantities.

416aAC                   exsr      calcqtys
416aAC                   exsr      slot2ds

     C     endupdslot    endsr

     *----------------------------------------------------------------
     *  verifyadd  Verify slot information when adding.
     *----------------------------------------------------------------

     C     verifyadd     begsr
600tAC                   eval      currRoutine = 'verifyadd'
600tAC                   exsr      phpgmV1V2V3s

     *  Section must be sent.

     C                   if        not $slstypu
     C                   eval      error = *on
     C                   eval      $slstype = '1'
     C                   eval      $preturn = 'STPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   endif

     *  Status must be sent.

     C                   if        not $slstatu
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = 'STSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   endif

     *  If designation is not sent set code to blank and type to 'S'.

     C                   if        not $sldesgu
     C                   eval      $sldesg = ' '
     C                   eval      #dtypeslot = 'S'
     C                   endif

     *  Item number must be sent when creating Active slot.

     C                   if        $slstat = 'A' and not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   endif

     *  Item cannot be blank when creating Active slot.

     C                   if        $slstat = 'A' and $slitem = ' '
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'BLANKITEM'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   endif

     *  Slot1 cannot already exist.

     C                   eval      lock = *off
     C                   exsr      getslot1
     C                   select
     C                   when      not error
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slaisle = '1'
     C                   eval      $slloce = '1'
     C                   eval      $slrlvle = '1'
     C                   eval      $slhande = '1'
     C                   eval      $preturn = 'SLOT1EXIST'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   when      $preturn = 'OPNERRSLT1'
     C                   goto      endvfyadd
     C                   other
     C                   eval      error = *off
     C                   eval      $preturn  = '*OK'
     C                   eval      $pmessage = ' '
     C                   endsl

     *  Slot2 cannot already exist.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   select
     C                   when      not error
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLOT2EXIST'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   when      $preturn = 'OPNERRSLT2'
     C                   goto      endvfyadd
     C                   other
     C                   eval      error = *off
     C                   eval      $preturn  = '*OK'
     C                   eval      $pmessage = ' '
     C                   endsl

     *  Verify that item is allowed in slot.

     C                   if        $slitem <> ' '
     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*VERIFYS'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   goto      endvfyadd
     C                   endif
     C                   endif

     *  Get item information.

     C                   if        $slitem <> ' '
     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETALL'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   goto      endvfyadd
     C                   endif
     C                   eval      check4err = *off
     C                   eval      desigcode = $itdesg
     C                   exsr      getdesig
     C                   eval      #dtypeitem = $dstype
     C                   endif
MQS A*
MQS A*    if slot def for current slot matches Staging/Store slot def then
MQS A*    force "S" or #dtypeitem to ignore next check
MQS A*
MQS Ac                   if        client = Marques
MQS Ac                   if        $slsdef = oprzst
MQS Ac                             and #dtypeitem='H'
MQS Ac                   eval      #dtypeitem = 'S'
MQS Ac                   endif
MQS Ac                   endif

     *  When creating an active slot ...
     *    Then the dept, section and designation must match item.
     *    Otherwise, match isn't necessary.

     C                   if        $slstat = 'A' and $psubcmd <> '*ADDXDK'
     C                   if        $slwhdp <> $itwhdp or
     C                             $slstyp <> $itstyp or
     C                             $sldesg <> $itdesg and #dtypeslot ='H' or
     C                             $sldesg <> $itdesg and #dtypeitem ='H'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slstype = '1'
     C                   eval      $sldesge = '1'
     C                   eval      $preturn = 'ISMISMTCH'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   endif
     C                   endif

     *  Special checks when adding a fixed, active pick slot.

     C                   if        $slstyp = 'F' and
     C                             $slstat = 'A' and
     C                             $slpick = 'Y' and
     C                             $psubcmd <> '*ADDXDK'

     *    Make sure maximum number of picks slots is <= 1 if ...
     *      Department is Directed putaway
     *      or mulitple pick slots are not allowed.

     C                   if        DirectPutaway or opmpck <> 'Y'
     C                   if        $imnrpk > 1
     C                   eval      $imnrpk = 1
     C                   endif
     C                   endif

     *    Count existing active pick slots for item.


     C                   call      'CNTPICK'
     C                   parm      $slwhse       $vwhse
     C                   parm      $slitem       $vitem
     C                   parm      ' '           $vwhdp
     C                   parm      ' '           $vdisp
     C                   parm                    $vcount
611aDC**                 parm                    $vreturn
611aMC                   parm                    $vreturn8
     C                   parm                    $vmessage

611aDC**                 if        $vreturn <> '*OK'
611aMC                   if        $vreturn8 <> '*OK'
     C                   eval      error = *on
700iDC*                  eval      $preturn = $vreturn
700iAC                   eval      $preturn = $vreturn8
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfyadd
     C                   endif
700iAc*
700iAc*  check to see if slot type being added is *EACH.  If so
700iAc*  and *EACH already exists return error
700iAc                   eval      slwhse = $slwhse
700iAc                   eval      slsdef = $slsdef
700iAC                   exsr      getSlotDef
700iAc                   if        $sdpal = '*EACH'
700iAc                             and $vmessage = '*ONEEACH'
700iAC                   eval      $preturn = '*ERROR'
700iAC                   eval      $pmessage = 'Item (' +
700iAc                             %trim($vitem) + ') can have'
700iAc                             + ' only one *EACH slot'
700iAC                   goto      endvfyadd
700iAc                   endif

700mAc*
700mA*    Item must have breakdown for pallet *each.
700mAc                   if        $sdpal = '*EACH'
700mAc                             and $itum2 = ' '
700mAC                   eval      $preturn = '*ERROR'
700mAC                   eval      $pmessage = 'Item (' +
700mAc                             %trim($vitem) + ') must have'
700mAc                             + ' a breakdown when using *EACH slot'
700mAC                   goto      endvfyadd
700mAc                   endif
     *    See if we already have maximum pick slots for item.

     C                   if        $vcount >= $imnrpk
700kAc                             and $sdpal <> '*EACH'
     C                   eval      error = *on
     C                   eval      $preturn = 'PCKOVRFLW'
     C                   exsr      getmsg
     C                   goto      endvfyadd
     C                   endif

     C                   endif

     C     endvfyadd     endsr

     *----------------------------------------------------------------
     *  verifychg   Verfify slot information for change
     *----------------------------------------------------------------

     C     verifychg     begsr
600tAC                   eval      currRoutine = 'verifychg'
600tAC                   exsr      phpgmV1V2V3s

     *  Get slot information.

     C                   eval      lock = *off
     C                   exsr      getslot1
     C                   if        error
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slaisle = '1'
     C                   eval      $slloce = '1'
     C                   eval      $slrlvle = '1'
     C                   eval      $slhande = '1'
     C                   goto      endvfychg
     C                   endif

     *  If display changed then Slot2 cannot already exist.

     C                   if        $sldispu and $sldisp <> sldisp
     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   select
     C                   when      not error
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLOT2EXIST'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   when      $preturn = 'OPNERRSLT2'
     C                   goto      endvfychg
     C                   other
     C                   eval      error = *off
     C                   eval      $preturn  = '*OK'
     C                   eval      $pmessage = ' '
     C                   endsl
     C                   endif
650zA
650zA*  Status not allowed to be changed to 'V'.
650zA
650zAC                   if        $slstatu and
650zAC                             $slstat <> slstat and
650zAc                             sldesg = 'BFC'
650zAC                   eval      error = *on
650zAC                   eval      $slstate = '1'
650zAC                   eval      $preturn = 'BFCNALLOW'
650zAC                   exsr      getmsg
650zAC                   goto      endvfychg
650zAC                   endif
416uA
416uA*  Status not allowed to be changed to 'V'.
416uA
416uAC                   if        $slstatu and
416uAC                             $slstat = 'V' and slstat <> 'V'
416uAC                   eval      error = *on
416uAC                   eval      $slstate = '1'
416uAC                   eval      $preturn = 'VNOTALLOW'
416uAC                   exsr      getmsg
416uAC                   goto      endvfychg
416uAC                   endif

     *  Slot status cannot be changed to 'V' when qty <> 0
     *    unless stat is already a 'Z'.

     *    Note: New status is $slstat. Old status is slstat.

 1B  C                   if        $slstatu and $slstat <> slstat and
 1B  C                             $slstat = 'V' and slstat <> 'Z'
 2B  C                   if        slstk1 <> 0  or
     C                             slstk2 <> 0  or
     C                             slstk3 <> 0  or
     C                             slalc1 <> 0  or
     C                             slalc2 <> 0  or
     C                             slalc3 <> 0  or
     C                             sltfr1 <> 0  or
     C                             sltfr2 <> 0  or
     C                             sltfr3 <> 0  or
     C                             slpck1 <> 0  or
     C                             slpck2 <> 0  or
     C                             slpck3 <> 0  or
     C                             slrcv1 <> 0  or
     C                             slrcv2 <> 0  or
     C                             slrcv3 <> 0
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = 'INVLDVSTAT'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   endif
     C                   endif

     *  Slot status cannot be changed to 'Z' when qty <> 0

     *    Note: New status is $slstat. Old status is slstat.

 1B  C                   if        $slstatu and $slstat <> slstat and
 1B  C                             $slstat = 'Z'
 2B  C                   if        slstk1 <> 0  or
     C                             slstk2 <> 0  or
     C                             slstk3 <> 0  or
     C                             slalc1 <> 0  or
     C                             slalc2 <> 0  or
     C                             slalc3 <> 0  or
     C                             sltfr1 <> 0  or
     C                             sltfr2 <> 0  or
     C                             sltfr3 <> 0  or
     C                             slpck1 <> 0  or
     C                             slpck2 <> 0  or
     C                             slpck3 <> 0  or
     C                             slrcv1 <> 0  or
     C                             slrcv2 <> 0  or
     C                             slrcv3 <> 0
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = 'INVLDZSTAT'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   endif
     C                   endif


650vA*  Slot status cannot be changed to 'Z' if ckusage returns $upieces >0


650vAC                   if        $slstatu and $slstat <> slstat and
650xAC                             directputaway = *on and
650vAC                             $slstat = 'Z'
650vAc                   exsr      chkusage
650vAC                   if        $upieces > 0
650vAC                   eval      error = *on
650vAC                   eval      $slstate = '1'
650vAC                   eval      $preturn = 'INVLDZSTAT'
650vAC                   exsr      getmsg
650vAC                   goto      endvfychg
650vAC                   endif
650vAC                   endif

PAK AC                   if        client = Packers
PAK A*  Status may not be changed to QA or BL unless slot is empty.
     *    Note: New status is $slstat. Old status is slstat.
PAK AC                   if        $slstatu and $slstat <> slstat and
PAK AC                             $slstat = 'QA'
PAK AC                             or
PAK AC                             $slstatu and $slstat <> slstat and
PAK AC                             $slstat = 'BL'
PAK AC                   if        slstk1 <> 0  or
PAK AC                             slstk2 <> 0  or
PAK AC                             slstk3 <> 0  or
PAK AC                             slalc1 <> 0  or
PAK AC                             slalc2 <> 0  or
PAK AC                             slalc3 <> 0  or
PAK AC                             sltfr1 <> 0  or
PAK AC                             sltfr2 <> 0  or
PAK AC                             sltfr3 <> 0  or
PAK AC                             slpck1 <> 0  or
PAK AC                             slpck2 <> 0  or
PAK AC                             slpck3 <> 0  or
PAK AC                             slrcv1 <> 0  or
PAK AC                             slrcv2 <> 0  or
PAK AC                             slrcv3 <> 0
PAK AC                   eval      error = *on
PAK AC                   eval      $slstate = '1'
PAK AC                   eval      $preturn = 'INVLDPSTAT'
PAK AC                   exsr      getmsg
PAK AC                   goto      endvfychg
PAK AC                   endif
PAK AC                   endif
PAK AC                   endif

     *  When status is Active, item number must be present.

 1B  C                   if        $slstatu and $slstat = 'A' or
 1B  C                             not $slstatu and slstat = 'A'
 2B  C                   if        $slitemu and $slitem = ' ' or
 2B  C                             not $slitemu and slitem = ' '
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'BLANKITEM'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   endif
     C                   endif

     *  Item number cannot change when quantities exist.

 2B  C                   if        $slitemu and $slitem <> slitem
 1B  C                   if        $slstatu and $slstat <> 'Z' or
 1B  C                             not $slstatu and slstat <> 'Z'
 2B  C                   if        slstk1 <> 0  or
     C                             slstk2 <> 0  or
     C                             slstk3 <> 0  or
     C                             slalc1 <> 0  or
     C                             slalc2 <> 0  or
     C                             slalc3 <> 0  or
     C                             sltfr1 <> 0  or
     C                             sltfr2 <> 0  or
     C                             sltfr3 <> 0  or
     C                             slpck1 <> 0  or
     C                             slpck2 <> 0  or
     C                             slpck3 <> 0  or
     C                             slrcv1 <> 0  or
     C                             slrcv2 <> 0  or
     C                             slrcv3 <> 0
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITEMCHG'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   endif
     C                   endif
     C                   endif

     *  Verify that item is allowed in slot.

     C                   if        $slitemu and $slitem <> ' '
     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*VERIFYS'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   goto      endvfychg
     C                   endif
740 A
740 AC                   else
740 A
740 AC                   if        $slitemu and $slitem = ' '
740 A*    If no item in slot, still need to initialize $item,$item2.
740 AC                   exsr      clr$item
740 AC                   endif
740 A*
     C                   endif

     *  Get item information.

416mMC                   if        $slitemu and $slitem <> ' ' or
416mAC                             not $slitemu and slitem <> ' '
     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETALL'
     C                   if        $slitemu
     C                   eval      item# = $slitem
     C                   else
     C                   eval      item# = slitem
     C                   endif
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   goto      endvfychg
     C                   endif

416mAC                   eval      #slotitem = $ititem
416mAC                   eval      #slottype = $ittype
416mAC                   eval      #slotdesc = $itdesc
416mAC                   eval      #slotpdsc = $itpdsc
416mAC                   eval      #slotwhdp = $itwhdp
416mAC                   eval      #slotstyp = $itstyp
416mAC                   eval      #slotdesg = $itdesg
416mAC                   eval      #slotum1  = $itum1
416mAC                   eval      #slotflg1 = $itflg1
416mAC                   eval      #slotum2  = $itum2
416mAC                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
416mAC                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
416nAC                   eval      #slotswgt = $itswgt
416nAC                   eval      #slotcwgt = $itcwgt

     C                   eval      check4err = *off
     C                   eval      desigcode = $itdesg
     C                   exsr      getdesig
     C                   eval      #dtypeitem = $dstype
     C                   endif

650tA*  If on-demand repack, item cannot be put in normal pick slot
650tA*  confirms that slot must be either virtual or RP status pick
650tA*  slot before allowing user to assign slot to on-demand repack
650tA
650tA /free
650tA                 if $slitem <> ' ';
650tA                    chain ($itwhse:$ititem) kititem;
650tA                    if %found(kititem) and kirptp='2';
650tA                       if $ittype = 'R' and slpick ='Y'
650tA                            and slstat <> 'RP';
650tA                          chain (slwhse:slwhdp:sldisp) vslot1;
650tA                          if not %found(vslot1);
650tA                             eval error = *on;
650tA                             $sliteme = '1';
650tA                             $preturn = 'SLTNOTRPK';
650tA                             exsr getmsg;
650tA /end-free
650tAc                   goto      endvfychg
650tAc                   endif
650tAc                   endif
650tAc                   endif
650tAc                   endif

     *  Get slot designation type if designation wasn't sent in.
     *  If it was sent, then the type was retreived in verifygen.

     C                   if        not $sldesgu
     C                   eval      check4err = *off
     C                   eval      desigcode = sldesg
     C                   exsr      getdesig
     C                   eval      #dtypeslot = $dstype
     C                   endif

     *  For an active slot ...

MQS A*
MQS A*    if slot def for current slot matches Staging/Store slot def then
MQS A*    force "S" or #dtypeitem to ignore next check
MQS A*
MQS Ac                   if        client = Marques
MQS Ac                   if        $slsdef = oprzst
MQS Ac                             and #dtypeitem='H'
MQS Ac                   eval      #dtypeitem = 'S'
MQS Ac                   endif
MQS Ac                   endif
     *    Then the dept, section and designation area must match item.
     *    Otherwise, match isn't necessary.

     C                   if        $slstatu and $slstat = 'A' or
     C                             not $slstatu and slstat = 'A'
     C                   if        $slwhdp <> $itwhdp or
     C                             $slstypu and $slstyp <> $itstyp or
     C                             not $slstypu and slstyp <> $itstyp or
     C                             $sldesgu and $sldesg <> $itdesg and
     C                               #dtypeslot ='H' or
     C                             $sldesgu and $sldesg <> $itdesg and
     C                               #dtypeitem ='H' or
     C                             not $sldesgu and sldesg <> $itdesg and
     C                               #dtypeslot ='H' or
     C                             not $sldesgu and sldesg <> $itdesg and
     C                               #dtypeitem ='H'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slstype = '1'
     C                   eval      $sldesge = '1'
     C                   eval      $preturn = 'ISMISMTCH'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   endif
     C                   endif

416mM*  Special checks for a fixed, pick slot where the
416mA*    status is being changed to Active.

     C                   if        $slstypu and $slstyp = 'F' or
     C                             not $slstypu and slstyp = 'F'
416mDC**                 if        $slstatu and $slstat = 'A' or
416mDC**                           not $slstatu and slstat = 'A'
     C                   if        $slpicku and $slpick = 'Y' or
     C                             not $slpicku and slpick = 'Y'
416mAC                   if        $slstatu and $slstat = 'A' and
416mAC                             slstat <> 'A'
510gAC                             or $slstatu and $slstat = 'A '
510gAC                             and slstat = 'A '
510gAC                             and $slitem <> slitem
730aAc                             or $slpicku and $slpick = 'Y'
730aAc                             and slpick = 'N'

     *    Make sure maximum number of picks slots is <= 1 if ...
     *      Department is Directed putaway
     *      or mulitple pick slots are not allowed.

     C                   if        DirectPutaway or opmpck <> 'Y'
     C                   if        $imnrpk > 1
     C                   eval      $imnrpk = 1
     C                   endif
     C                   endif

     *    Count existing active pick slots for item.

     C                   call      'CNTPICK'
     C                   parm      $slwhse       $vwhse
     C                   parm      $slitem       $vitem
     C                   parm      ' '           $vwhdp
     C                   parm      ' '           $vdisp
     C                   parm                    $vcount
611aDC**                 parm                    $vreturn
611aMC                   parm                    $vreturn8
     C                   parm                    $vmessage

611aDC**                 if        $vreturn <> '*OK'
611aMC                   if        $vreturn8 <> '*OK'
     C                   eval      error = *on
700iDC*                  eval      $preturn = $vreturn
700iAC                   eval      $preturn = $vreturn8
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfychg
     C                   endif
510gA
510gA*    Increment $vcount to include new slot if previous status
510gA*    was not 'A ' or status=A and item number is changing.
510gA
510gAC                   if        $slstatu and $slstat = 'A '
510gAC                             and slstat <> 'A '
510gAC                             or $slstatu and $slstat = 'A '
510gAC                             and slstat = 'A '
510gAC                             and $slitem <> slitem
650JaC                             or $slpick <> slpick
750gAc                   eval      slwhse = $slwhse
750gAc                   eval      slsdef = $slsdef
700iAC                   exsr      getSlotDef
700iAc                   if        $sdpal <> '*EACH'
510gAC                   eval      $vcount = $vcount + 1
700iAc                   else
700iAc                   if        $vmessage = '*ONEEACH'
700iAC                   eval      $preturn = '*ERROR'
700iAC                   eval      $pmessage = 'Item (' +
700iAc                             %trim($vitem) + ') can have'
700iAc                             + ' only one *EACH slot'
700iAC                   goto      endvfychg
700iAc                   endif
700iAc                   endif
510gAC                   endif

700mAc*
700mA*    Item must have breakdown for pallet *each.
700mAc                   if        $sdpal = '*EACH'
700mAc                             and $itum2 = ' '
700mAC                   eval      $preturn = '*ERROR'
700mAC                   eval      $pmessage = 'Item (' +
700mAc                             %trim($vitem) + ') must have'
700mAc                             + ' a breakdown when using *EACH slot'
700mAC                   goto      endvfychg
700mAc                   endif
     *    See if we already have maximum pick slots for item.

730fAc                   if        $slitem <> ' ' or slitem <> ' '
     C                   if        $slpick = slpick and
     C                             $vcount > $imnrpk or
     C                             $slpick <> slpick and
650jDC*                            $vcount >= $imnrpk
650jMC                             $vcount > $imnrpk
     C                   eval      error = *on
     C                   eval      $preturn = 'PCKOVRFLW'
     C                   exsr      getmsg
     C                   goto      endvfychg
     C                   endif
730fAc                   endif

     C                   endif
     C                   endif
     C                   endif


     C     endvfychg     endsr

710jA*----------------------------------------------------------------
710jA*  verifyClass Class verification for Food Safety.
710jA*----------------------------------------------------------------

710jAC     verifyClass   begsr
710jA /free
740bA   exsr openslot1;
        setll ($slwhse: #toitem) itemcls;
        dow forever = forever;
          reade ($slwhse: #toitem) itemcls;
          if %eof(itemcls);
            leavesr;
          endif;
          // item has a class setup
          setll (iclcde) classrule;
          dow forever = forever;
            reade (iclcde) classrule;
            if %eof(classrule);
              leave;
            endif;
            // have a class rule for this item/class
            // check if level above is defined
            if carabv > 0;
              select;
                when carabv = 99;
                  classlevel = 0;
                other;
                  classlevel = slrlvl - carabv;
                  if classlevel < 0;
                    classlevel = 0;
                  endif;
              endsl;
              // now go read slot
              saveslrec = slrecds;
              setll (slwhse: slwhdp: slaisl: slloc: classlevel) slot1;
              dow forever = forever;
                reade (slwhse: slwhdp: slaisl: slloc) slot1;
                if %eof(slot1);
                  slrecds = saveslrec;
                  leave;
                endif;
                // if slot level is GT putaway level
                if slrlvl > saveslrec.slrlvl;
                  slrecds = saveslrec;
                  leave;
                endif;
                // if slot doesn't contain an item
                if slitem = ' ';
                  slrecds = saveslrec;
                  iter;
                endif;
                // if item is not assigned to class2 of rules
                if slitem <> ' ';
                  // need to save the current record from itemcls so I
                  // don't lose my original file position
                  saveiclwhs = iclwhs;
                  saveiclitm = iclitm;
                  saveiclcde = iclcde;

                  setll (slwhse: slitem: carcl2) itemcls;
                  if %equal;
                    error = *on;
                    $preturn = 'ITEMCLS1';
                    leavesr;
                  else;
                    slrecds = saveslrec;
                    // restore original itemcls position
                    setgt (saveiclwhs: saveiclitm: saveiclcde) itemcls;
                    iter;
                  endif;
                endif;
              enddo;
            endif;

            // check if level below is defined
            if carblw > 0;
              select;
                when carblw = 99;
                  classlevel = 99;
                other;
                  if (slrlvl + carblw) > 99;
                    classlevel = 99;
                  else;
                    classlevel = slrlvl + carblw;
                  endif;
              endsl;
              // now go read slot
              saveslrec = slrecds;
              setll (slwhse: slwhdp: slaisl: slloc: slrlvl) slot1;
              dow forever = forever;
                reade (slwhse: slwhdp: slaisl: slloc) slot1;
                if %eof(slot1);
                  slrecds = saveslrec;
                  leave;
                endif;
                // if slot level is GT max level
                if slrlvl > classlevel;
                  slrecds = saveslrec;
                  leave;
                endif;
                // if slot doesn't contain an item
                if slitem = ' ';
                  slrecds = saveslrec;
                  iter;
                endif;
                // if item is not assigned to class2 of rules
                if slitem <> ' ';
                  // need to save the current record from itemcls so I
                  // don't lose my original file position
                  saveiclwhs = iclwhs;
                  saveiclitm = iclitm;
                  saveiclcde = iclcde;

                  setll (slwhse: slitem: carcl2) itemcls;
                  if %equal;
                    error = *on;
                    $preturn = 'ITEMCLS2';
                    leavesr;
                  else;
                    slrecds = saveslrec;
                    // restore original itemcls position
                    setgt (saveiclwhs: saveiclitm: saveiclcde) itemcls;
                    iter;
                  endif;
                endif;
              enddo;
            endif;

            // check for locations left
            if carllr > 0;
              // lets check left first
              select;
                when carllr = 99;
                  LeftLoc  = 0;
                other;
                  LeftLoc  = slloc  - carllr;
                  if LeftLoc  < 0;
                    LeftLoc  = 0;
                  endif;
              endsl;
              // now go read slot
              saveslrec = slrecds;
              // check locations left
              dow LeftLoc <> slloc;
                setll (slwhse: slwhdp: slaisl: LeftLoc: slrlvl) slot1;
                dow forever = forever;
                  reade (slwhse: slwhdp: slaisl:
                         LeftLoc: slrlvl) slot1;
                  if %eof(slot1);
                    slrecds = saveslrec;
                    LeftLoc = LeftLoc + 1;
                    leave;
                  endif;
                  // if slot doesn't contain an item
                  if slitem = ' ';
                    slrecds = saveslrec;
                    iter;
                  endif;
                  // if item is not assigned to class2 of rules
                  if slitem <> ' ';
                    // save the current record from itemcls so I
                    // don't lose my original file position
                    saveiclwhs = iclwhs;
                    saveiclitm = iclitm;
                    saveiclcde = iclcde;

                    setll (slwhse: slitem: carcl2) itemcls;
                    if %equal;
                      error = *on;
                      $preturn = 'ITEMCLS3';
                      leavesr;
                    else;
                      slrecds = saveslrec;
                      // restore original itemcls position
                      setgt (saveiclwhs: saveiclitm:
                             saveiclcde) itemcls;
                      iter;
                    endif;
                  endif;
                enddo;
              enddo;
            endif;
            // check for locations right
            if carllr > 0;
              // lets check right now
              select;
                when carllr = 99;
                  RightLoc  = 999;
                other;
                  if (slloc + carllr) > 999;
                    RightLoc = 999;
                  else;
                    RightLoc = slloc + carllr;
                  endif;
              endsl;
              // now go read slot
              saveslrec = slrecds;
              // check locations right
              dow RightLoc <> slloc;
                setll (slwhse: slwhdp: slaisl: RightLoc: slrlvl) slot1;
                dow forever = forever;
                  reade (slwhse: slwhdp: slaisl:
                         RightLoc: slrlvl) slot1;
                  if %eof(slot1);
                    slrecds = saveslrec;
                    RightLoc = RightLoc - 1;
                    leave;
                  endif;
                  // if slot doesn't contain an item
                  if slitem = ' ';
                    slrecds = saveslrec;
                    iter;
                  endif;
                  // if item is not assigned to class2 of rules
                  if slitem <> ' ';
                    // save the current record from itemcls so I
                    // don't lose my original file position
                    saveiclwhs = iclwhs;
                    saveiclitm = iclitm;
                    saveiclcde = iclcde;

                    setll (slwhse: slitem: carcl2) itemcls;
                    if %equal;
                      error = *on;
                      $preturn = 'ITEMCLS3';
                      leavesr;
                    else;
                      slrecds = saveslrec;
                      // restore original itemcls position
                      setgt (saveiclwhs: saveiclitm:
                             saveiclcde) itemcls;
                      iter;
                    endif;
                  endif;
                enddo;
              enddo;
            endif;
          enddo;
        enddo;
710jA /end-free
710jAC     endvfyclass   endsr
     *----------------------------------------------------------------
     *  verifygen   General verification.
     *----------------------------------------------------------------

     C     verifygen     begsr
600tAC                   eval      currRoutine = 'verifygen'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Verify warehouse.

     C                   eval      vfywhse = *on
     C                   call(e)   'VFYWHSE'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $slwhse       $vwhse
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYWHSE'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endvfygen

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfygen

     C                   endsl

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfygen
     C                   endif

     *  Aisle must be sent.

     C                   if        not $slaislu or $slaisl = ' '
     C                   eval      error = *on
     C                   eval      $slaisle = '1'
     C                   eval      $preturn = 'ASLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Location must be sent.

     C                   if        not $sllocu
     C                   eval      error = *on
     C                   eval      $slloce = '1'
     C                   eval      $preturn = 'LOCNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Location can't be negative.

     C                   if        $slloc < 0
     C                   eval      error = *on
     C                   eval      $slloce = '1'
     C                   eval      $preturn = 'NEGATIVLOC'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Level must be sent.

     C                   if        not $slrlvlu
     C                   eval      error = *on
     C                   eval      $slrlvle = '1'
     C                   eval      $preturn = 'LVLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Level can't be negative.

     C                   if        $slrlvl < 0
     C                   eval      error = *on
     C                   eval      $slrlvle = '1'
     C                   eval      $preturn = 'NEGATIVLVL'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Handstack must be sent.

     C                   if        not $slhandu
     C                   eval      error = *on
     C                   eval      $slhande = '1'
     C                   eval      $preturn = 'HNDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Slot display cannot be blank.

     C                   if        $sldispu and $sldisp = ' '
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'BLANKDISP'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Verify slot type.

     C                   if        $slstypu and $psubcmd <> '*ADDXDK'
     C                   if        $slstyp <> 'F' and $slstyp <> 'P'
     C                   eval      error = *on
     C                   eval      $slstype = '1'
     C                   eval      $preturn = 'INVLDSTYP'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif
     C                   endif

     *  Picking seq can't be negative.

     C                   if        $slpsequ and $slpseq < 0
     C                   eval      error = *on
     C                   eval      $slpseqe = '1'
     C                   eval      $preturn = 'NEGATIVPSQ'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif

     *  Verify slot definition.

     C                   if        $slsdefu
     C                   eval      vfysdef = *on
     C                   call(e)   'VFYSDEF'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $slwhse       $vwhse
     C                   parm      $slsdef       $vsdef
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $slsdefe = '1'
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYSDEF'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endvfygen

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $slsdefe = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfygen

     C                   endsl
     C                   endif

     *  Verify status code.

     C                   if        $slstatu
     C                   eval      vfysstat = *on
     C                   call(e)   'VFYSSTAT'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $slstat       $vstat
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYSSTAT'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endvfygen

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfygen

     C                   endsl
     C                   endif

     *  Verify build code.

     C                   if        $slbldu
     C                   eval      vfybld = *on
     C                   call(e)   'VFYBLD'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $slbld        $vbld
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $slblde = '1'
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYBLD'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endvfygen

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $slblde = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfygen

     C                   endsl
     C                   endif

     *  Verify activity zone code.

     C                   if        $slactvu
     C                   eval      vfyactv = *on
     C                   call(e)   'VFYACTV'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $slactv       $vactv
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $slactve = '1'
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYACTV'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endvfygen

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $slactve = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfygen

     C                   endsl
     C                   endif

     *  Verify designation code.

     C                   if        $sldesgu
     C                   eval      check4err = *on
     C                   eval      desigcode = $sldesg
     C                   exsr      getdesig
     C                   if        error
     C                   eval      $sldesge = '1'
     C                   goto      endvfygen
     C                   endif
     C                   eval      #dtypeslot = $dstype
     C                   endif

     *  Verify pick flag.

     C                   if        $slpicku
     C                   if        $slpick <> 'Y' and $slpick <> 'N'
     C                   eval      error = *on
     C                   eval      $slpicke = '1'
     C                   eval      $preturn = 'INVLDPICK'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif
     C                   endif

     *  Verify reserved flag.

     C                   if        $slrsrvu
     C                   if        $slrsrv <> 'Y' and
     C                             $slrsrv <> 'N' and
     C                             $slrsrv <> 'V'
417oAC*    Item was at Reserve=Y or Reserve=N, Can't chg to V=Virtual.
417oAC                             or  slrsrv = 'Y'
417oAC                             and $slrsrv = 'V'
417oAC                             or  slrsrv = 'N'
417oAC                             and $slrsrv = 'V'
     C                   eval      error = *on
417oDC*                  eval      $slpicke = '1'
417oMC                   eval      $slrsrve = '1'
     C                   eval      $preturn = 'INVLDRSRV'
     C                   exsr      getmsg
     C                   goto      endvfygen
     C                   endif
     C                   endif

     C     endvfygen     endsr

510dA*----------------------------------------------------------------
510dA*  verifygetrpk  GETREPACK verification
510dA*----------------------------------------------------------------
510dA
510dAC     verifygetrpk  begsr
600tAC                   eval      currRoutine = 'verifygetrpk'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetrpk
     C                   endif

     *    Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetrpk
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfygetrpk
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfygetrpk
     C                   endif

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
     C                   eval      #slotswgt = $itswgt
     C                   eval      #slotcwgt = $itcwgt

     C     endvfygetrpk  endsr
650hA*----------------------------------------------------------------
650hA*  verifyodrrpk  GETODRRPK verification
650hA*----------------------------------------------------------------
650hA
650hAC     verifyodrrpk  begsr
650hAC                   eval      currRoutine = 'verifyodrrpk'
650hAC                   exsr      phpgmV1V2V3s
650hA
650hA*  Clear error flags.

650hAC                   exsr      clearerrflags

     *  Warehouse must be sent.

650hAC                   if        not $slwhseu
650hAC                   eval      error = *on
650hAC                   eval      $slwhsee = '1'
650hAC                   eval      $preturn = 'WHSNOTSNT'
650hAC                   exsr      getmsg
650hAC                   goto      endvfyodrrpk
650hAC                   endif

     *    Item must be sent.

650hAC                   if        not $slitemu
650hAC                   eval      error = *on
650hAC                   eval      $sliteme = '1'
650hAC                   eval      $preturn = 'ITMNOTSNT'
650hAC                   exsr      getmsg
650hAC                   goto      endvfyodrrpk
650hAC                   endif

     *  Get "sent" item information.

650hAC                   eval      check4err = *on
650hAC                   eval      $drisubcmd = '*GETPARENT'
650hAC                   eval      item# = $slitem
650hAC                   exsr      getitem
650hAC                   if        error
650hAC                   goto      endvfyodrrpk
650hAC                   endif

650hAC                   eval      #sentitem = $ititem
650hAC                   eval      #senttype = $ittype
650hAC                   eval      #sentdesc = $itdesc
650hAC                   eval      #sentpdsc = $itpdsc
650hAC                   eval      #sentwhdp = $itwhdp
650hAC                   eval      #sentstyp = $itstyp
650hAC                   eval      #sentdesg = $itdesg
650hAC                   eval      #sentum1  = $itum1
650hAC                   eval      #sentflg1 = $itflg1
650hAC                   eval      #sentum2  = $itum2
650hAC                   eval      #sentumq2 = $itumq2
650hAC                   eval      #sentflg2 = $itflg2
650hAC                   eval      #sentum3  = $itum3
650hAC                   eval      #sentumq3 = $itumq3

650hAC     endvfyodrrpk  endsr

416jA*----------------------------------------------------------------
416jA*  verifygetxdk  GETXDK verification.
416jA*----------------------------------------------------------------
416jA
416jAC     verifygetxdk  begsr
600tAC                   eval      currRoutine = 'verifygetxdk'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetxdk
     C                   endif

     *    Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetxdk
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfygetxdk
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfygetxdk
     C                   endif

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
416nAC                   eval      #slotswgt = $itswgt
416nAC                   eval      #slotcwgt = $itcwgt

     C     endvfygetxdk  endsr

416bA*----------------------------------------------------------------
416bA*  verifynxtprv Nxt/Prv verification.
416bA*----------------------------------------------------------------
416bA
416bAC     verifynxtprv  begsr
600tAC                   eval      currRoutine = 'verifynxtprv'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif
416rA
416rA*  Checks for PICKAV.
416rA
416rAC                   if        $psubcmd = '*NXTPICKAV'
416rA
416rA*    Item must be sent.
416rA
416rAC                   if        not $slitemu
416rAC                   eval      error = *on
416rAC                   eval      $sliteme = '1'
416rAC                   eval      $preturn = 'ITMNOTSNT'
416rAC                   exsr      getmsg
416rAC                   goto      endvfynxtprv
416rAC                   endif
416rA
416rA*    Status must be sent.
416rA
416rAC                   if        not $slstatu
416rAC                   eval      error = *on
416rAC                   eval      $slstate = '1'
416rAC                   eval      $preturn = 'STSNOTSNT'
416rAC                   exsr      getmsg
416rAC                   goto      endvfynxtprv
416rAC                   endif
416tA
416tA*  If priority not sent, set to -9.
416tA
416tAC                   if        not $slprtyu
416tAC                   eval      $slprty = -9
416rAC                   endif
416rA
416rAC                   endif

     *  Checks for ITEM, OVRF and PICK.

     C                   if        $psubcmd = '*NXTITEM' or
500 AC                             $psubcmd = '*NXTITEMAV' or
     C                             $psubcmd = '*PRVITEM' or
     C                             $psubcmd = '*NXTOVRF' or
417gAC                             $psubcmd = '*NXTOVRFAV' or
500bDC**                           $psubcmd = '*GETOVRFAV' or
     C                             $psubcmd = '*PRVOVRF' or
     C                             $psubcmd = '*NXTPICK' or
417gAC                             $psubcmd = '*NXTPICKAV' or
     C                             $psubcmd = '*PRVPICK'

     *    Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Status must be sent.

     C                   if        not $slstatu
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = 'STSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Aisle must be sent.

     C                   if        not $slaislu
     C                   eval      error = *on
     C                   eval      $slaisle = '1'
     C                   eval      $preturn = 'ASLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Pick seq must be sent.

     C                   if        not $slpsequ
     C                   eval      error = *on
     C                   eval      $slpseqe = '1'
     C                   eval      $preturn = 'PSEQNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Level must be sent.

     C                   if        not $slrlvlu
     C                   eval      error = *on
     C                   eval      $slrlvle = '1'
     C                   eval      $preturn = 'LVLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Handstack must be sent.

     C                   if        not $slhandu
     C                   eval      error = *on
     C                   eval      $slhande = '1'
     C                   eval      $preturn = 'HNDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Priority must be sent.

     C                   if        not $slprtyu
     C                   eval      error = *on
     C                   eval      $slprtye = '1'
     C                   eval      $preturn = 'PRTYNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Expiration date must be sent.

     C                   if        not $slexpdu
     C                   eval      error = *on
     C                   eval      $slexpde = '1'
     C                   eval      $preturn = 'EXPDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Enter date must be sent.

     C                   if        not $slentdu
     C                   eval      error = *on
     C                   eval      $slentde = '1'
     C                   eval      $preturn = 'ENTDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Extra checks for ITEM.

     *      Pick flag must be sent.

     C                   if        $psubcmd = '*NXTITEM' or
500 AC                             $psubcmd = '*NXTITEMAV' or
     C                             $psubcmd = '*PRVITEM'
     C                   if        not $slpicku
     C                   eval      error = *on
     C                   eval      $slpicke = '1'
     C                   eval      $preturn = 'PCKNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif
     C                   endif

     C                   endif

     *  Checks for SLOTI.

     C                   if        $psubcmd = '*NXTSLOTI' or
     C                             $psubcmd = '*PRVSLOTI'

     *    Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Aisle must be sent.

     C                   if        not $slaislu
     C                   eval      error = *on
     C                   eval      $slaisle = '1'
     C                   eval      $preturn = 'ASLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Location must be sent.

     C                   if        not $sllocu
     C                   eval      error = *on
     C                   eval      $slloce = '1'
     C                   eval      $preturn = 'LOCNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Level must be sent.

     C                   if        not $slrlvlu
     C                   eval      error = *on
     C                   eval      $slrlvle = '1'
     C                   eval      $preturn = 'LVLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Handstack must be sent.

     C                   if        not $slhandu
     C                   eval      error = *on
     C                   eval      $slhande = '1'
     C                   eval      $preturn = 'HNDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     C                   endif

     *  Checks for SLOT.

     C                   if        $psubcmd = '*NXTSLOT' or
417aMC                             $psubcmd = '*PRVSLOT' or
417aAC                             $psubcmd = '*NXTVSLOT' or
417aAC                             $psubcmd = '*PRVVSLOT'

     *    Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     C                   endif
417aA
417aA*  Checks for VSLOT.
417aA
     C                   if        $psubcmd = '*NXTVSLOT' or
     C                             $psubcmd = '*PRVVSLOT'

     *    Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     *    Corresponding slot display (Base slot) must be sent.

     C                   if        not $sacdspu
     C                   eval      error = *on
     C*****              eval      $sacdspe = '1'
     C                   eval      $preturn = 'CDSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfynxtprv
     C                   endif

     C                   endif

     C     endvfynxtprv  endsr

416bA*----------------------------------------------------------------
416bA*  verifypick   Verify number of pick slots.
416bA*----------------------------------------------------------------

416bAC     verifypick    begsr
600tAC                   eval      currRoutine = 'verifypick'
600tAC                   exsr      phpgmV1V2V3s
500sAC                   eval      $imnrpk = #slotnrpk

     *  Verify that the # of pick slots doesn't exceed maximum for item.

     *    Only check Fixed pick slots.

     C                   if        slstyp <> 'F' or slpick <> 'Y'
     C                   goto      endverifypick
     C                   endif

     *    Only check when receiving slot is at status 'V' or 'Z'.
     *    (For active slots we assume that this check was already done)

     C                   if        slstat <> 'V' and slstat <> 'Z'
     C                   goto      endverifypick
     C                   endif

     *      Make sure maximum number of picks slots is <= 1 if
     *         mulitple pick slots are not allowed.

     C                   if        opmpck <> 'Y' and #slotnrpk > 1
     C                   eval      #slotnrpk = 1
     C                   endif

500uDC**     Special case for transfers ... *** NOT ANY MORE ***
500uDC**
500uDC**       Since we do not know the "From" slot, we do not know
500uDC**       if we are moving from one pick slot to another.
500uDC**       Therefore, increase the maximum by 1 to allow for this.
500uDC**
500uDC**       Note: This does leave open the possibility of doing a
500uDC**             transfer from an overflow to a new pick slot, with
500uDC**             the end result of having more pick slots than allowed.

500sDC**                 if        $psubcmd = '*TFROUT' or
500sDC**                           $psubcmd = '*LETOUT' or
500sDC**                           $psubcmd = '*PROUT' or
500sDC**                           $psubcmd = '*SSOUT' or
500sDC**                           $psubcmd = '*CLSTFROUT' or
500sDC**                           $psubcmd = '*CLSLETOUT' or
500sDC**                           $psubcmd = '*CLSPROUT'  or
500sDC**                           $psubcmd = '*CLSSSOUT'

500uDC**                 if        $psubcmd = '*TFRINCHG'  or
500uDC**                           $psubcmd = '*LETINCHG'  or
500uDC**                           $psubcmd = '*PRINCHG'  or
500uDC**                           $psubcmd = '*SSINCHG'  or
500uDC**                           $psubcmd = '*CLSTFICHG' or
500uDC**                           $psubcmd = '*CLSLTICHG' or
500uDC**                           $psubcmd = '*CLSPRICHG' or
500uDC**                           $psubcmd = '*CLSSSICHG' or
500uDC**                           $psubcmd = '*VFYTFICHG' or
500uDC**                           $psubcmd = '*VFYLTICHG' or
500uDC**                           $psubcmd = '*VFYPRICHG' or
500uDC**                           $psubcmd = '*VFYSSICHG'
500uDC**                 eval      #slotnrpk = #slotnrpk + 1
500uDC**                 endif

     *      Count existing active pick slots for item.

500uA*      Note, there are 2 counting programs depending on whether
500uA*      we are doing a transfer in or not.

600dDC**                 if        $psubcmd = '*TFRINCHG'  or
600dDC**                           $psubcmd = '*CLSTFICHG' or
600dDC**                           $psubcmd = '*VFYTFICHG'

600dMC                   if        $saAction = 'TFR'
700eAC                   if        $psubcmd = '*USR2PUT'
700eAC                   eval      $vwhdp = $sacwhd
700eAC                   else
700eAC                   eval      $vwhdp = $slwhdp
700eAC                   endif

500uAC                   call      'CNTPICKTFR'
500uAC                   parm      $slwhse       $vwhse
500uAC                   parm      #slotitem     $vitem
700eDC**                 parm      $slwhdp       $vwhdp
700eMC                   parm                    $vwhdp
500uAC                   parm      $sldisp       $vdisp
500uAC                   parm      $sacdsp       $vfrom
500uAC                   parm                    $vcount
611aDC**                 parm                    $vreturn
611aMC                   parm                    $vreturn8
500uAC                   parm                    $vmessage

500uAC                   else

     C                   call      'CNTPICK'
500nDC**                 parm      slwhse        $vwhse
500nDC**                 parm      slitem        $vitem
500nMC                   parm      $slwhse       $vwhse
500qDC**                 parm      $saitem       $vitem
500qMC                   parm      #slotitem     $vitem
     C                   parm      ' '           $vwhdp
     C                   parm      ' '           $vdisp
     C                   parm                    $vcount
611aDC**                 parm                    $vreturn
611aMC                   parm                    $vreturn8
     C                   parm                    $vmessage

500uAC                   endif

611aDC**                 if        $vreturn <> '*OK'
611aMC                   if        $vreturn8 <> '*OK'
     C                   eval      error = *on
700iDC*                  eval      $preturn = $vreturn
700iAC                   eval      $preturn = $vreturn8
     C                   eval      $pmessage = $vmessage
     C                   goto      endverifypick
     C                   endif

     *      See if we already have maximum pick slots for item.

     C                   if        $vcount >= #slotnrpk
MRTbAc                   if        client=Merit
MRTbAc                             and $slstat<>'RP'
     C                   eval      error = *on
     C                   eval      $preturn = 'PCKOVRFLW'
     C                   exsr      getmsg
     C                   goto      endverifypick
MRTbAC                   endif
     C                   endif

     C     endverifypick endsr

416dA*----------------------------------------------------------------
416dA*  verifyqty  Verify information when changing quantities.
416dA*----------------------------------------------------------------
416dA
416daC     verifyqty     begsr
600tAC                   eval      currRoutine = 'verifyqty'
600tAC                   exsr      phpgmV1V2V3s
600dAC                   eval      itemChanged = *off

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfyqty
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif

     *  Item must be sent.

     C                   if        not $saitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif
417dA
417dA*  Corresponding item can only be sent for some operations.
417dA
417dAC                   if        $sacitemu
417fAC                   if        $psubcmd <> '*TFRINCHG'  and
417hAC                             $psubcmd <> '*LETINCHG'  and
417hAC                             $psubcmd <> '*PRINCHG'  and
417hAC                             $psubcmd <> '*SSINCHG'  and
417fAC                             $psubcmd <> '*TFROUTCHG' and
417hAC                             $psubcmd <> '*LETOUTCHG' and
417hAC                             $psubcmd <> '*PROUTCHG' and
417hAC                             $psubcmd <> '*SSOUTCHG' and
417fAC                             $psubcmd <> '*CLSTFICHG' and
417hAC                             $psubcmd <> '*CLSLTICHG' and
417hAC                             $psubcmd <> '*CLSPRICHG' and
417hAC                             $psubcmd <> '*CLSSSICHG' and
417fAC                             $psubcmd <> '*CLSTFOCHG' and
417hAC                             $psubcmd <> '*CLSLTOCHG' and
417hAC                             $psubcmd <> '*CLSPROCHG' and
417hAC                             $psubcmd <> '*CLSSSOCHG' and
600dAC                             $psubcmd <> '*TFR2USR' and
610sAC                             $psubcmd <> '*TFR2USRR' and
640dAC                             $psubcmd <> '*TFR2USRN' and
600dAC                             $psubcmd <> '*USR2PUT' and
720 AC                             $psubcmd <> '*USR2RPA' and
417fAC                             $psubcmd <> '*VFYTFICHG' and
417hAC                             $psubcmd <> '*VFYLTICHG' and
417hAC                             $psubcmd <> '*VFYPRICHG' and
417hAC                             $psubcmd <> '*VFYSSICHG' and
417fAC                             $psubcmd <> '*VFYTFOCHG' and
417hAC                             $psubcmd <> '*VFYLTOCHG' and
417hAC                             $psubcmd <> '*VFYPROCHG' and
417hAC                             $psubcmd <> '*VFYSSOCHG' and
500jAC                             $psubcmd <> '*VFYCLSTFI' and
500jAC                             $psubcmd <> '*VFYCLSLTI' and
500jAC                             $psubcmd <> '*VFYCLSPRI' and
500jAC                             $psubcmd <> '*VFYCLSSSI' and
500jAC                             $psubcmd <> '*VFYCLSTIC' and
500jAC                             $psubcmd <> '*VFYCLSLIC' and
500jAC                             $psubcmd <> '*VFYCLSPIC' and
500jAC                             $psubcmd <> '*VFYCLSSIC' and
500jAC                             $psubcmd <> '*VFYCLSTFO' and
500jAC                             $psubcmd <> '*VFYCLSLTO' and
500jAC                             $psubcmd <> '*VFYCLSPRO' and
500jAC                             $psubcmd <> '*VFYCLSSSO' and
500jAC                             $psubcmd <> '*VFYCLSTOC' and
500jAC                             $psubcmd <> '*VFYCLSLOC' and
500jAC                             $psubcmd <> '*VFYCLSPOC' and
500jAC                             $psubcmd <> '*VFYCLSSOC'
417dAC                   eval      error = *on
417dAC                   eval      $saciteme = '1'
417dAC                   eval      $preturn = 'CITMNOTALW'
417dAC                   exsr      getmsg
417dAC                   goto      endvfyqty
417dAC                   endif
417dAC                   endif

     *  Adjustment qtys must be sent.

     C                   if        not $saqtyu
     C                   eval      error = *on
     C                   eval      $saqty1e = '1'
     C                   eval      $saqty2e = '1'
     C                   eval      $saqty3e = '1'
     C                   eval      $preturn = 'QTYNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif

     *  Original qtys cannot be sent for some operations.

     C                   if        $saorgu
     C                   if        $psubcmd = '*ALLOCATE' or
     C                             $psubcmd = '*PICK'     or
     C                             $psubcmd = '*RECEIVE'  or
417hAC                             $psubcmd = '*PUTAWAY'  or
500xAC                             $psubcmd = '*STAGEPUT' or
417hAC                             $psubcmd = '*RETURN'   or
     C                             $psubcmd = '*STOCK'    or
     C                             $psubcmd = '*TFRIN'    or
417hAC                             $psubcmd = '*LETIN'    or
417hAC                             $psubcmd = '*PRIN'     or
417hAC                             $psubcmd = '*SSIN'     or
600dAC                             $psubcmd = '*RCVIN'    or
720 AC                             $psubcmd = '*RPAIN'    or
700sAC                             $psubcmd = '*RTNIN'    or
730eAC                             $psubcmd = '*RWOIN'    or
600dAC                             $psubcmd = '*STGIN'    or
600dAC                             $psubcmd = '*OSSIN'    or
611eAC                             $psubcmd = '*PREIN'    or
700dAC                             $psubcmd = '*AMPIN'    or
600dAC                             $psubcmd = '*USRIN'    or
     C                             $psubcmd = '*TFROUT'   or
417hAC                             $psubcmd = '*LETOUT'   or
417hAC                             $psubcmd = '*PROUT'   or
417hAC                             $psubcmd = '*SSOUT'   or
600dAC                             $psubcmd = '*TFR2USR'   or
610sAC                             $psubcmd = '*TFR2USRR'  or
640dAC                             $psubcmd = '*TFR2USRN'  or
610gAC                             $psubcmd = '*QTY2PUT'   or
610gAC                             $psubcmd = '*QTY2PUT0'   or
640tAC                             $psubcmd = '*DPPUT'   or
600dAC                             $psubcmd = '*USR2PUT'   or
600dAC                             $psubcmd = '*USR2RTN'   or
600dAC                             $psubcmd = '*USR2RCV'   or
720 AC                             $psubcmd = '*USR2RPA'   or
700sAC                             $psubcmd = '*USR2RTNO'   or
730eAC                             $psubcmd = '*USR2RWO'   or
600dAC                             $psubcmd = '*USR2STG'   or
600dAC                             $psubcmd = '*USR2OSS'   or
417fAC                             $psubcmd = '*TFRINCHG'  or
417hAC                             $psubcmd = '*LETINCHG'  or
417hAC                             $psubcmd = '*PRINCHG'  or
417hAC                             $psubcmd = '*SSINCHG'  or
417fAC                             $psubcmd = '*TFROUTCHG' or
417hAC                             $psubcmd = '*LETOUTCHG' or
417hAC                             $psubcmd = '*PROUTCHG' or
417hAC                             $psubcmd = '*SSOUTCHG' or
416oAC                             $psubcmd = '*VERIFYTFI' or
417hAC                             $psubcmd = '*VERIFYLTI' or
417hAC                             $psubcmd = '*VERIFYPRI' or
417hAC                             $psubcmd = '*VERIFYSSI' or
417fMC                             $psubcmd = '*VERIFYTFO' or
417hAC                             $psubcmd = '*VERIFYLTO' or
417hAC                             $psubcmd = '*VERIFYPRO' or
417hAC                             $psubcmd = '*VERIFYSSO' or
417fAC                             $psubcmd = '*VFYTFICHG' or
417hAC                             $psubcmd = '*VFYLTICHG' or
417hAC                             $psubcmd = '*VFYPRICHG' or
417hAC                             $psubcmd = '*VFYSSICHG' or
417fAC                             $psubcmd = '*VFYTFOCHG' or
417hAC                             $psubcmd = '*VFYLTOCHG' or
417hAC                             $psubcmd = '*VFYPROCHG' or
417hAC                             $psubcmd = '*VFYSSOCHG' or
500eAC                             $psubcmd = '*VERIFYPUT' or
500xAC                             $psubcmd = '*VFYSTGPUT' or
500eAC                             $psubcmd = '*VERIFYRTN' or
500iAC                             $psubcmd = '*VERIFYSI'
     C                   eval      error = *on
     C                   eval      $saorg1e = '1'
     C                   eval      $saorg2e = '1'
     C                   eval      $saorg3e = '1'
     C                   eval      $preturn = 'ORGNOTALW'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif
     C                   endif

     *  Verify that there is something to do.

600rAC                   if        $psubcmd <> '*OSSIN'
611eAC                             and $psubcmd <> '*PREIN'
700dAC                             and $psubcmd <> '*AMPIN'
610gAC                             and $psubcmd <> '*QTY2PUT0'
640tAC                             and $psubcmd <> '*DPPUT'
700qAC                             and (not $saAllowZrou or $saAllowZero <> 'Y')
730cAC                             and $pprogram <> 'RTC330'
     C                   if        not $saqtyu  and
     C                             not $saorgu  and
     C                             not $sacwtau or
     C                             $saqty1 = 0  and
     C                             $saqty2 = 0  and
     C                             $saqty3 = 0  and
     C                             $saorg1 = 0  and
     C                             $saorg2 = 0  and
     C                             $saorg3 = 0  and
     C                             $sacwta = 0
     C                   eval      error = *on
     C                   eval      $saqty1e = '1'
     C                   eval      $saqty2e = '1'
     C                   eval      $saqty3e = '1'
     C                   eval      $sacwtae = '1'
     C                   eval      $preturn = 'ALLZERO'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif
600rAC                   endif

     *  Initialize original qty to zero if not sent.
     *    This will help with future calculations.

     C                   if        not $saorgu
     C                   eval      $saorg1 = 0
     C                   eval      $saorg2 = 0
     C                   eval      $saorg3 = 0
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
650dMC*                  eval      $drisubcmd = '*GETMAIN'
650dAC                   eval      $drisubcmd = '*GETPARENT'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfyqty
     C                   endif
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
417fAC                   eval      #sentmitem = $itmitem
500gAC                   eval      #sentlot  = $imlot
600dAC                   eval      #senttrack = $imltrk
CBIcAC                   eval      #sentimmflg = $immflg
500cA
500cA*  If "sent" item is Alias, then set item type to parent's type.
500cA
500cAC                   if        #senttype = 'A'
500cA
500cAC                   eval      check4err = *on
500cAC                   eval      $drisubcmd = '*GETMAIN'
500cAC                   eval      item# = $itmitem
500cAC                   exsr      getitem
500cAC                   if        error
500cAC                   goto      endvfyqty
500cAC                   endif
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype
500cA
500cAC                   eval      #senttype = $ittype
500cA
500cAC                   endif

416pA*  Shift SSB quantities.

416pAC                   exsr      shiftssbqty

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfyqty
     C                   endif
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
416nAC                   eval      #slotswgt = $itswgt
416nAC                   eval      #slotcwgt = $itcwgt
417fAC                   eval      #slotmitem = $itmitem
600dAC                   eval      #slottrack = $imltrk

416pM*  Get corresponding SSB item for "slot" item (if any)
416pM*    (moved from before getting slot item)
416pM*    (revised to get SSB for slot item)

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSSB'
416pDC**                 eval      item# = $saitem
416pMC                   eval      item# = #slotitem
     C                   exsr      getitem

     C                   if        error

     C                   eval      error = *off
     C                   eval      ssbflag = *off
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '

     C                   else
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype

     C                   eval      ssbflag = *on
     C                   eval      #ssbitem = $ititem
     C                   eval      #ssbtype = $ittype
     C                   eval      #ssbdesc = $itdesc
     C                   eval      #ssbpdsc = $itpdsc
     C                   eval      #ssbwhdp = $itwhdp
     C                   eval      #ssbstyp = $itstyp
     C                   eval      #ssbdesg = $itdesg
     C                   eval      #ssbum1  = $itum1
     C                   eval      #ssbum2  = $itum2
     C                   eval      #ssbumq2 = $itumq2
     C                   eval      #ssbum3  = $itum3
     C                   eval      #ssbumq3 = $itumq3

     C                   endif
417dA
417dA*  Get "Corresponding" item information.
417dA
417dA*    If corresponding item not sent or blank,
417dA*      then set it to $saitem.
417dA
417dAC                   if        $sacitemu <> '1' or $sacitem = ' '
417dAC                   eval      $sacitem = $saitem
417dAC                   endif
417dA
417dAC                   select
417dA*    If item and corresponding item are the same ...
417dA
417dAC                   when      $sacitem = $saitem
417dA
417dAC                   eval      #csentitem = #sentitem
417dAC                   eval      #csenttype = #senttype
417dAC                   eval      #csentdesc = #sentdesc
417dAC                   eval      #csentpdsc = #sentpdsc
417dAC                   eval      #csentwhdp = #sentwhdp
417dAC                   eval      #csentstyp = #sentstyp
417dAC                   eval      #csentdesg = #sentdesg
417dAC                   eval      #csentum1  = #sentum1
417dAC                   eval      #csentflg1 = #sentflg1
417dAC                   eval      #csentum2  = #sentum2
417dAC                   eval      #csentumq2 = #sentumq2
417dAC                   eval      #csentflg2 = #sentflg2
417dAC                   eval      #csentum3  = #sentum3
417dAC                   eval      #csentumq3 = #sentumq3
417fAC                   eval      #csentmitem = #sentmitem
600dAC                   eval      #csenttrack = #senttrack
CBIcAC                   eval      #csentimmflg = #sentimmflg
417dA
417dAC                   eval      #cslotitem = #slotitem
417dAC                   eval      #cslottype = #slottype
417dAC                   eval      #cslotdesc = #slotdesc
417dAC                   eval      #cslotpdsc = #slotpdsc
417dAC                   eval      #cslotwhdp = #slotwhdp
417dAC                   eval      #cslotstyp = #slotstyp
417dAC                   eval      #cslotdesg = #slotdesg
417dAC                   eval      #cslotum1  = #slotum1
417dAC                   eval      #cslotflg1 = #slotflg1
417dAC                   eval      #cslotum2  = #slotum2
417dAC                   eval      #cslotumq2 = #slotumq2
417dAC                   eval      #cslotflg2 = #slotflg2
417dAC                   eval      #cslotum3  = #slotum3
417dAC                   eval      #cslotumq3 = #slotumq3
417dAC                   eval      #cslotnrpk = #slotnrpk
417dAC                   eval      #cslotflgd = #slotflgd
417dAC                   eval      #cslotswgt = #slotswgt
417dAC                   eval      #cslotcwgt = #slotcwgt
417fAC                   eval      #cslotmitem = #slotmitem
600dAC                   eval      #cslottrack = #slottrack
417dA
417dAC                   eval      #cssbitem = #ssbitem
417dAC                   eval      #cssbtype = #ssbtype
417dAC                   eval      #cssbdesc = #ssbdesc
417dAC                   eval      #cssbpdsc = #ssbpdsc
417dAC                   eval      #cssbwhdp = #ssbwhdp
417dAC                   eval      #cssbstyp = #ssbstyp
417dAC                   eval      #cssbdesg = #ssbdesg
417dAC                   eval      #cssbum1  = #ssbum1
417dAC                   eval      #cssbum2  = #ssbum2
417dAC                   eval      #cssbumq2 = #ssbumq2
417dAC                   eval      #cssbum3  = #ssbum3
417dAC                   eval      #cssbumq3 = #ssbumq3
417dA
417dA*    If item and corresponding item are different ...
417dA
417dAC                   other
417dA
417dA*      Get "sent" corresponding item information.
417dA
417dAC                   eval      check4err = *on
417dAC                   eval      $drisubcmd = '*GETMAIN'
417dAC                   eval      item# = $sacitem
417dAC                   exsr      getitem
417dAC                   if        error
417dAC                   goto      endvfyqty
417dAC                   endif
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype
417dA
417dAC                   eval      #csentitem = $ititem
417dAC                   eval      #csenttype = $ittype
417dAC                   eval      #csentdesc = $itdesc
417dAC                   eval      #csentpdsc = $itpdsc
417dAC                   eval      #csentwhdp = $itwhdp
417dAC                   eval      #csentstyp = $itstyp
417dAC                   eval      #csentdesg = $itdesg
417dAC                   eval      #csentum1  = $itum1
417dAC                   eval      #csentflg1 = $itflg1
417dAC                   eval      #csentum2  = $itum2
417dAC                   eval      #csentumq2 = $itumq2
417dAC                   eval      #csentflg2 = $itflg2
417dAC                   eval      #csentum3  = $itum3
417dAC                   eval      #csentumq3 = $itumq3
417fAC                   eval      #csentmitem = $itmitem
600dAC                   eval      #csenttrack = $imltrk
CBIcAC                   eval      #csentimmflg = $immflg
417dA
417dA*      Get corresponding "slot" item for "sent" corresp. item.
417dA
417dAC                   eval      check4err = *on
417dAC                   eval      $drisubcmd = '*GETSLOT'
417dAC                   eval      item# = $sacitem
417dAC                   exsr      getitem
417dAC                   if        error
417dAC                   goto      endvfyqty
417dAC                   endif
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype
417dA
417dAC                   eval      #cslotitem = $ititem
417dAC                   eval      #cslottype = $ittype
417dAC                   eval      #cslotdesc = $itdesc
417dAC                   eval      #cslotpdsc = $itpdsc
417dAC                   eval      #cslotwhdp = $itwhdp
417dAC                   eval      #cslotstyp = $itstyp
417dAC                   eval      #cslotdesg = $itdesg
417dAC                   eval      #cslotum1  = $itum1
417dAC                   eval      #cslotflg1 = $itflg1
417dAC                   eval      #cslotum2  = $itum2
417dAC                   eval      #cslotumq2 = $itumq2
417dAC                   eval      #cslotflg2 = $itflg2
417dAC                   eval      #cslotum3  = $itum3
417dAC                   eval      #cslotumq3 = $itumq3
417dAC                   eval      #cslotnrpk = $imnrpk
417dAC                   eval      #cslotflgd = $itflgd
417dAC                   eval      #cslotswgt = $itswgt
417dAC                   eval      #cslotcwgt = $itcwgt
417fAC                   eval      #cslotmitem = $itmitem
600dAC                   eval      #cslottrack = $imltrk
417dA
417dA*      Get corresponding SSB item for "slot" corr. item (if any)
417dA
417dAC                   eval      check4err = *on
417dAC                   eval      $drisubcmd = '*GETSSB'
417dAC                   eval      item# = #cslotitem
417dAC                   exsr      getitem
417dA
417dAC                   if        error
417dA
417dAC                   eval      error = *off
417dAC                   eval      cssbflag = *off
417dAC                   eval      $preturn = '*OK'
417dAC                   eval      $pmessage = ' '
417dA
417dAC                   else
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = $itdesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeitem = $dstype
417dA
417dAC                   eval      cssbflag = *on
417dAC                   eval      #cssbitem = $ititem
417dAC                   eval      #cssbtype = $ittype
417dAC                   eval      #cssbdesc = $itdesc
417dAC                   eval      #cssbpdsc = $itpdsc
417dAC                   eval      #cssbwhdp = $itwhdp
417dAC                   eval      #cssbstyp = $itstyp
417dAC                   eval      #cssbdesg = $itdesg
417dAC                   eval      #cssbum1  = $itum1
417dAC                   eval      #cssbum2  = $itum2
417dAC                   eval      #cssbumq2 = $itumq2
417dAC                   eval      #cssbum3  = $itum3
417dAC                   eval      #cssbumq3 = $itumq3
417dA
417dAC                   endif
417dA
417dAC                   endsl

     *  If breakdown quantity sent, see if it is allowed.
     *    (If item has corresponding SSB item, all qty's allowed)

601cA*  Revise to only check that umq's are defined

     C                   if        ssbflag = *off
601cDC**                 if        $saqty2 <> 0 and #slotflg1 <> 'Y' or
601cDC**                           $saqty2 <> 0 and #slotumq2 <= 0   or
601cDC**                           $saqty3 <> 0 and #slotflg2 <> 'Y' or
601cDC**                           $saqty3 <> 0 and #slotumq3 <= 0   or
601cDC**                           $saorg2 <> 0 and #slotflg1 <> 'Y' or
601cDC**                           $saorg2 <> 0 and #slotumq2 <= 0   or
601cDC**                           $saorg3 <> 0 and #slotflg2 <> 'Y' or
601cDC**                           $saorg3 <> 0 and #slotumq3 <= 0
601cMC                   if        $saqty2 <> 0 and #slotumq2 <= 0   or
601cMC                             $saqty3 <> 0 and #slotumq3 <= 0   or
601cMC                             $saorg2 <> 0 and #slotumq2 <= 0   or
601cMC                             $saorg3 <> 0 and #slotumq3 <= 0
     C                   eval      error = *on
     C                   eval      $saqty2e = '1'
     C                   eval      $saqty3e = '1'
     C                   eval      $preturn = 'INVLDBRKQ'
     C                   exsr      getmsg
     C                   goto      endvfyqty
     C                   endif
     C                   endif

417dA
417dA*  If breakdown quantity sent,
417dA*  see if it is allowed for the "Corresponding" item.
417dA*    (If item has corresponding SSB item, all qty's allowed)

601cA*  Revise to only check that umq's are defined
417dA
417dAC                   if        $sacitem <> $saitem
417dAC                   if        cssbflag = *off
601cDC**                 if        $saqty2<>0 and #cslotflg1 <> 'Y' or
601cDC**                           $saqty2<>0 and #cslotumq2 <= 0   or
601cDC**                           $saqty3<>0 and #cslotflg2 <> 'Y' or
601cDC**                           $saqty3<>0 and #cslotumq3 <= 0   or
601cDC**                           $saorg2<>0 and #cslotflg1 <> 'Y' or
601cDC**                           $saorg2<>0 and #cslotumq2 <= 0   or
601cDC**                           $saorg3<>0 and #cslotflg2 <> 'Y' or
601cDC**                           $saorg3<>0 and #cslotumq3 <= 0
601cMC                   if        $saqty2<>0 and #cslotumq2 <= 0   or
601cMC                             $saqty3<>0 and #cslotumq3 <= 0   or
601cMC                             $saorg2<>0 and #cslotumq2 <= 0   or
601cMC                             $saorg3<>0 and #cslotumq3 <= 0
417dAC                   eval      error = *on
417dAC                   eval      $saqty2e = '1'
417dAC                   eval      $saqty3e = '1'
417dAC                   eval      $preturn = 'INVLDCBRKQ'
417dAC                   exsr      getmsg
417dAC                   goto      endvfyqty
417dAC                   endif
417dAC                   endif
417dAC                   endif

601fDC** Extra checks for "Change" transfer requests.
601fDC**
601fDC**                 if        $psubcmd <> '*TFRINCHG'  and
601fDC**                           $psubcmd <> '*LETINCHG'  and
601fDC**                           $psubcmd <> '*PRINCHG'  and
601fDC**                           $psubcmd <> '*SSINCHG'  and
601fDC**                           $psubcmd <> '*TFROUTCHG' and
601fDC**                           $psubcmd <> '*LETOUTCHG' and
601fDC**                           $psubcmd <> '*PROUTCHG' and
601fDC**                           $psubcmd <> '*SSOUTCHG' and
601fDC**                           $psubcmd <> '*CLSTFICHG' and
601fDC**                           $psubcmd <> '*CLSLTICHG' and
601fDC**                           $psubcmd <> '*CLSPRICHG' and
601fDC**                           $psubcmd <> '*CLSSSICHG' and
601fDC**                           $psubcmd <> '*CLSTFOCHG' and
601fDC**                           $psubcmd <> '*CLSLTOCHG' and
601fDC**                           $psubcmd <> '*CLSPROCHG' and
601fDC**                           $psubcmd <> '*CLSSSOCHG' and
601fDC**                           $psubcmd <> '*TFR2USR' and
601fDC**                           $psubcmd <> '*USR2PUT' and
601fDC**                           $psubcmd <> '*VFYTFICHG' and
601fDC**                           $psubcmd <> '*VFYLTICHG' and
601fDC**                           $psubcmd <> '*VFYPRICHG' and
601fDC**                           $psubcmd <> '*VFYSSICHG' and
601fDC**                           $psubcmd <> '*VFYTFOCHG' and
601fDC**                           $psubcmd <> '*VFYLTOCHG' and
601fDC**                           $psubcmd <> '*VFYPROCHG' and
601fDC**                           $psubcmd <> '*VFYSSOCHG' and
601fDC**                           $psubcmd <> '*VFYCLSTFI' and
601fDC**                           $psubcmd <> '*VFYCLSLTI' and
601fDC**                           $psubcmd <> '*VFYCLSPRI' and
601fDC**                           $psubcmd <> '*VFYCLSSSI' and
601fDC**                           $psubcmd <> '*VFYCLSTIC' and
601fDC**                           $psubcmd <> '*VFYCLSLIC' and
601fDC**                           $psubcmd <> '*VFYCLSPIC' and
601fDC**                           $psubcmd <> '*VFYCLSSIC' and
601fDC**                           $psubcmd <> '*VFYCLSTFO' and
601fDC**                           $psubcmd <> '*VFYCLSLTO' and
601fDC**                           $psubcmd <> '*VFYCLSPRO' and
601fDC**                           $psubcmd <> '*VFYCLSSSO' and
601fDC**                           $psubcmd <> '*VFYCLSTOC' and
601fDC**                           $psubcmd <> '*VFYCLSLOC' and
601fDC**                           $psubcmd <> '*VFYCLSPOC' and
601fDC**                           $psubcmd <> '*VFYCLSSOC'
601fDC**                 goto      skipchgtfrchk
601fDC**                 endif
500sDC**
500sDC**   Skip checks if item number not being changed.
500sDC**
500sDC**                 if        #slotitem = #cslotitem
500sDC**                 goto      skipchgtfrchk
500sDC**                 endif
417fA
417fA*    First, sort out the From/To information.
417fA
417fAC                   if        $psubcmd = '*TFROUTCHG'  or
417hAC                             $psubcmd = '*LETOUTCHG'  or
417hAC                             $psubcmd = '*PROUTCHG'  or
417hAC                             $psubcmd = '*SSOUTCHG'  or
417fAC                             $psubcmd = '*CLSTFOCHG' or
417hAC                             $psubcmd = '*CLSLTOCHG' or
417hAC                             $psubcmd = '*CLSPROCHG' or
417hAC                             $psubcmd = '*CLSSSOCHG' or
601gAC                             $psubcmd = '*TFR2USR' or
610sAC                             $psubcmd = '*TFR2USRR' or
640dAC                             $psubcmd = '*TFR2USRN' or
417fAC                             $psubcmd = '*VFYTFOCHG' or
417hAC                             $psubcmd = '*VFYLTOCHG' or
417hAC                             $psubcmd = '*VFYPROCHG' or
500pMC                             $psubcmd = '*VFYSSOCHG' or
500pAC                             $psubcmd = '*VFYCLSTFO' or
500pAC                             $psubcmd = '*VFYCLSLTO' or
500pAC                             $psubcmd = '*VFYCLSPRO' or
500pAC                             $psubcmd = '*VFYCLSSSO' or
500pAC                             $psubcmd = '*VFYCLSTOC' or
500pAC                             $psubcmd = '*VFYCLSLOC' or
500pAC                             $psubcmd = '*VFYCLSPOC' or
500pAC                             $psubcmd = '*VFYCLSSOC'
417fA
417fAC                   eval      #fromitem  = #slotitem
417fAC                   eval      #frommitem = #slotmitem
417fAC                   eval      #fromtype  = #slottype
417fAC                   eval      #fromumq2  = #slotumq2
417fAC                   eval      #fromumq3  = #slotumq3
601gAC                   eval      #fromsentitem = #sentitem
601gAC                   eval      #fromsenttype = #senttype
417fAC                   eval      #toitem    = #cslotitem
417fAC                   eval      #tomitem   = #cslotmitem
417fAC                   eval      #totype    = #cslottype
417fAC                   eval      #toumq2    = #cslotumq2
417fAC                   eval      #toumq3    = #cslotumq3
601gAC                   eval      #tosentitem = #csentitem
601gAC                   eval      #tosenttype = #csenttype
417fA
417fAC                   else
417fA
417fAC                   eval      #fromitem  = #cslotitem
417fAC                   eval      #frommitem = #cslotmitem
417fAC                   eval      #fromtype  = #cslottype
417fAC                   eval      #fromumq2  = #cslotumq2
417fAC                   eval      #fromumq3  = #cslotumq3
601gAC                   eval      #fromsentitem = #csentitem
601gAC                   eval      #fromsenttype = #csenttype
417fAC                   eval      #toitem    = #slotitem
417fAC                   eval      #tomitem   = #slotmitem
417fAC                   eval      #totype    = #slottype
417fAC                   eval      #toumq2    = #slotumq2
417fAC                   eval      #toumq3    = #slotumq3
601gAC                   eval      #tosentitem = #sentitem
601gAC                   eval      #tosenttype = #senttype
417fA
417fAC                   endif
500sA
500sA*    Skip checks if item number not being changed.
500sA
500sAC                   if        #slotitem = #cslotitem
500sAC                   goto      skipchgtfrchk
500sAC                   endif
600dA
600dAC                   eval      itemChanged = *on
417fA
417fA*    Make sure From/To items are compatible.
417fA
417fAC                   if        #fromtype='B' and #frommitem<>#toitem
417fAC                             or
417fAC                             #fromtype='S' and #frommitem<>#toitem
417fAC                             or
417fAC                             #totype='B' and #tomitem<>#fromitem
417fAC                             or
417fAC                             #totype='S' and #tomitem<>#fromitem
417fA
417fAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
500oDC*                  eval      $sacitem = '1'
500oMC                   eval      $saciteme = '1'
417fAC                   eval      $preturn  = 'ITMNOTCOMP'
417fAC                   exsr      getmsg
417fAC                   goto      endvfyqty
417fA
417fAC                   endif
417fA
417fA*    When going from a Normal item to a Breakdown item,
417fA*      Then sent item UOM quanity cannot be zero.
417fA
417fAC                   if        #fromtype = ' ' and
417fAC                               (#totype = 'B' or #totype = 'S')
417fAC                   if        $saqty1 <> 0 and #fromumq2 <= 0 or
417fAC                             $saqty2 <> 0 and #fromumq3 <= 0
417fAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
417fAC                   eval      $preturn  = 'BRKNOTDEF'
417fAC                   exsr      getmsg
417fAC                   goto      endvfyqty
417fAC                   endif
417fAC                   endif
417fA
417fA*    When going from a Breakdown item to a Normal item,
417fA*      Then corresponding UOM quanity cannot be zero.
417fA
417fAC                   if        (#fromtype = 'B' or #fromtype = 'S')
417fAC                               and #totype = ' '
417fAC                   if        $saqty1 <> 0 and #toumq2 <= 0 or
417fAC                             $saqty2 <> 0 and #toumq3 <= 0
417fAC                   eval      error = *on
500oDC*                  eval      $saitem = '1'
500oMC                   eval      $saiteme = '1'
417fAC                   eval      $preturn  = 'BRKNOTDEF'
417fAC                   exsr      getmsg
417fAC                   goto      endvfyqty
417fAC                   endif
417fAC                   endif
417fA
417fA*    When going from a Breakdown item to a Normal item,
417fA*      Then make sure qty is evenly divisible by UOM quantity.
417fA
417fAC                   if        (#fromtype = 'B' or #fromtype = 'S')
417fAC                               and #totype = ' '
417fA
417fAC                   if        $saqty1 > 0
417fAC     $saqty1       div       #toumq2       temp5n
417fAC                   mvr                     remainder
417fAC                   if        remainder > 0
417fAC                   eval      error = *on
417fAC                   eval      $saqty1e = '1'
417fAC                   eval      $preturn  = 'INVLDQTY1'
417fAC                   exsr      getmsg
417fAC                   goto      endvfyqty
417fAC                   endif
417fAC                   endif
417fA
417fAC                   if        $saqty2 > 0
417fAC     $saqty2       div       #toumq3       temp5n
417fAC                   mvr                     remainder
417fAC                   if        remainder > 0
417fAC                   eval      error = *on
417fAC                   eval      $saqty2e = '1'
417fAC                   eval      $preturn  = 'INVLDQTY2'
417fAC                   exsr      getmsg
417fAC                   goto      endvfyqty
417fAC                   endif
417fAC                   endif
417fA
417fAC                   endif
417fA
417fAC     skipchgtfrchk tag
600lA
600lA*  Get Pull slot if sent.
600lA
600lAC                   eval      PullExists = *off
600lAC                   eval      PullStat = ' '
600lAC                   eval      PullItem = ' '
600uAC                   if        $saPullWhdpU = *on
600uAC                   eval      kywhdp = $saPullWhdp
600uAC                   endif
600lAC                   if        $saPullDispU = *on
600lAC                   eval      kywhse = $slwhse
600uDC**                 eval      kywhdp = $slwhdp
600lAC                   eval      kydisp = $saPullDisp
600lAC                   eval      check4err = *on
600lAC                   exsr      getslot2
600lAC                   if        error
600lAC                   eval      error = *off
600lAC                   else
600lAC                   eval      PullExists = *on
600lAC                   eval      PullStat = slstat
600lAC                   eval      PullItem = slitem
600lAC                   endif
600lAC                   endif

     *  Get slot - Lock it if not verifying or doing manual putaway.
600dA*    or for RCV/STG/OSS/USRIN, which don't have a base slot.
600dA*    or TFR2USR.

     C                   if        $psubcmd = '*VERIFY'    or
     C                             $psubcmd = '*VERIFYORD' or
416oAC                             $psubcmd = '*VERIFYTFI' or
417hAC                             $psubcmd = '*VERIFYLTI' or
417hAC                             $psubcmd = '*VERIFYPRI' or
417hAC                             $psubcmd = '*VERIFYSSI' or
     C                             $psubcmd = '*VERIFYTFO' or
417hAC                             $psubcmd = '*VERIFYLTO' or
417hAC                             $psubcmd = '*VERIFYPRO' or
500eAC                             $psubcmd = '*VERIFYPUT' or
500xAC                             $psubcmd = '*VFYSTGPUT' or
500eAC                             $psubcmd = '*VERIFYRTN' or
500iAC                             $psubcmd = '*VERIFYSI' or
417hAC                             $psubcmd = '*VERIFYSSO' or
417fAC                             $psubcmd = '*VFYTFICHG' or
417hAC                             $psubcmd = '*VFYLTICHG' or
417hAC                             $psubcmd = '*VFYPRICHG' or
417hAC                             $psubcmd = '*VFYSSICHG' or
417fAC                             $psubcmd = '*VFYTFOCHG' or
417hAC                             $psubcmd = '*VFYLTOCHG' or
417hAC                             $psubcmd = '*VFYROCHG' or
417hAC                             $psubcmd = '*VFYSSOCHG' or
500jAC                             $psubcmd = '*VFYCLSTFI'  or
500jAC                             $psubcmd = '*VFYCLSLTI'  or
500jAC                             $psubcmd = '*VFYCLSPRI'  or
500jAC                             $psubcmd = '*VFYCLSSSI'  or
500jAC                             $psubcmd = '*VFYCLSTIC'  or
500jAC                             $psubcmd = '*VFYCLSLIC'  or
500jAC                             $psubcmd = '*VFYCLSPIC'  or
500jAC                             $psubcmd = '*VFYCLSSIC'  or
500jAC                             $psubcmd = '*VFYCLSTFO'  or
500jAC                             $psubcmd = '*VFYCLSLTO'  or
500jAC                             $psubcmd = '*VFYCLSPRO'  or
500jAC                             $psubcmd = '*VFYCLSSSO'  or
500jAC                             $psubcmd = '*VFYCLSTOC'  or
500jAC                             $psubcmd = '*VFYCLSLOC'  or
500jAC                             $psubcmd = '*VFYCLSPOC'  or
500jAC                             $psubcmd = '*VFYCLSSOC'  or
600dAC                             $psubcmd = '*RCVIN'      or
700sAC                             $psubcmd = '*RTNIN'      or
730eAC                             $psubcmd = '*RWOIN'      or
720 AC                             $psubcmd = '*RPAIN'      or
600dAC                             $psubcmd = '*STGIN'      or
600dAC                             $psubcmd = '*OSSIN'      or
611eAC                             $psubcmd = '*PREIN'      or
700dAC                             $psubcmd = '*AMPIN'      or
600dAC                             $psubcmd = '*USRIN'      or
600dAC                             $psubcmd = '*TFR2USR'    or
610sAC                             $psubcmd = '*TFR2USRR'   or
640dAC                             $psubcmd = '*TFR2USRN'   or
     C                             $psubcmd = '*RECEIVE'
     C                                and ManualPutaway    or
417hAC                             $psubcmd = '*PUTAWAY'
417hAC                                and ManualPutaway    or
500xAC                             $psubcmd = '*STAGEPUT'
500xAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*RETURN'
417hAC                                and ManualPutaway    or
     C                             $psubcmd = '*CLSRCV'
     C                                and ManualPutaway    or
417sAC                             $psubcmd = '*CLSRCVADJ'
417sAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSRTN'
417hAC                                and ManualPutaway    or
500iAC                             $psubcmd = '*STUFFIT'
500iAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSPUTAWY'
417hAC                                and ManualPutaway    or
500xAC                             $psubcmd = '*CLSSTGPUT'
500xAC                                and ManualPutaway    or
     C                             $psubcmd = '*TFRIN'
     C                                and ManualPutaway    or
417hAC                             $psubcmd = '*LETIN'
417hAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*PRIN'
417hAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*SSIN'
417hAC                                and ManualPutaway    or
417fAC                             $psubcmd = '*TFRINCHG'
417fAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*LETINCHG'
417hAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*PRINCHG'
417hAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*SSINCHG'
417hAC                                and ManualPutaway    or
     C                             $psubcmd = '*CLSTFRIN'
417fMC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSLETIN'
417hMC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSPRIN'
417hMC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSSSIN'
417hMC                                and ManualPutaway    or
417fAC                             $psubcmd = '*CLSTFICHG'
417fAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSLTICHG'
417hAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSPRICHG'
417hAC                                and ManualPutaway    or
417hAC                             $psubcmd = '*CLSSSICHG'
417hAC                                and ManualPutaway    or
600dAC                             $psubcmd = '*USR2PUT'
600dAC                                and ManualPutaway    or
600dAC                             $psubcmd = '*USR2RTN'
600dAC                                and ManualPutaway
     C                   eval      lock = *off
     C                   else
     C                   eval      lock = *on
     C                   endif
600dA
611eM*  Call special routine for RCV/STG/OSS/USRIN/PRE,
600dA*    because they don't have a base slot.
600dA
600dAC                   if        $psubcmd = '*RCVIN'
700sAC                              or $psubcmd = '*RTNIN'
730eAC                              or $psubcmd = '*RWOIN'
720 AC                              or $psubcmd = '*RPAIN'
600dAC                              or $psubcmd = '*STGIN'
600dAC                              or $psubcmd = '*OSSIN'
611eAC                              or $psubcmd = '*PREIN'
700dAC                              or $psubcmd = '*AMPIN'
600dAC                              or $psubcmd = '*USRIN'
600dAC                   exsr      getslot2USR
600dAC                   else
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
CBIcA * check for clr to frz change
CBIcA /free
CBIcA   CBIClrFrz = *off;
CBIcA   if client = cheney and
CBIcA      $psubcmd = '*VFYTFOCHG';
CBIcA     // clr to frz original item must be mfg dated item
CBIdA     // this no longer applies, the from item does not need to be
CBIdA     // mfg dated item.
CBIdD     //if #sentwhdp = 'CLR'
CBIdD        //and #csentwhdp = 'FRZ'
CBIdD        //and #sentimmflg <> 'Y';
CBIdD       //error = *on;
CBIdD       //$preturn = 'CBIFITMMFG';
CBIdD       //exsr getmsg;
CBIdD       //leavesr;
CBIdD     //endif;
CBIcA     // clr to frz new item must be mfg dated item
CBIcA     if #sentwhdp = 'CLR'
CBIcA        and #csentwhdp = 'FRZ'
CBIcA        and #csentimmflg <> 'Y';
CBIcA       error = *on;
CBIcA       $preturn = 'CBITITMMFG';
CBIcA       exsr getmsg;
CBIcA       leavesr;
CBIcA     endif;
CBIcA     if #sentwhdp = 'CLR'
CBIcA        and #csentwhdp = 'FRZ';
CBIcA       CBIClrFrz = *on;
CBIcA       // Do not allow transfer from pick slot when clr to frz.
CBIeD       //if slpick = 'Y' and CBIClrFrz;
CBIeD         //error = *on;
CBIeD         //$preturn = 'CBINOPICK ';
CBIeD         //exsr getmsg;
CBIeD         //leavesr;
CBIeD       //else;
CBIcA       exsr getslotlic;
CBIcA       // Get the original license info.
CBIcA       exsr clr$licinfo;
CBIcA       $lnwhse  = kywhse;
CBIcA       $lnlcns  = $liolcns;
CBIcA       $lnseq = 1;
CBIcA
CBIcA       $dricommand = 'DRILICINFO';
CBIcA       $drisubcmd  = '%GET';
CBIcA       $drisys2upd = 'D';
CBIcA       exsr zzzdrimain3;
CBIcA       if $drireturn <> '*OK';
CBIcA         error = *on;
CBIcA         $preturn = $drireturn;
CBIcA         $pmessage = $drimessage;
CBIcA         leavesr;
CBIcA       endif;

CBIdA         // this no longer applies
CBIdD         //if $lnenttype <> '*MFGDTE';
CBIdD           //error = *on;
CBIdD           //$preturn = 'CBINOMFGD ';
CBIdD           //exsr getmsg;
CBIdD           //leavesr;
CBIdD         //endif;
CBIeD       //endif;
CBIcA     endif;
CBIcA   endif;

CBIcA   if client = cheney and
CBIcA      $psubcmd = '*USR2PUT';
CBIcA     if #sentwhdp = 'FRZ' and
CBIcA        #csentwhdp = 'CLR';
CBIcA       CBIClrFrz = *on;
CBIcA       // Get the original license info.
CBIcA       exsr clr$licinfo;
CBIcA       $lnwhse  = kywhse;
CBIcA       $lnlcns  = $saolcns;
CBIcA       $lnseq = 1;
CBIcA
CBIcA       $dricommand = 'DRILICINFO';
CBIcA       $drisubcmd  = '%GET';
CBIcA       $drisys2upd = 'D';
CBIcA       exsr zzzdrimain3;
CBIcA       if $drireturn <> '*OK';
CBIcA         error = *on;
CBIcA         $preturn = $drireturn;
CBIcA         $pmessage = $drimessage;
CBIcA         leavesr;
CBIcA       endif;

CBIdA       // This no longer applies
CBIdD       //if $lnenttype <> '*MFGDTE';
CBIdD         //error = *on;
CBIdD         //$preturn = 'CBINOMFGD ';
CBIdD         //exsr getmsg;
CBIdD         //leavesr;
CBIdD       //endif;
CBIcA       // convert to new expiration date
CBIcA       perrmsg = ' ';
CBIcA       psessid = ' ';
CBIcA       pdpcombo = 'DRISLOT ';
CBIcA       calpdktexpd = 0;
CBIdD       //calpentdate = $lnentdate;
CBIdM       calpentdate = %dec(%date($lnaddts):*iso);
CBIcA       calpwhse = kywhse;
CBIcA       caldktexp(perrmsg: psessid: #user: pdpcombo:
CBIcA               calpwhse: #sentitem: calpentdate: calpdktexpd);
CBIcA     endif;
CBIcA   endif;
CBIcA /end-free
650yA*  Need to set error on if the slot sent in was a virtual slot
650yA*  When doing VERIFYRTN
650yAc                   if        $psubcmd = '*VERIFYRTN'
650yAc                             and slrsrv = 'V'
650yAc                             or $psubcmd = '*VERIFYPUT'
650yAc                             and slrsrv = 'V'
650yAc                   eval      error = *on
650yAc                   eval      $preturn = 'INVLDSLOT'
650yAC                   exsr      getmsg
650yAc                   endif
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfyqty
     C                   endif
6501AC                   eval      $slstat = slstat
600dAC                   endif

     *  Get itemqty record - Lock if not verifying.
600dA*    don't lock for RCV/STG/OSS/USRIN,USR2*,TFR2USR

     C                   eval      check4err = *on
     C                   if        $psubcmd = '*VERIFY'    or
     C                             $psubcmd = '*VERIFYORD' or
416oAC                             $psubcmd = '*VERIFYTFI' or
417hAC                             $psubcmd = '*VERIFYLTI' or
417hAC                             $psubcmd = '*VERIFYPRI' or
417hAC                             $psubcmd = '*VERIFYSSI' or
417fMC                             $psubcmd = '*VERIFYTFO' or
417hAC                             $psubcmd = '*VERIFYLTO' or
417hAC                             $psubcmd = '*VERIFYPRO' or
417hAC                             $psubcmd = '*VERIFYSSO' or
417fAC                             $psubcmd = '*VFYTFICHG' or
417hAC                             $psubcmd = '*VFYLTICHG' or
417hAC                             $psubcmd = '*VFYPRICHG' or
417hAC                             $psubcmd = '*VFYSSICHG' or
417fAC                             $psubcmd = '*VFYTFOCHG' or
417hAC                             $psubcmd = '*VFYLTOCHG' or
417hAC                             $psubcmd = '*VFYPROCHG' or
417hAC                             $psubcmd = '*VFYSSOCHG' or
500jAC                             $psubcmd = '*VFYCLSTFI'  or
500jAC                             $psubcmd = '*VFYCLSLTI'  or
500jAC                             $psubcmd = '*VFYCLSPRI'  or
500jAC                             $psubcmd = '*VFYCLSSSI'  or
500jAC                             $psubcmd = '*VFYCLSTIC'  or
500jAC                             $psubcmd = '*VFYCLSLIC'  or
500jAC                             $psubcmd = '*VFYCLSPIC'  or
500jAC                             $psubcmd = '*VFYCLSSIC'  or
500jAC                             $psubcmd = '*VFYCLSTFO'  or
500jAC                             $psubcmd = '*VFYCLSLTO'  or
500jAC                             $psubcmd = '*VFYCLSPRO'  or
500jAC                             $psubcmd = '*VFYCLSSSO'  or
500jAC                             $psubcmd = '*VFYCLSTOC'  or
500jAC                             $psubcmd = '*VFYCLSLOC'  or
500jAC                             $psubcmd = '*VFYCLSPOC'  or
500jAC                             $psubcmd = '*VFYCLSSOC'  or
500eAC                             $psubcmd = '*VERIFYPUT' or
500xAC                             $psubcmd = '*VFYSTGPUT' or
500eAC                             $psubcmd = '*VERIFYRTN' or
500iAC                             $psubcmd = '*VERIFYSI'  or
600dAC                             $psubcmd = '*RCVIN'      or
720 AC                             $psubcmd = '*RPAIN'      or
700sAC                             $psubcmd = '*RTNIN'      or
730eAC                             $psubcmd = '*RWOIN'      or
600dAC                             $psubcmd = '*STGIN'      or
600dAC                             $psubcmd = '*OSSIN'      or
611eAC                             $psubcmd = '*PREIN'      or
700dAC                             $psubcmd = '*AMPIN'      or
600dAC                             $psubcmd = '*USRIN'      or
600dAC                             $psubcmd = '*USR2RCV'    or
720 AC                             $psubcmd = '*USR2RPA'    or
700sAC                             $psubcmd = '*USR2RTNO'    or
730eAC                             $psubcmd = '*USR2RWO'    or
600dAC                             $psubcmd = '*USR2STG'    or
600dAC                             $psubcmd = '*USR2OSS'    or
600dAC                             $psubcmd = '*TFR2USR'    or
640dAC                             $psubcmd = '*TFR2USRN'   or
610sAC                             $psubcmd = '*TFR2USRR'
     C                   eval      lock = *off
     C                   else
     C                   eval      lock = *on
     C                   endif
     C                   exsr      getitemqty
     C                   if        error
     C                   eval      $saiteme = '1'
     C                   goto      endvfyqty
     C                   endif

417fA*  For "change" transfers In's, convert quantity if necessary.
417fA*    (Note: This is duplicated in QTYCLSRCV and QTYRECEIVE).

417fAC                   if        $psubcmd = '*TFRINCHG'  or
417hAC                             $psubcmd = '*LETINCHG'  or
417hAC                             $psubcmd = '*PRINCHG'  or
417hAC                             $psubcmd = '*SSINCHG'  or
417fAC                             $psubcmd = '*CLSTFICHG' or
417hAC                             $psubcmd = '*CLSLTICHG' or
417hAC                             $psubcmd = '*CLSPRICHG' or
417hAC                             $psubcmd = '*CLSSSICHG' or
600dAC                             $psubcmd = '*USR2PUT' or
417fAC                             $psubcmd = '*VFYTFICHG' or
417hAC                             $psubcmd = '*VFYLTICHG' or
417hAC                             $psubcmd = '*VFYPRICHG' or
417hAC                             $psubcmd = '*VFYSSICHG' or
500jAC                             $psubcmd = '*VFYCLSTFI'  or
500jAC                             $psubcmd = '*VFYCLSLTI'  or
500jAC                             $psubcmd = '*VFYCLSPRI'  or
500jAC                             $psubcmd = '*VFYCLSSSI'  or
500jAC                             $psubcmd = '*VFYCLSTIC'  or
500jAC                             $psubcmd = '*VFYCLSLIC'  or
500jAC                             $psubcmd = '*VFYCLSPIC'  or
500jAC                             $psubcmd = '*VFYCLSSIC'

417fAC                   select

417fAC                   when      #fromtype = ' ' and
417fAC                               (#totype = 'B' or #totype = 'S')
     C                   eval      $saqty1 = $saqty1 * #fromumq2
600hAC                   eval      $saqty1 = $saqty1 + $saqty2
600hAC                   eval      $saqty2 = $saqty3
600hDC**                 eval      $saqty2 = $saqty2 * #fromumq3
500pAC                   eval      $saorg1 = $saorg1 * #fromumq2
600hAC                   eval      $saorg1 = $saorg1 + $saorg2
600hAC                   eval      $saorg2 = $saorg3
600hDC**                 eval      $saorg2 = $saorg2 * #fromumq3

417fAC                   when      (#fromtype = 'B' or #fromtype = 'S')
417fAC                               and #totype = ' '
     C                   if        $saqty1 <> 0 and #toumq2 > 0
     C                   eval      $saqty1 = $saqty1 / #toumq2
417fAC                   endif
     C                   if        $saqty2 <> 0 and #toumq3 > 0
     C                   eval      $saqty2 = $saqty2 / #toumq3
417fAC                   endif
500pAC                   if        $saorg1 <> 0 and #toumq2 > 0
500pAC                   eval      $saorg1 = $saorg1 / #toumq2
500pAC                   endif
500pAC                   if        $saorg2 <> 0 and #toumq3 > 0
500pAC                   eval      $saorg2 = $saorg2 / #toumq3
500pAC                   endif

417fAC                   endsl

417fAC                   endif

     *  Converty adjustment quantities to lowest uom quantitiy.

     C                   if        #slotumq2 <= 0
     C                   eval      #slotumq2 = 1
     C                   endif

     C                   if        #slotumq3 <= 0
     C                   eval      #slotumq3 = 1
     C                   endif

     C                   eval      lowiaqty = ($saqty1 * #slotumq2 * #slotumq3)
     C                                      + ($saqty2 * #slotumq3)
     C                                      + $saqty3

     C                   eval      lowiaorg = ($saorg1 * #slotumq2 * #slotumq3)
     C                                      + ($saorg2 * #slotumq3)
     C                                      + $saorg3

     *    Converty warehouse available qtys to lowest uom quantitiy.

     C                   eval      lowwhavl = ($iqavl1 * #slotumq2 * #slotumq3)
     C                                      + ($iqavl2 * #slotumq3)
     C                                      + $iqavl3

     C     endvfyqty     endsr

     *----------------------------------------------------------------
     *  verifyqtyadj  Verification for *ADJUST/*ADJUSTORD
     *----------------------------------------------------------------

     C     verifyqtyadj  begsr
600tAC                   eval      currRoutine = 'verifyqtyadj'
600tAC                   exsr      phpgmV1V2V3s
     C                   move      *off          error

     *  Validate adjustment code.
600jA
600jA*    Special case for codes that start with '@'
600jA*      - Don't verify that they are in the table.
600jA*      - Force to be Dakota only.
600jA
600jAC                   if        %subst($sacode:1:1) = '@'
600jAC                   eval      $vsys = 'D'
600jA
600jAC                   else
600jA
600jA*    Otherwise, code must exist in table.

     C                   eval      vfyadjc = *on
     C                   call(e)   'VFYADJC'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $sacode       $vcode
416aAC                   parm      ' '           $vsys
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYADJC'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endverifyqa

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $sacodee = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endverifyqa

     C                   endsl
600jA
600jAC                   endif

640lA*    New available slot quantities cannot exceed 99,999
640lA
640lAC                   eval      qtytest = slavl1 + $saqty1
640lAC                   if        qtytest > 99999
640lAC                   eval      error = *on
640lAC                   eval      $saqty1e = '1'
640lAC                   eval      $preturn = 'ADJQTYMAX'
640lAC                   exsr      getmsg
640lAC                   goto      endverifyqa
640lAC                   endif

     *  Calculate new available.

     C                   eval      newavlqty1  = slavl1 + $saqty1
     C                   eval      newavlqty2  = slavl2 + $saqty2
     C                   eval      newavlqty3  = slavl3 + $saqty3

500wA
500wA*    Convert new available qtys to lowest uom quantitiy.
500wA
500wAC                   eval      lownewavl = (newavlqty1* #slotumq2*#slotumq3)
500wAC                                       + (newavlqty2 * #slotumq3)
500wAC                                       + newavlqty3

     *  New available quantities cannot be negative ...
     *    when doing a normal adjustment and reducing quantity.

     C                   if        $psubcmd = '*VERIFY' or
710bMC                             $psubcmd = '*ADJUST' or
710bAC                             $psubcmd = '*ADJUSTIMP'
510fDC**                 if        newavlqty1 < 0 and $saqty1 < 0 or
510fDC**                           newavlqty2 < 0 and $saqty2 < 0 or
510fDC**                           newavlqty3 < 0 and $saqty3 < 0
500wAC***                if        lownewavl < 0
FRCaAc                   if        (client = FreshCuts
FRCaAc                             or client = GFKKitchen)
FRCaAc                             and $saAction = 'ADJ'
FRCaAC                   else
510fMC                   if        lownewavl < 0 and lowiaqty < 0
650qAc                               and $saAction <> 'PRM'
650qAc                               and $saAction <> 'PIU'
650qAc                               and $saAction <> 'PIW'
     C                   eval      error = *on
     C                   eval      $saqty1e = '1'
     C                   eval      $saqty2e = '1'
     C                   eval      $saqty3e = '1'
     C                   eval      $preturn = 'NEGAVLSLT'
     C                   exsr      getmsg
     C                   goto      endverifyqa
500wAC                   endif
FRCaAC                   endif
lmcx C* for 510f         endif
     C                   endif

     *  New warehouse available quantity cannot be negative ...
     *    when doing a normal adjustment.

     C                   if        $psubcmd = '*VERIFY' or
710bMC                             $psubcmd = '*ADJUST' or
710bAC                             $psubcmd = '*ADJUSTIMP'
500dDC**                 if        (lowiaqty + lowwhavl) < 0
500dDC**                 eval      error = *on
500dDC**                 eval      $saqty1e = '1'
500dDC**                 eval      $saqty2e = '1'
500dDC**                 eval      $saqty3e = '1'
500dDC**                 eval      $preturn = 'NEGAVLWHS'
500dDC**                 exsr      getmsg
500dDC**                 goto      endverifyqa
500dDC**                 endif
     C                   endif

     C     endverifyqa   endsr

416dA*----------------------------------------------------------------
416dA*  verifyrcv  Verify information when receiving.
416dA*----------------------------------------------------------------
416dA
416daC     verifyrcv     begsr
     c*
600tAC                   eval      currRoutine = 'verifyrcv'
600tAC                   exsr      phpgmV1V2V3s
610cA
610cAC                   select
610cA
610cA*     Special case for *OSSIN. If slot is passed in then
610cA*     assume slot was created in PO236 and we are not just
610cA*     assigning the qty and license to it.
610cA
610cAC                   when      $psubcmd = '*OSSIN'
610cAC                             and $sldispu
610cAC                             and $sldisp <> ' '
610cAC                   exsr      verifyrcvm
610cAC                   goto      endvfyrcv
610cA
611eM*     Special case for RCV/STG/OSS/USR/PRE where a virtual
610cA*     slot will always be created.
610cA
610cAC                   when      $psubcmd = '*RCVIN' or
720 AC                             $psubcmd = '*RPAIN' or
700sAC                             $psubcmd = '*RTNIN' or
730eAC                             $psubcmd = '*RWOIN' or
610cAC                             $psubcmd = '*STGIN' or
610cAC                             $psubcmd = '*OSSIN' or
611eAC                             $psubcmd = '*PREIN' or
700dAC                             $psubcmd = '*AMPIN' or
610cAC                             $psubcmd = '*USRIN'
610cAC                   exsr      verifyrcvs
610cAC                   goto      endvfyrcv
610cA
610cAC                   endsl

     *  Directed putaway checks.
640uA*  Now all checks go through verifyrcvm.

640uDC**                 if        DirectPutaway
640uDC**                 exsr      verifyrcvd
640uDC**                 if        error
640uDC**                 goto      endvfyrcv
640uDC**                 endif
640uDC**                 endif

     *  Manual putaway checks.

     C                   if        ManualPutaway
640uAC                             or DirectPutaway
610cDC**
610cDC**                 select
610cDC**
610cDC**    Special case for *OSSIN. If slot is passed in then
610cDC**    assume slot was created in PO236 and we are not just
610cDC**    assigning the qty and license to it.
610cDC**
610cDC**                 when      $psubcmd = '*OSSIN'
610cDC**                           and $sldispu
610cDC**                           and $sldisp <> ' '
610cDC**                 exsr      verifyrcvm
610cDC**
610cDC**    Special case for RCV/STG/OSS/USR where a virtual
610cDC**    slot will always be created.
610cDC**
610cDC**                 when      $psubcmd = '*RCVIN' or
610cDC**                           $psubcmd = '*STGIN' or
610cDC**                           $psubcmd = '*OSSIN' or
610cDC**                           $psubcmd = '*USRIN'
610cDC**                 exsr      verifyrcvs
600dA
600dA*     Normal receive into slot processing.
600dA
610cDC**                 other
     C                   exsr      verifyrcvm
600dA
610cDC**                 endsl
600dA
     C                   if        error
     C                   goto      endvfyrcv
     C                   endif
600dA
     C                   endif
417sA
417sA*  Special check for *CLSRCVADJ.
417sA
417sAC                   if        $psubcmd = '*CLSRCVADJ'
417sA
417sA*    Validate adjustment code.
417sA
417sAC                   eval      vfyadjc = *on
417sAC                   call(e)   'VFYADJC'
417sAC                   parm      '*VERIFY'     $vcommand
417sAC                   parm      '*NONE'       $vprg
417sAC                   parm      $sacode       $vcode
417sAC                   parm      ' '           $vsys
417sAC                   parm      ' '           $vdesc
417sAC                   parm      ' '           $vreturn
417sAC                   parm      ' '           $vmessage
417sAC                   parm      ' '           $vmsgk
417sA
417sAC                   select
417sAC                   when      %error
417sAC                   eval      error = *on
417sAC                   eval      $preturn  = 'CALLERROR'
417sAC                   eval      $pmessage = 'Error occured on call to '
417sAC                                       + 'VFYADJC'
417sAC                                       + '/' + %trim($vcommand)
417sAC                                       + ' from ' + #prog
417sAC                   goto      endvfyrcv
417sA
417sAC                   when      $vreturn <> '*OK'
417sAC                   eval      error = *on
417sAC                   eval      $sacodee = '1'
417sAC                   eval      $preturn = $vreturn
417sAC                   eval      $pmessage = $vmessage
417sAC                   goto      endvfyrcv
417sA
417sAC                   endsl
417sA
417sAC                   endif

     C     endvfyrcv     endsr

416dA*----------------------------------------------------------------
416dA*  verifyrcvd   Verify for Directed putaway department.
416dA*----------------------------------------------------------------
416dA
416daC     verifyrcvd    begsr
600tAC                   eval      currRoutine = 'verifyrcvd'
600tAC                   exsr      phpgmV1V2V3s
416oAC                   eval      vslotcreated = *off

     *  If called from RC160 (Directed Putaway)
     *    then we can skip the rest of the checks.

     C                   if        $pprogram = 'RC160'
     C                   goto      endvfyrcvd
     C                   endif

     *  Make sure that slot contains "slot" item ...
     *    except when dealing with a Verified slot.

     C                   if        slstat <> 'V' and slitem <> #slotitem
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn  = 'WRONGITEM'
     C                   exsr      getmsg
     C                   goto      endvfyrcvd
     C                   endif
MQS A*
MQS A*    if slot def for current slot matches Staging/Store slot def then
MQS A*    force "S" or #dtypeitem to ignore next check
MQS A*
MQS Ac                   if        client = Marques
MQS Ac                   if        slsdef = oprzst
MQS Ac                             and #dtypeitem='H'
MQS Ac                   eval      #dtypeitem = 'S'
MQS Ac                   endif
MQS Ac                   endif

     *  If receiving into an Active or Verified slot ...
     *    Then the dept, section and designation must match.
     *    Otherwise, match isn't necessary.

     C                   if        slstat = 'A' or slstat = 'V'
     C                   if        slwhdp <> #slotwhdp  or
     C                             slstyp <> #slotstyp  or
     C                             sldesg <> #slotdesg
     C                               and #dtypeslot ='H' or
     C                             sldesg <> #slotdesg
     C                               and #dtypeitem ='H'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slstype = '1'
     C                   eval      $sldesge = '1'
600qDC**                 eval      $preturn = 'ISMISMTCH'
600qMC                   eval      $preturn = 'ISMISMTCH2'
     C                   exsr      getmsg
     C                   goto      endvfyrcvd
     C                   endif
     C                   endif

     *  Cannot reduce the quantity of a 'Z' or 'V' slot.

     C                   if        slstat = 'V' or slstat = 'Z'
     C                   if        ($saqty1 - $saorg1) < 0 or
     C                             ($saqty2 - $saorg2) < 0 or
     C                             ($saqty3 - $saorg3) < 0
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn = 'NEGRCVQTY'
     C                   exsr      getmsg
     C                   goto      endvfyrcvd
     C                   endif
     C                   endif

     *  Verify that the # of pick slots doesn't exceed maximum for item.

     C                   exsr      verifypick
     C                   if        error
     C                   goto      endvfyrcvd
     C                   endif

     C     endvfyrcvd    endsr

416dA*----------------------------------------------------------------
416dA*  verifyrcvm   Verify for Manual putaway department.
416dA*----------------------------------------------------------------
416dA
416daC     verifyrcvm    begsr
600tAC                   eval      currRoutine = 'verifyrcvm'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off
500gA
500gA*  Get tracking options.
500gA
500gAC                   exsr      gettrack

500fA*  Virtual slot is not allowed to be sent.
500fA
500mDC**                 if        slrsrv = 'V'
500mDC**                 eval      error = *on
500mDC**                 eval      $slwhdpe = '1'
500mDC**                 eval      $sldispe = '1'
500mDC**                 eval      $preturn = 'VIRTLSLOT'
500mDC**                 exsr      getmsg
500mDC**                 goto      endvfyrcvm
500mDC**                 endif
600lA
600lA*  Get base slot
600lA
600lAC                   exsr      getbaseslot

     *  Get slot definition information.

     C                   exsr      getslotdef

     *  If reducing quantity,
     *    assume we are adjusting an existing slot and skip lookup.

     C                   if        ($saqty1 - $saorg1) < 0 or
     C                             ($saqty2 - $saorg2) < 0 or
     C                             ($saqty3 - $saorg3) < 0
     C                   goto      haveslot
     C                   endif

417jA*  If slot is inactive, prevent receiving into slot.
417jA
PCKAAC                   if        client <> 'PACKERS'
416jAC                   if        $psubcmd = '*RECEIVE'  or
417jMC                             $psubcmd = '*PUTAWAY'  or
500xAC                             $psubcmd = '*STAGEPUT' or
417jMC                             $psubcmd = '*RETURN'   or
416jAC                             $psubcmd = '*CLSRCV'   or
416sAC                             $psubcmd = '*CLSRCVADJ' or
417jMC                             $psubcmd = '*CLSRTN'   or
500iAC                             $psubcmd = '*STUFFIT'  or
417jMC                             $psubcmd = '*CLSPUTAWY' or
500xAC                             $psubcmd = '*CLSSTGPUT' or
600dAC                             ($psubcmd = '*USR2PUT' and
640uAC                               ManualPutaway and
600dAC                               $saAction = 'PUT') or
720 AC                             ($psubcmd = '*USR2RPA' and
720 AC                               ManualPutaway and
720 AC                               $saAction = 'PUT') or
600dAC                             ($psubcmd = '*USR2RTN' and
600dAC                               $saAction = 'PUT') or
500eAC                             $psubcmd = '*VERIFYPUT' or
500xAC                             $psubcmd = '*VFYSTGPUT' or
500eAC                             $psubcmd = '*VERIFYRTN' or
600aDC*                            $psubcmd = '*VERIFYSI'
600aMC                             $psubcmd = '*VERIFYSI'  or
600aAC                             $psubcmd = '*VERIFYTFI'
417jAC                   if        slstat <> 'A'
417jAC                             and slstat <> 'V'
417jAC                             and slstat <> 'Z'
PCKcAC                             and client <> Packers
700oAC                             and $psubcmd <> '*STUFFIT'
700oAC                             and $psubcmd <> '*VERIFYSI'
700oDC*                            and ($psubcmd = '*STUFFIT'
700oDC*                            and slstat <> 'RP')
700oDC*                            and ($psubcmd = '*VERIFYSI'
700oDC*                            and slstat <> 'RP')
PCKcA*
PCKcA*      Allow Special Order status slots to be putaway.
PCKcAC                             or  client = Packers
PCKcAC                             and (slstat <> 'A'
PCKcAC                             and  slstat <> 'V'
PCKcAC                             and  slstat <> 'Z'
PCKcAC                             and  slstat <> 'SO')

700oAC                             or slstat <> 'A'
700oAC                             and slstat <> 'V'
700oAC                             and slstat <> 'Z'
700oAC                             and client <> Packers
700oAC                             and ($psubcmd = '*STUFFIT'
700oAC                             and slstat <> 'RP' or
700oAC                                $psubcmd = '*VERIFYSI'
700oAC                             and slstat <> 'RP')
PCKcA*
RYLaAC                   if        client <> Freshsense
RYLaAC                             and slstat <> 'XD'

710nAc                   if        opiswn = 'Y'   and
710nAc                             $sldispe = '3'
710nAc                   else
417jAC                   eval      error = *on
417jAC                   eval      $slwhdpe = '1'
417jAC                   eval      $sldispe = '1'
417jAC                   eval      $preturn = 'SLTNOTACTV'
710nAc                   if        opiswn = 'Y'
710nAc                   eval      $sldispe = '2'
710nAc                   endif
417jAC                   exsr      getmsg
417jAC                   goto      endvfyrcvm
710nAC                   endif

RYLaAC                   endif

417jAC                   endif
417jAC                   endif
PCKAAC                   endif
501fA
501fA*   Can only put into existing pick slot if no overflow slot exist
501fA*   Unless it is a return - returns can go to pick slot.
501fA*   Allow override to put any product into pick slot.
501fA
501fAC                   if        slpick = 'Y'
640hAC                   if        $slpicku = *on
640hAC                   eval      $slpick = slpick
640hAC                   endif
501fAC                   if        $psubcmd = '*PUTAWAY'  or
500xAC                             $psubcmd = '*STAGEPUT' or
501fAC                             $psubcmd = '*CLSPUTAWY' or
500xAC                             $psubcmd = '*CLSSTGPUT' or
600dAC                             ($psubcmd = '*USR2PUT' and
640uAC                               ManualPutaway and
600dAC                               $saAction = 'PUT') or
500xMC                             $psubcmd = '*VERIFYPUT' or
500xAC                             $psubcmd = '*VFYSTGPUT'
501fAC                   if        $slpicke <> '3'
600dAC                   eval      saveSLREC = slrecds
501fAC                   exsr      look4overflow
600dAC                   eval      slrecds = saveSLREC
501fAC                   if        overflowfound
501fAC                   eval      error = *on
501fAC                   eval      $slpicke = '2'
501fAC                   eval      $preturn = 'WARNPICK'
501fAC                   exsr      getmsg
501fAC                   goto      endvfyrcvm
501fAC                   endif
501fAC                   endif
501fAC                   endif
501fAC                   endif

     *  See if item already exists in slot (either base or virtual).
500gA*  Also see if it's in same slot position and other things.
600lA*
600lA*  Because of license tracking rules, this has been modified.
600lA*  The look4slot routine will now determine whether we can use
600lA*  an existing slot or we need to use a new one.

510dAC                   eval      $sdpos   = *zeros
     C                   exsr      look4slot

500gA*  If item does not exist in slot,
500gA*    Then skip over other "Found" checks.
500gA
500gMC                   if        not found
500gMC                   goto      skipfoundchks
500gMC                   endif

417jA*  Item exists in slot ...

600lDC**                 select
600lD **
600lD **   If item exists in same slot position ...
600lD **
600lDC**                 when      samepos
600dA
600dA*      If item does not exist in slot for *OSSIN,
600dA*        Then throw error.
600dA
600dAC                   if        $psubcmd = '*OSSIN'
600dAC                             and (not found or not samepos)
600dAC                   eval      error = *on
600dAC                   eval      $slwhdpe = '1'
600dAC                   eval      $sldispe = '1'
600dAC                   eval      $preturn = 'OSSNOTFND'
600dAC                   exsr      getmsg
600dAC                   goto      endvfyrcvm
600dAC                   endif

611eA*      If item does not exist in slot for *PREIN,
611eA*        Then throw error.
611eA
611eAC                   if        $psubcmd = '*PREIN'
611eAC                             and (not found or not samepos)
611eAC                   eval      error = *on
611eAC                   eval      $slwhdpe = '1'
611eAC                   eval      $sldispe = '1'
611eAC                   eval      $preturn = 'PRENOTFND'
611eAC                   exsr      getmsg
611eAC                   goto      endvfyrcvm
611eAC                   endif

700dA*      If item does not exist in slot for *AMPIN,
700dA*        Then throw error.
700dA
700dAC                   if        $psubcmd = '*AMPIN'
700dAC                             and (not found or not samepos)
700dAC                   eval      error = *on
700dAC                   eval      $slwhdpe = '1'
700dAC                   eval      $sldispe = '1'
700dAC                   eval      $preturn = 'AMPNOTFND'
700dAC                   exsr      getmsg
700dAC                   goto      endvfyrcvm
700dAC                   endif

500gA*      Retreive "same" slot.
500gA
500gAC                   eval      lock = *off
500gAC                   eval      kywhse = samewhse
500gAC                   eval      kywhdp = samewhdp
500gAC                   eval      kydisp = samedisp
500gAC                   eval      check4err = *on
500gAC                   exsr      getslot2
500gAC                   if        error
500gAC                   eval      $slwhdpe = '1'
500gAC                   eval      $sldispe = '1'
500gAC                   goto      endvfyrcvm
500gAC                   endif
600dA
600dA*      If *OSSIN and qty exists in slot,
600dA*        Then throw error.
600dA
600dAC                   if        $psubcmd = '*OSSIN'
600dAC                   exsr      checkallzero
600dAC                   if        not allZero
600dAC                   eval      error = *on
600dAC                   eval      $slwhdpe = '1'
600dAC                   eval      $sldispe = '1'
600dAC                   eval      $preturn = 'OSSNOTZRO'
600dAC                   exsr      getmsg
600dAC                   goto      endvfyrcvm
600dAC                   endif
600dAC                   endif

611eA*      If *PREIN and qty exists in slot,
611eA*        Then throw error.
611eA
611eAC                   if        $psubcmd = '*PREIN'
611eAC                   exsr      checkallzero
611eAC                   if        not allZero
611eAC                   eval      error = *on
611eAC                   eval      $slwhdpe = '1'
611eAC                   eval      $sldispe = '1'
611eAC                   eval      $preturn = 'PRENOTZRO'
611eAC                   exsr      getmsg
611eAC                   goto      endvfyrcvm
611eAC                   endif
611eAC                   endif
600lA
700dA*      If *AMPIN and qty exists in slot,
700dA*        Then throw error.
700dA
700dAC                   if        $psubcmd = '*AMPIN'
700dAC                   exsr      checkallzero
700dAC                   if        not allZero
700dAC                   eval      error = *on
700dAC                   eval      $slwhdpe = '1'
700dAC                   eval      $sldispe = '1'
700dAC                   eval      $preturn = 'AMPNOTZRO'
700dAC                   exsr      getmsg
700dAC                   goto      endvfyrcvm
700dAC                   endif
700dAC                   endif
600lA
600lA*     Otherwise, merge item into existing slot.
600lA
600lAC                   goto      haveslot

600dD **     If item and slot have a different expiration date,
600dD **     and they are in the same pallet position,
600dD **       then don't allow item to be put into slot.
600dD **
600dD **     Allow this situation for some clients. Set off the same pos
600dD **     flag in order to force the code below to create a virtual slot.
600dD **
500gDC**                 if        found and difexpdte
600dDC**                 if        sameposdiffdte
600dD **
600dDC**                 if        client = jordanos
600dDC**                           or client = 'DAVE'
600dDC**                 eval      samepos = *off
600dD **
600dDC**                 else
600dD **
600dDC**                 eval      error = *on
600dDC**                 eval      $slwhdpe = '1'
600dDC**                 eval      $sldispe = '1'
600dDC**                 eval      $slexpde = '1'
600dDC**                 eval      $preturn = 'DIFEXPDTE'
600dDC**                 exsr      getmsg
600dDC**                 goto      endvfyrcvm
600dD **
600dDC**                 endif
600dD **
600dDC**                 endif
600dD **
600dD **     If item and slot have a different lot codes,
600dD **     and they are in the same pallet position,
600dD **       then don't allow item to be put into slot.
600dD **
600dDC**                 if        sameposdifflot
600dDC**                 eval      error = *on
600dDC**                 eval      $slwhdpe = '1'
600dDC**                 eval      $sldispe = '1'
600dDC**                 eval      $slexpde = '1'
600dDC**                 eval      $preturn = 'DIFLOTCODE'
600dDC**                 exsr      getmsg
600dDC**                 goto      endvfyrcvm
600dDC**                 endif
600lD **
600lD **     If not a Pick slot and not *OSSIN,
600lD **       Then, if High tracked item and item already same position,
600lD **         Then don't allow item to be put into slot.
600lD **
600lD **     Decided that this wasn't necessary.
600lD **
600lDC**                 if        slpick <> 'Y'
600lDC**                           and $psubcmd <> '*OSSIN'
600lDC**                 if        samepos and trackitem = tHigh
600lDC**                 eval      error = *on
600lDC**                 eval      $slwhdpe = '1'
600lDC**                 eval      $sldispe = '1'
600lDC**                 eval      $slexpde = '1'
600lDC**                 eval      $preturn = 'HLPEXIST'
600lDC**                 exsr      getmsg
600lDC**                 goto      endvfyrcvm
600lDC**                 endif
600lDC**                 endif
600dD **
600dD **     If Medium tracked item,
600dD **       and not *OSSIN,
600dD **       then don't allow item to be put into slot.
600dD **
600dDC**                 if        samepos and trackitem = tMedium
600dDC**                 eval      error = *on
600dDC**                 eval      $slwhdpe = '1'
600dDC**                 eval      $sldispe = '1'
600dDC**                 eval      $slexpde = '1'
600dDC**                 eval      $preturn = 'MLPEXIST'
600dDC**                 exsr      getmsg
600dDC**                 goto      endvfyrcvm
600dDC**                 endif
600lDC**
600lDC**     Now see if we want to merge item into existing slot.
600lDC**     or try to create a new Virtual slot.
600lDC**
600lDC**       If not a Pick slot and not *OSSIN,
600lDC**         Then, If existing item is not in same slot position,
600lDC**               or Item tracking is not Low.
600lDC**           Then, Create a new slot.
600lDC**
600lDC**                 if        slpick <> 'Y'
600lDC**                           and $psubcmd <> '*OSSIN'
600lDC**                 if        not samepos
600lDC**                           or trackitem <> tLow
600lDC**                 goto      skipfoundchks
600lDC**                 endif
600lDC**                 endif
600lDC**
600lDC**       Otherwise, merge item into existing slot.
600lDC**
600lDC**                 if        found
600lDC**                 goto      haveslot
600lDC**                 endif
600lDC**
600lDC**                 endsl

500gA*  Item doesn't exist in slot,
500gA*  or we didn't want to merge into existing slot position.
500gA
500gMC     skipfoundchks tag

     *  Re-retreive base slot. Info was destroyed in look4slot routines.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfyrcvm
     C                   endif

650sA*  Get slot designation type if designation wasn't sent in.
650sA*  If it was sent, then the type was retreived in verifygen.

650sAC                   if        not $sldesgu
650sAC                   eval      check4err = *off
650sAC                   eval      desigcode = sldesg
650sAC                   exsr      getdesig
650sAC                   eval      #dtypeslot = $dstype
650sAC                   endif

650nA*  If Repack slot, item must match
650nAC                   if        slstat = 'RP'
650nAC                             and slitem <> #slotitem
650nAC                   eval      error = *on
650nAC                   eval      $sliteme = '1'
650nAC                   eval      $preturn = 'RPKSLTITM'
650nAC                   exsr      getmsg
650nAC                   goto      endvfyrcvm
650nAC                   endif
MQS A*
MQS A*    if slot def for current slot matches Staging/Store slot def then
MQS A*    force "S" or #dtypeitem to ignore next check
MQS A*
MQS Ac                   if        client = Marques
MQS Ac                   if        slsdef = oprzst
MQS Ac                             and #dtypeitem='H'
MQS Ac                   eval      #dtypeitem = 'S'
MQS Ac                   endif
MQS Ac                   endif

     *  If base slot does not have an inactive status ...
     *    Then the dept, section and designation must match.
     *    Otherwise, match isn't necessary.

     C                   if        (slstat = 'A' or
     C                             slstat = 'V' or
730gDC*                            slstat = 'Z')
730gMC                             slstat = 'Z') and sldesg<>'*DROP'
     C                   if        slwhdp <> #slotwhdp  or
     C                             slstyp <> #slotstyp  or
     C                             sldesg <> #slotdesg
750dAC                               and $pprogram <> 'UT311'
     C                               and #dtypeslot ='H' or
     C                             sldesg <> #slotdesg
750dAC                               and $pprogram <> 'UT311'
     C                               and #dtypeitem ='H'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slstype = '1'
     C                   eval      $sldesge = '1'
600qDC**                 eval      $preturn = 'ISMISMTCH'
600qMC                   eval      $preturn = 'ISMISMTCH2'
     C                   exsr      getmsg
     C                   goto      endvfyrcvm
     C                   endif
     C                   endif
710jA*  Check to make sure the product doesn't have any class
710jA*    rules that prevent this slot from being used.
710jAc                   exsr      verifyclass
710jAc                   if        error = *on
      **** SET $PRETURN IN VERIFYCLASS
710jAC                   exsr      getmsg
710jAC                   goto      endvfyrcvm
710jAc                   endif

     *  If base slot is at 'V' status, use it.
610gA*  Except when doing an inventory/cycle count,
610gA*    then always create a virtual.

     C                   if        slstat = 'V'
610gAC                               and $psubcmd <> '*QTY2PUT0'
611bAC                             or slstat = 'RP'
611bAC                               and $psubcmd <> '*QTY2PUT0'
610gAC                             or slstat = 'V'
610gAC                               and $psubcmd = '*QTY2PUT0'
610gAC                               and $saAction <> 'CNT'
740dAC                               and $saAction <> 'LAC'
640tAC                             or slstat = 'V'
640tAC                               and $psubcmd = '*DPPUT'
PCKcA*
PCKcA*  Treat slots with SO status and no item as Verified.
PCKcAC                             or  client = Packers
PCKcAC                             and slstat = 'SO'
PCKcAC                             and slitem = ' '
PCKcA*
WSTbA*
WSTbA*  If Westside slot status A with No license, use it.
WSTbA*  Directed putaway put the item in this slot, jut not the license
WSTbA*
WSTbAC                              or slstat = 'A'
WSTbAC                                and $psubcmd <> '*QTY2PUT0'
WSTbAC                                and $litolcns = '*NONE'
750cDC**                              and (client = westside
750cDC**                              or client = EI)
WSTbAC                                and DirectPutaway
WSTcAC                               and $pprogram = 'RC200'
EIa A*
EIa A*  Treat slots with 'I'status and no item as Verified.
EIa AC                             or  client = EI
EIa AC                             and slstat = 'I'
EIa AC                             and slitem = ' '
SFGdAC                             or  client = sgc
SFGdAC                             and slstat = 'I'
SFGdAC                             and slitem = ' '
SFGdA*
     C                   exsr      verifypick
     C                   if        error
     C                   goto      endvfyrcvm
     C                   endif
     C                   goto      haveslot
     C                   endif

     *  Otherwise, try and create a virtual slot.
650qAc                   if        slstat = 'PR'
650qAc                   goto      haveslot
650qAc                   endif

640xA*    For overflow slots, see if Virtuals are allowed.
640xA*    (*VIRTUAL options are retrieve in look4slot)
640xA
WSTbAc                   select
WSTbAc                   when      client = westside
WSTbAc                             and $pprogram <> 'RC160'
WSTbAC                             and slpick = 'N' and opvovf = 'C'
WSTbAc                             and trackitem <> tLow
WSTbAc                   other
640xAC                   if        slpick = 'N' and opvovf = 'N'
WSTbAc                             or  client = westside
WSTbAc                             and slpick = 'N' and opvovf = 'C'
640xAC                   eval      error = *on
640xAC                   eval      $preturn = 'VRTNOTALWO'
640xAC                   exsr      getmsg
640xAC                   goto      endvfyrcvm
640xAC                   endif
WSTbAc                   endsl

     C                   exsr      crtvirtual
     C                   if        error
     C                   goto      endvfyrcvm
     C                   endif

     *  We now have a slot that we can use. Now for a few more checks.

     C     haveslot      tag

416oA*  If we are just verifying and a virtual slot was created ...
416oA*    Then skip to the end.
416oA
417 AC                   if        $psubcmd = '*VERIFYTFI'
417hAC                             or $psubcmd = '*VERIFYLTI'
417hAC                             or $psubcmd = '*VERIFYPRI'
417hAC                             or $psubcmd = '*VERIFYSSI'
417gAC                             or $psubcmd = '*VFYTFICHG'
417hAC                             or $psubcmd = '*VFYLTICHG'
417hAC                             or $psubcmd = '*VFYPRICHG'
417hAC                             or $psubcmd = '*VFYSSICHG'
500tAC                             or $psubcmd = '*VFYCLSTFI'
500tAC                             or $psubcmd = '*VFYCLSLTI'
500tAC                             or $psubcmd = '*VFYCLSPRI'
500tAC                             or $psubcmd = '*VFYCLSSSI'
500tAC                             or $psubcmd = '*VFYCLSTIC'
500tAC                             or $psubcmd = '*VFYCLSLIC'
500tAC                             or $psubcmd = '*VFYCLSPIC'
500tAC                             or $psubcmd = '*VFYCLSSIC'
500eAC                             or $psubcmd = '*VERIFYPUT'
500xAC                             or $psubcmd = '*VFYSTGPUT'
500eAC                             or $psubcmd = '*VERIFYRTN'
500iAC                             or $psubcmd = '*VERIFYSI'
416oAC                   if        vslotcreated
650qAc                              or slstat = 'PR'
416oAC                   goto      endvfyrcvm
416oAC                   endif
417 AC                   endif

     *  Cannot update a 'Z' or 'V' slot with negative quantity.

     C                   if        slstat = 'V' or slstat = 'Z'
     C                   if        ($saqty1 - $saorg1) < 0 or
     C                             ($saqty2 - $saorg1) < 0 or
     C                             ($saqty3 - $saorg1) < 0
     C                   eval      error = *on
500oDC*                  eval      $slitem = '1'
500oMC                   eval      $sliteme = '1'
     C                   eval      $preturn = 'NEGRCVQTY'
     C                   exsr      getmsg
     C                   goto      endvfyrcvm
     C                   endif
     C                   endif

     *  Get and lock the slot to be used.
416oA*    - Don't lock when just verifying.

416oAC                   if        $psubcmd = '*VERIFYTFI'
417hAC                             or $psubcmd = '*VERIFYLTI'
417hAC                             or $psubcmd = '*VERIFYPRI'
417hAC                             or $psubcmd = '*VERIFYSSI'
417gAC                             or $psubcmd = '*VFYTFICHG'
417hAC                             or $psubcmd = '*VFYLTICHG'
417hAC                             or $psubcmd = '*VFYPRICHG'
417hAC                             or $psubcmd = '*VFYSSICHG'
500eAC                             or $psubcmd = '*VERIFYPUT'
500xAC                             or $psubcmd = '*VFYSTGPUT'
500eAC                             or $psubcmd = '*VERIFYRTN'
500iAC                             or $psubcmd = '*VERIFYSI'
416oAC                   eval      lock = *off
416oAC                   else
     C                   eval      lock = *on
416oAC                   endif
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfyrcvm
     C                   endif

     C     endvfyrcvm    endsr

600dA*----------------------------------------------------------------
600dA*  verifyrcvs   Verify for special RCV/STG/OSS/USR commands.
600dA*----------------------------------------------------------------
600dA
600daC     verifyrcvs    begsr
600tAC                   eval      currRoutine = 'verifyrcvs'
600tAC                   exsr      phpgmV1V2V3s
     C                   eval      vslotcreated = *off

     *  Set aisle/loc/lvl based on base slot information
     *  from GETSLOT2USR, which was called in verifyqty.

     C                   eval      $slaisl = slaisl
     C                   eval      $slrlvl = slrlvl
     C                   eval      $sldisp = sldisp

     *  Always create new virtual slot for special RCV/STG/OSS/USRIN.
     *  For RCV/STG we will try to find an available slot for
     *    slot levels 1 - 10. That will give us 7020 possibilities.
     *    Therefore, we are assuming there will never be more than
     *    7020 items in one of these special slots.
     *  For USRIN we try once because the loc/lvl conatins the emp#

     C                   dow       forever = forever
600vAC                   eval      slhand = ' '
     C                   exsr      crtvirtual

     C                   select

     C                   when      not error
     C                   leave

     C                   when      $psubcmd = '*USRIN'
     C                   goto      endvfyrcvs

     C                   when      $slrlvl = 10
     C                   goto      endvfyrcvs

     C                   other
     C                   eval      $slrlvl = $slrlvl + 1
     C                   iter

     C                   endsl

     C                   enddo

     *  Get and lock the slot to be used.

     C                   eval      lock = *on
     C                   eval      kywhse = slwhse
     C                   eval      kywhdp = slwhdp
     C                   eval      kydisp = sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfyrcvs
     C                   endif

     C     endvfyrcvs    endsr

600dA*----------------------------------------------------------------
600dA*  verifyusr    Verify USR slot info
600dA*----------------------------------------------------------------
600dA
600dAC     verifyusr     begsr
600tAC                   eval      currRoutine = 'verifyusr'
600tAC                   exsr      phpgmV1V2V3s
601hA
601hA*  USR slot cannot be sent as main slot.
601hA
601hAC                   if        %subst($sldisp:1:3) = 'USR'
601hAC                   eval      error = *on
601hAC                   eval      $sldisp = '1'
601hAC                   eval      $preturn = 'USRNOTALW'
601hAC                   exsr      getmsg
601hAC                   leavesr
601hAC                   endif

     *  Verify USR department sent in corresponding department field.

     C                   if        not $sacwhdu
     C                   eval      error = *on
     C                   eval      $sacwhde = '1'
     C                   eval      $preturn = 'CWHDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify USR slot was sent in corresponding display field.

     C                   if        not $sacdspu
     C                   eval      error = *on
     C                   eval      $preturn = 'CDSPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify USR slot exists.

     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $sacwhd
     C                   eval      kydisp = $sacdsp
     C                   eval      lock = *off
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $preturn = 'INVLDUSLOT'
     C                   exsr      getmsg
     C                   eval      $sacwhde = '1'
     C                   leavesr
     C                   endif

     *  Verify USR slot contains correct item.

     C                   if        slitem <> #slotitem
     C****               eval      $preturn = 'USRSLTITM'
     C****               exsr      getmsg
     C****               eval      $sacwhde = '1'
     C****               leavesr
     C                   endif

     C                   endsr

416nA*----------------------------------------------------------------
416nA*  vfychgitm    Verify information when changing item in slot.
416nA*----------------------------------------------------------------
416nA
416naC     vfychgitm     begsr
600tAC                   eval      currRoutine = 'vfychgitm'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu or $slwhdp = ' '
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfychgitm
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu or $sldisp = ' '
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     *  New item must be sent.

     C                   if        not $saitemu or $saitem = ' '
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'NEWNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     *  Validate adjustment code (default is 'CI')

     C                   if        not $sacodeu   or
     C                             $sacode = ' '  or
     C                             $sacode = 'CI'

     C                   eval      $sacode = 'CI'
     C                   eval      $vsys   = 'S'

     C                   else

     C                   eval      vfyadjc = *on
     C                   call(e)   'VFYADJC'
     C                   parm      '*VERIFY'     $vcommand
     C                   parm      '*NONE'       $vprg
     C                   parm      $sacode       $vcode
416aAC                   parm      ' '           $vsys
     C                   parm      ' '           $vdesc
     C                   parm      ' '           $vreturn
     C                   parm      ' '           $vmessage
     C                   parm      ' '           $vmsgk

     C                   select
     C                   when      %error
     C                   eval      error = *on
     C                   eval      $preturn  = 'CALLERROR'
     C                   eval      $pmessage = 'Error occured on call to '
     C                                       + 'VFYADJC'
     C                                       + '/' + %trim($vcommand)
     C                                       + ' from ' + #prog
     C                   goto      endvfychgitm

     C                   when      $vreturn <> '*OK'
     C                   eval      error = *on
     C                   eval      $sacodee = '1'
     C                   eval      $preturn = $vreturn
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfychgitm

     C                   endsl

     C                   endif

     *  Get slot information.

600vAC                   eval      kywhse = $slwhse
600vAC                   eval      kywhdp = $slwhdp
600vAC                   eval      kydisp = $sldisp
     C                   eval      lock = *off
     C                   exsr      getslot2
     C                   if        error
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   goto      endvfychgitm
     C                   endif

     C                   eval      check4err = *off
     C                   eval      desigcode = sldesg
     C                   exsr      getdesig
     C                   eval      #dtypeslot = $dstype

     *  Slot cannot have a Zero or Verify status.

     C                   if        slstat = 'Z' or slstat = 'V'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp = '1'
500oMC                   eval      $sldispe = '1'
     C                   eval      $preturn = 'NOTACTIVE'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     *  Item number cannot be changed when non-stock quantities exist.

     C                   if        slalc1 <> 0  or
     C                             slalc2 <> 0  or
     C                             slalc3 <> 0  or
     C                             sltfr1 <> 0  or
     C                             sltfr2 <> 0  or
     C                             sltfr3 <> 0  or
     C                             slpck1 <> 0  or
     C                             slpck2 <> 0  or
     C                             slpck3 <> 0  or
     C                             slrcv1 <> 0  or
     C                             slrcv2 <> 0  or
     C                             slrcv3 <> 0
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'NONSTKEXST'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     *  Verify that new item is allowed in slot.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*VERIFYS'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $saiteme = '1'
     C                   goto      endvfychgitm
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfychgitm
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3

     C                   eval      check4err = *off
     C                   eval      desigcode = $itdesg
     C                   exsr      getdesig
     C                   eval      #dtypeitem = $dstype

     *  When slot is Active ...
     *    Then the dept, section and designation must match new item.
     *    Otherwise, match isn't necessary.

     C                   if        slstat = 'A'
     C                   if        slwhdp <> #sentwhdp or
     C                             slstyp <> #sentstyp or
700pDC**                           sldesg <> #sentdesg and #dtypeslot='H' or
700pMC                             (sldesg <> #sentdesg and #dtypeslot='H'
700pMC                             and slaisl <> aisleoss) or
     C                             sldesg <> #sentdesg and #dtypeitem='H'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
500oDC*                  eval      $sldisp  = '1'
500oMC                   eval      $sldispe = '1'
600qDC**                 eval      $preturn = 'ISMISMTCH'
600qMC                   eval      $preturn = 'ISMISMTCH3'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif
     C                   endif

     *  Special checks for a fixed, active pick slot.

     C                   if        slstyp = 'F' and
     C                             slstat = 'A' and
     C                             slpick = 'Y'

     *    Make sure maximum number of picks slots is <= 1 if ...
     *      Department is Directed putaway
     *      or mulitple pick slots are not allowed.

     C                   if        DirectPutaway or opmpck <> 'Y'
     C                   if        $imnrpk > 1
     C                   eval      $imnrpk = 1
     C                   endif
     C                   endif

     *    Count existing active pick slots for new item.

     C                   call      'CNTPICK'
     C                   parm      $slwhse       $vwhse
     C                   parm      $saitem       $vitem
     C                   parm      ' '           $vwhdp
     C                   parm      ' '           $vdisp
     C                   parm                    $vcount
611aDC**                 parm                    $vreturn
611aMC                   parm                    $vreturn8
     C                   parm                    $vmessage

611aDC**                 if        $vreturn <> '*OK'
611aMC                   if        $vreturn8 <> '*OK'
     C                   eval      error = *on
700iDC*                  eval      $preturn = $vreturn
700iAC                   eval      $preturn = $vreturn8
     C                   eval      $pmessage = $vmessage
     C                   goto      endvfychgitm
     C                   endif

     *    See if we already have maximum pick slots for item.

     C                   if        $vcount >= $imnrpk
     C                   eval      error = *on
     C                   eval      $preturn = 'PCKOVRFLW'
     C                   exsr      getmsg
     C                   goto      endvfychgitm
     C                   endif

     C                   endif


     *  Verify itemqty record exists for new item.

     C                   eval      check4err = *on
     C                   eval      lock = *off
     C                   eval      #slotitem = $saitem
     C                   exsr      getitemqty
     C                   if        error
     C                   eval      $sldispe = '1'
     C                   goto      endvfychgitm
     C                   endif

     *  Verify itemqty record for original item.

     C                   eval      check4err = *on
     C                   eval      lock = *off
     C                   eval      #slotitem = slitem
     C                   exsr      getitemqty
     C                   if        error
     C                   eval      $sldispe = '1'
     C                   goto      endvfychgitm
     C                   endif

     C     endvfychgitm  endsr

600kA*----------------------------------------------------------------
600kA*  vfychkfifo   CHKFIFO verification
600kA*----------------------------------------------------------------
600kA
600kAC     vfychkfifo    begsr
600tAC                   eval      currRoutine = 'vfychkfifo'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Status must be sent.

     C                   if        not $slstatu
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = 'STSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Section must be sent.

     C                   if        not $slstypu
     C                   eval      error = *on
     C                   eval      $slstype = '1'
     C                   eval      $preturn = 'STPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Aisle must be sent.

     C                   if        not $slaislu
     C                   eval      error = *on
     C                   eval      $slaisle = '1'
     C                   eval      $preturn = 'ASLNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Pick seq must be sent.

     C                   if        not $slpsequ
     C                   eval      error = *on
     C                   eval      $slpseqe = '1'
     C                   eval      $preturn = 'PSEQNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Level must be sent.

     C                   if        not $slrlvlu
     C                   eval      error = *on
     C                   eval      $slrlvle = '1'
     C                   eval      $preturn = 'LVLNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Handstack must be sent.

     C                   if        not $slhandu
     C                   eval      error = *on
     C                   eval      $slhande = '1'
     C                   eval      $preturn = 'HNDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Priority must be sent.

     C                   if        not $slprtyu
     C                   eval      error = *on
     C                   eval      $slprtye = '1'
     C                   eval      $preturn = 'PRTYNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Expiration date must be sent.

     C                   if        not $slexpdu
     C                   eval      error = *on
     C                   eval      $slexpde = '1'
     C                   eval      $preturn = 'EXPDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Enter date must be sent.

     C                   if        not $slentdu
     C                   eval      error = *on
     C                   eval      $slentde = '1'
     C                   eval      $preturn = 'ENTDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Get item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   leavesr
     C                   endif

     C                   endsr

700dA*----------------------------------------------------------------
700dA*  vfycrtamp  Verify information for *CRTAMP
700dA*----------------------------------------------------------------
700da
700dAC     vfycrtamp     begsr
     C                   eval      currRoutine = 'vfycrtamp'
     C                   exsr      phpgmV1V2V3s
     C                   eval      itemChanged = *off

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtamp
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtamp
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfycrtamp
     C                   endif

     *  Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtamp
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtamp
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
     C                   eval      #sentmitem = $itmitem
     C                   eval      #sentlot  = $imlot
     C                   eval      #senttrack = $imltrk

     *  If "sent" item is Alias, then set item type to parent's type.

     C                   if        #senttype = 'A'

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $itmitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtamp
     C                   endif

     C                   eval      #senttype = $ittype

     C                   endif

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtamp
     C                   endif

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
     C                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
     C                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
     C                   eval      #slotswgt = $itswgt
     C                   eval      #slotcwgt = $itcwgt
     C                   eval      #slotmitem = $itmitem
     C                   eval      #slottrack = $imltrk

     C     endvfycrtamp  endsr

600mA*----------------------------------------------------------------
600mA*  vfycrtoss  Verify information for *CRTOSS
600mA*----------------------------------------------------------------
600ma
600mAC     vfycrtoss     begsr
600tAC                   eval      currRoutine = 'vfycrtoss'
600tAC                   exsr      phpgmV1V2V3s
600dAC                   eval      itemChanged = *off

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtoss
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtoss
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfycrtoss
     C                   endif

     *  Item must be sent.

     C                   if        not $saitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtoss
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtoss
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
417fAC                   eval      #sentmitem = $itmitem
500gAC                   eval      #sentlot  = $imlot
600dAC                   eval      #senttrack = $imltrk
500cA
500cA*  If "sent" item is Alias, then set item type to parent's type.
500cA
500cAC                   if        #senttype = 'A'
500cA
500cAC                   eval      check4err = *on
500cAC                   eval      $drisubcmd = '*GETMAIN'
500cAC                   eval      item# = $itmitem
500cAC                   exsr      getitem
500cAC                   if        error
500cAC                   goto      endvfycrtoss
500cAC                   endif
500cA
500cAC                   eval      #senttype = $ittype
500cA
500cAC                   endif

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtoss
     C                   endif

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
416nAC                   eval      #slotswgt = $itswgt
416nAC                   eval      #slotcwgt = $itcwgt
417fAC                   eval      #slotmitem = $itmitem
600dAC                   eval      #slottrack = $imltrk

     C     endvfycrtoss  endsr

720 A*----------------------------------------------------------------
720 A*  vfycrtrpa  Verify information for *CRTRPA
720 A*----------------------------------------------------------------
720 A
720 AC     vfycrtrpa     begsr
720 AC                   eval      currRoutine = 'vfycrtrpa'
720 AC                   exsr      phpgmV1V2V3s
720 AC                   eval      itemChanged = *off
720 A
720 A*  Clear error flags.
720 A
720 AC                   exsr      clearerrflags
720 A
720 A*  Warehouse must be sent.
720 A
720 AC                   if        not $slwhseu
720 AC                   eval      error = *on
720 AC                   eval      $slwhsee = '1'
720 AC                   eval      $preturn = 'WHSNOTSNT'
720 AC                   exsr      getmsg
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 A*  Department must be sent.
720 A
720 AC                   if        not $slwhdpu
720 AC                   eval      error = *on
720 AC                   eval      $slwhdpe = '1'
720 AC                   eval      $preturn = 'WHDNOTSNT'
720 AC                   exsr      getmsg
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 A*  Verify warehouse department.
720 A
720 AC                   eval      check4err = *on
720 AC                   exsr      getdept
720 AC                   if        error
720 AC                   eval      $slwhdpe = '1'
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 A*  Item must be sent.
720 A
720 AC                   if        not $saitemu
720 AC                   eval      error = *on
720 AC                   eval      $sliteme = '1'
720 AC                   eval      $preturn = 'ITMNOTSNT'
720 AC                   exsr      getmsg
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 A*  Get "sent" item information.
720 A
720 AC                   eval      check4err = *on
720 AC                   eval      $drisubcmd = '*GETMAIN'
720 AC                   eval      item# = $saitem
720 AC                   exsr      getitem
720 AC                   if        error
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 AC                   eval      #sentitem = $ititem
720 AC                   eval      #senttype = $ittype
720 AC                   eval      #sentdesc = $itdesc
720 AC                   eval      #sentpdsc = $itpdsc
720 AC                   eval      #sentwhdp = $itwhdp
720 AC                   eval      #sentstyp = $itstyp
720 AC                   eval      #sentdesg = $itdesg
720 AC                   eval      #sentum1  = $itum1
720 AC                   eval      #sentflg1 = $itflg1
720 AC                   eval      #sentum2  = $itum2
720 AC                   eval      #sentumq2 = $itumq2
720 AC                   eval      #sentflg2 = $itflg2
720 AC                   eval      #sentum3  = $itum3
720 AC                   eval      #sentumq3 = $itumq3
720 AC                   eval      #sentmitem = $itmitem
720 AC                   eval      #sentlot  = $imlot
720 AC                   eval      #senttrack = $imltrk
720 A
720 A*  If "sent" item is Alias, then set item type to parent's type.
720 A
720 AC                   if        #senttype = 'A'
720 A
720 AC                   eval      check4err = *on
720 AC                   eval      $drisubcmd = '*GETMAIN'
720 AC                   eval      item# = $itmitem
720 AC                   exsr      getitem
720 AC                   if        error
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 AC                   eval      #senttype = $ittype
720 A
720 AC                   endif
720 A
720 A*  Get corresponding "slot" item for "sent" item.
720 A
720 AC                   eval      check4err = *on
720 AC                   eval      $drisubcmd = '*GETSLOT'
720 AC                   eval      item# = $saitem
720 AC                   exsr      getitem
720 AC                   if        error
720 AC                   goto      endvfycrtrpa
720 AC                   endif
720 A
720 AC                   eval      #slotitem = $ititem
720 AC                   eval      #slottype = $ittype
720 AC                   eval      #slotdesc = $itdesc
720 AC                   eval      #slotpdsc = $itpdsc
720 AC                   eval      #slotwhdp = $itwhdp
720 AC                   eval      #slotstyp = $itstyp
720 AC                   eval      #slotdesg = $itdesg
720 AC                   eval      #slotum1  = $itum1
720 AC                   eval      #slotflg1 = $itflg1
720 AC                   eval      #slotum2  = $itum2
720 AC                   eval      #slotumq2 = $itumq2
720 AC                   eval      #slotumq2orig = $itumq2
720 AC                   eval      #slotflg2 = $itflg2
720 AC                   eval      #slotum3  = $itum3
720 AC                   eval      #slotumq3 = $itumq3
720 AC                   eval      #slotumq3orig = $itumq3
720 AC                   eval      #slotnrpk = $imnrpk
720 AC                   eval      #slotflgd = $itflgd
720 AC                   eval      #slotswgt = $itswgt
720 AC                   eval      #slotcwgt = $itcwgt
720 AC                   eval      #slotmitem = $itmitem
720 AC                   eval      #slottrack = $imltrk
720 A
720 AC     endvfycrtrpa  endsr

611eA*----------------------------------------------------------------
611eA*  vfycrtpre  Verify information for *CRTPRE
611eA*----------------------------------------------------------------
611ea
611eAC     vfycrtpre     begsr
     C                   eval      currRoutine = 'vfycrtpre'
     C                   exsr      phpgmV1V2V3s
     C                   eval      itemChanged = *off

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtpre
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtpre
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfycrtpre
     C                   endif

     *  Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtpre
     C                   endif

     *  Get "sent" item information.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtpre
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
     C                   eval      #sentmitem = $itmitem
     C                   eval      #sentlot  = $imlot
     C                   eval      #senttrack = $imltrk

     *  If "sent" item is Alias, then set item type to parent's type.

     C                   if        #senttype = 'A'

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETMAIN'
     C                   eval      item# = $itmitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtpre
     C                   endif

     C                   eval      #senttype = $ittype

     C                   endif

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   goto      endvfycrtpre
     C                   endif

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
     C                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
     C                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
     C                   eval      #slotswgt = $itswgt
     C                   eval      #slotcwgt = $itcwgt
     C                   eval      #slotmitem = $itmitem
     C                   eval      #slottrack = $imltrk

     C     endvfycrtpre  endsr

650qA*----------------------------------------------------------------
650qA*  vfycrtprod  Verify for *CRTPROD
650qA*----------------------------------------------------------------
650qA
650qAC     vfycrtprod    begsr
650qAC                   eval      currRoutine = 'vfycrtprod'
650qAC                   exsr      phpgmV1V2V3s
650q
650q *  Clear error flags.
650q
650q C                   exsr      clearerrflags
650q
650q *  Warehouse must be sent.
650q
650q C                   if        not $slwhseu
650q C                   eval      error = *on
650q C                   eval      $slwhsee = '1'
650q C                   eval      $preturn = 'WHSNOTSNT'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Department must be sent.
650q
650q C                   if        not $slwhdpu
650q C                   eval      error = *on
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $preturn = 'WHDNOTSNT'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Slot display must be sent.
650q
650q C                   if        not $sldispu
650q C                   eval      error = *on
650q C                   eval      $sldispe = '1'
650q C                   eval      $preturn = 'DSPNOTSNT'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Item must be sent.
650q
650q C                   if        not $slitemu
650q C                   eval      error = *on
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $preturn = 'ITMNOTSNT'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Verify warehouse department.
650q
650q C                   eval      check4err = *on
650q C                   exsr      getdept
650q C                   if        error
650q C                   eval      $slwhdpe = '1'
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Verify valid csutomer sent if "Create Customer Slot"
650q
650q C                   eval      check4err = *on
650q  /free
                    ProdCust = 0;
                    if $samemo <> ' ';
650q                     MONITOR;
650q                ProdCust = %DEC(%XLATE('$*,':'   ':$samemo):11:0);
650q                     ON-ERROR 105;
650q                        ProdCust = 0;
650q                     ENDMON;
650q
650q                     chain ($slwhse:ProdCust) CustMast;
650q                     if not %found or
                            ($samemo <> ' ' and ProdCust =0);
650q                        error = *on;
650q                        $preturn = 'PRDCUSBAD';
650q                     endif;
                    endif;
650q  /end-free
650q C                   if        error
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Verify slot.
650q
650q C                   eval      lock = *off
650q C                   eval      kywhse = $slwhse
650q C                   eval      kywhdp = $slwhdp
650q C                   eval      kydisp = $sldisp
650q C                   eval      check4err = *on
650q C                   exsr      getslot2
650q C                   if        error
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $sldispe = '1'
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Virtual slot is not allowed to be sent.
650q
650q C                   if        slrsrv = 'V'
650q C                   eval      error = *on
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $sldispe = '1'
650q C                   eval      $preturn = 'VIRTLSLOT'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Slot must be Production Slot
650q
650q  /free
650q            // production slot aisles were loaded in array
650q            // prdslt in routine aaainit
650q                     sltc = 0;
650q                     sltc = %lookup(slaisl:prdslt:1);
710aA                    if sltc = 0;
710aA                       sltc = 1;
710aA                    endif;
650q  /end-free
650q C                   if        $slstat <> 'PR'
650q C                             or ($psubcmd <> '*CRTPROD'
650q C                                 and $psubcmd <> '*CRTPRODC')
650q c                             or sltc = 0
650q c                             or slaisl = ' '
650q C                   eval      error = *on
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $sldispe = '1'
650q C                   eval      $preturn = 'SLTNOTPRD'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Verify item and that it is allowed in slot.
650q
650q C                   eval      check4err = *on
650q C                   eval      $drisubcmd = '*VERIFYS'
650q C                   eval      item# = $slitem
650q C                   exsr      getitem
650q C                   if        error
650q C                   eval      $sliteme = '1'
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q C                   eval      #sentitem = $ititem
650q C                   eval      #senttype = $ittype
650q C                   eval      #sentdesc = $itdesc
650q C                   eval      #sentpdsc = $itpdsc
650q C                   eval      #sentwhdp = $itwhdp
650q C                   eval      #sentstyp = $itstyp
650q C                   eval      #sentdesg = $itdesg
650q C                   eval      #sentum1  = $itum1
650q C                   eval      #sentflg1 = $itflg1
650q C                   eval      #sentum2  = $itum2
650q C                   eval      #sentumq2 = $itumq2
650q C                   eval      #sentflg2 = $itflg2
650q C                   eval      #sentum3  = $itum3
650q C                   eval      #sentumq3 = $itumq3
650q C                   eval      #sentmitem = $itmitem
650q
650q C                   eval      #slotitem = $ititem
650q C                   eval      #slottype = $ittype
650q C                   eval      #slotdesc = $itdesc
650q C                   eval      #slotpdsc = $itpdsc
650q C                   eval      #slotwhdp = $itwhdp
650q C                   eval      #slotstyp = $itstyp
650q C                   eval      #slotdesg = $itdesg
650q C                   eval      #slotum1  = $itum1
650q C                   eval      #slotflg1 = $itflg1
650q C                   eval      #slotum2  = $itum2
650q C                   eval      #slotumq2 = $itumq2
650q C                   eval      #slotumq2orig = $itumq2
650q C                   eval      #slotflg2 = $itflg2
650q C                   eval      #slotum3  = $itum3
650q C                   eval      #slotumq3 = $itumq3
650q C                   eval      #slotumq3orig = $itumq3
650q C                   eval      #slotnrpk = $imnrpk
650q C                   eval      #slotflgd = $itflgd
650q C                   eval      #slotswgt = $itswgt
650q C                   eval      #slotcwgt = $itcwgt
650q C                   eval      #slotmitem = $itmitem
650q
650q *  See if item already exists in slot (either base or virtual).
650q
650q C                   eval      $sdpos   = *zeros
650q C                   exsr      look4slot
650q
650q *  If item exists in slot then we can skip trying to create a slot.
650q
650q C                   if        found
650q
650q *  Move slot fields into data structure.
650q
710c  *  this exsr was moved down after we know we have the correct
710c  *  slot for the customer
710cDC*                  exsr      slot2ds
650q
650qAC                   if        ProdCust <> 0
710aDc*                              and %subst($sldisp:1:3) = 'PRD'
710aAc                               and $slaisl = prdslt(sltc)
650qAc*        if slot found and customer slot confirm correct
650qAc*        customer before return INSLOT error
650qA
650qA /free
650qA                    chain (slwhse:sldisp) pcslot1;
650qA          // if slot found in production customer xref then
650qA          // it must match to use this virtual.  Otherwise assign
650qA          // another virtual to this customer
650qA                    if %found(pcslot1);
650qA                       if cscust = ProdCust;
650qA                          unlock pcslot1;
650q                           error = *on;
650q                           $sliteme = '1';
650q                           $preturn = 'INSLOT';
650q                           exsr getmsg;
710cA                          exsr slot2ds;
650q  /end-free
650q c                   goto      endvfycrtprd
     c*  else, if customer mismatch reset to base slot and continue search
     c                   else
650qAc                   unlock    pcslot1
     c                   eval      $sldisp = baseDisp
650qAc                   endif
650qAc                   endif
650qAc                   else
650q c                   eval      error = *on
650q c                   eval      $sliteme = '1'
650q c                   eval      $preturn = 'INSLOT'
650q c                   exsr      getmsg
710cAc                   exsr      slot2ds
650q c                   goto      endvfycrtprd
650q C                   endif
650q C                   endif
650q
650q *  Re-retreive base slot. Info was destroyed in look4slot routines.
650q
650q C                   eval      lock = *off
650q C                   eval      kywhse = $slwhse
650q C                   eval      kywhdp = $slwhdp
650q C                   eval      kydisp = $sldisp
650q C                   eval      check4err = *on
650q C                   exsr      getslot2
650q C                   if        error
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $sldispe = '1'
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q *  Dept and section must match item.
650q
650q C                   if        slwhdp <> #sentwhdp or
650q C                             slstyp <> #sentstyp
650q C                   eval      error = *on
650q C                   eval      $slwhdpe = '1'
650q C                   eval      $slstype = '1'
650q C                   eval      $preturn = 'ISMISMTCH3'
650q C                   exsr      getmsg
650q C                   goto      endvfycrtprd
650q C                   endif
650q
650q C     endvfycrtprd  endsr

510dA*----------------------------------------------------------------
510dA*  vfycrtrepack  Verify for *CRTREPAKP / *CRTREPAKR
510dA*----------------------------------------------------------------
510dA
510dAC     vfycrtrepack  begsr
600tAC                   eval      currRoutine = 'vfycrtrepack'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfycrtrpk
     C                   endif

     *  Verify slot.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfycrtrpk
     C                   endif

     *  Virtual slot is not allowed to be sent.

     C                   if        slrsrv = 'V'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'VIRTLSLOT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Slot must be in Repack aisle.

650fDC*                  if        slaisl <> 'RPK'
650fMC                   if        slaisl <> 'RPK' and slstat <> 'RP'
610zAC                             and $psubcmd <> '*CRTREPAKD'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLTNOTRPK'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Verify item and that it is allowed in slot.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*VERIFYS'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   goto      endvfycrtrpk
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
     C                   eval      #sentmitem = $itmitem

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
     C                   eval      #slotswgt = $itswgt
     C                   eval      #slotcwgt = $itcwgt
     C                   eval      #slotmitem = $itmitem

     *  See if item already exists in slot (either base or virtual).

510dAC                   eval      $sdpos   = *zeros
     C                   exsr      look4slot

     *  If item exists in slot then we can skip trying to create a slot.

     C                   if        found

610yA*  Move slot fields into data structure.

610yAC                   exsr      slot2ds

     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'INSLOT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Re-retreive base slot. Info was destroyed in look4slot routines.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfycrtrpk
     C                   endif

     *  Dept and section must match item.

     C                   if        slwhdp <> #sentwhdp or
     C                             slstyp <> #sentstyp
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slstype = '1'
600qDC**                 eval      $preturn = 'ISMISMTCH'
600qMC                   eval      $preturn = 'ISMISMTCH3'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpk
     C                   endif

     *  Call apporpriate verification routine for command.

     C                   select
     C                   when      $psubcmd = '*CRTREPAKP'
     C                   exsr      vfycrtrepackp
     C                   when      $psubcmd = '*CRTREPAKR'
610zAC                             or $psubcmd = '*CRTREPAKD'
     C                   exsr      vfycrtrepackr
     C                   endsl

     C     endvfycrtrpk  endsr

510dA*----------------------------------------------------------------
510dA*  vfycrtrepackp  Verify for *CRTREPAKP
510dA*----------------------------------------------------------------
510dA
510dAC     vfycrtrepackp begsr
600tAC                   eval      currRoutine = 'vfycrtrepackp'
600tAC                   exsr      phpgmV1V2V3s

     *  Item must be a normal item to be a Repack Parent.

     C                   if        #senttype <> ' '
650dAC                             and #senttype <> 'R'
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'NOTPARENT'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpkp
     C                   endif

     C     endvfycrtrpkp endsr

510dA*----------------------------------------------------------------
510dA*  vfycrtrepackr  Verify for *CRTREPAKR
510dA*----------------------------------------------------------------
510dA
510dAC     vfycrtrepackr begsr
600tAC                   eval      currRoutine = 'vfycrtrepackr'
600tAC                   exsr      phpgmV1V2V3s

     *  Item must be a Repack item.

     C                   if        #senttype <> 'R'
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'NOTREPACK'
     C                   exsr      getmsg
     C                   goto      endvfycrtrpkr
     C                   endif

     C     endvfycrtrpkr endsr

500nA*----------------------------------------------------------------
500nA*  vfycrtvpick  Verify for *CRTVPICK
500nA*----------------------------------------------------------------
500nA
500nAC     vfycrtvpick   begsr
600tAC                   eval      currRoutine = 'vfycrtvpick'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   goto      endvfycrtvpck
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  Verify slot.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfycrtvpck
     C                   endif

     *  Virtual slot is not allowed to be sent.

     C                   if        slrsrv = 'V'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'VIRTLSLOT'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  If slot is not a pick slot, prevent creating a virtual slot.

     C                   if        slpick <> 'Y'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLTNOTPICK'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  If slot is inactive, prevent creating a virtual slot.

     C                   if        slstat <> 'A' and
     C                             slstat <> 'V' and
     C                             slstat <> 'Z' and
730gAC                             sldesg <> '*DROP'
FPRiAC                             and client <> FoodPro
MRTaAC                             and client <> 'MERITFOODS'
FPRiA*
FPRiAC                             or client = FoodPro
FPRiAC                             and (slstat <> 'A'
FPRiAC                             and  slstat <> 'V'
FPRiAC                             and  slstat <> 'Z'
FPRiAC                             and  slstat <> 'SR'
FPRiAC                             and  slstat <> 'FR')
FPRiA*
MRTaAC                             or client = 'MERITFOODS'
MRTaAc                             and slstat <> 'RP'
MRTaA *
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLTNOTACTV'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  Verify item and that it is allowed in slot.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*VERIFYS'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   goto      endvfycrtvpck
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
417fAC                   eval      #sentmitem = $itmitem

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
416nAC                   eval      #slotswgt = $itswgt
416nAC                   eval      #slotcwgt = $itcwgt
417fAC                   eval      #slotmitem = $itmitem

     *  Get item designation code information.

     C                   eval      check4err = *off
     C                   eval      desigcode = $itdesg
     C                   exsr      getdesig
     C                   eval      #dtypeitem = $dstype
MQS A*
MQS A*    if slot def for current slot matches Staging/Store slot def then
MQS A*    force "S" or #dtypeitem to ignore next check
MQS A*
MQS Ac                   if        client = Marques
MQS Ac                   if        $slsdef = oprzst
MQS Ac                             and #dtypeitem='H'
MQS Ac                   eval      #dtypeitem = 'S'
MQS Ac                   endif
MQS Ac                   endif

     *  Dept, section and designation must match item.

     C                   if        slwhdp <> $itwhdp or
     C                             slstyp <> $itstyp or
     C                             sldesg <> $itdesg and #dtypeslot ='H' or
     C                             sldesg <> $itdesg and #dtypeitem ='H'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $slstype = '1'
     C                   eval      $sldesge = '1'
     C                   eval      $preturn = 'ISMISMTCH'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif
500qA
500qA*  Get slot definition information.
500qA
500qAC                   exsr      getslotdef

     *  See if item already exists in slot (either base or virtual).

     C                   exsr      look4slot

     *  If item exists in slot then we can skip trying to create a slot.

     C                   if        found
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'INSLOT'
     C                   exsr      getmsg
     C                   goto      endvfycrtvpck
     C                   endif

     *  Re-retreive base slot. Info was destroyed in look4slot routines.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   goto      endvfycrtvpck
     C                   endif

500nAC     endvfycrtvpck endsr


700nA*----------------------------------------------------------------
700cA*  vfycrtvoflw  Verify for *CRTVOFLW
700cA*----------------------------------------------------------------
700cA
700cAC     vfycrtvoflw   begsr
700cAC                   eval      currRoutine = 'vfycrtvoflw'
700cAC                   exsr      phpgmV1V2V3s
700cA
700cA*  Clear error flags.
700cA
700cAC                   exsr      clearerrflags
700cA
700cA*  Warehouse must be sent.
700cA
700cAC                   if        not $slwhseu
700cAC                   eval      error = *on
700cAC                   eval      $slwhsee = '1'
700cAC                   eval      $preturn = 'WHSNOTSNT'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Department must be sent.
700cA
700cAC                   if        not $slwhdpu
700cAC                   eval      error = *on
700cAC                   eval      $slwhdpe = '1'
700cAC                   eval      $preturn = 'WHDNOTSNT'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Verify warehouse department.
700cA
700cAC                   eval      check4err = *on
700cAC                   exsr      getdept
700cAC                   if        error
700cAC                   eval      $slwhdpe = '1'
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Slot display must be sent.
700cA
700cAC                   if        not $sldispu
700cAC                   eval      error = *on
700cAC                   eval      $sldispe = '1'
700cAC                   eval      $preturn = 'DSPNOTSNT'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Verify slot.
700cA
700cAC                   eval      lock = *off
700cAC                   eval      kywhse = $slwhse
700cAC                   eval      kywhdp = $slwhdp
700cAC                   eval      kydisp = $sldisp
700cAC                   eval      check4err = *on
700cAC                   exsr      getslot2
700cAC                   if        error
700cAC                   eval      $slwhdpe = '1'
700cAC                   eval      $sldispe = '1'
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Virtual slot is not allowed to be sent.
700cA
700cAC                   if        slrsrv = 'V'
700cAC                   eval      error = *on
700cAC                   eval      $slwhdpe = '1'
700cAC                   eval      $sldispe = '1'
700cAC                   eval      $preturn = 'VIRTLSLOT'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  If slot is inactive, prevent creating a virtual slot.
700cA
700cAC                   if        slstat <> 'A' and
700cAC                             slstat <> 'V' and
700cAC                             slstat <> 'Z' and
730gAC                             sldesg <> '*DROP'
700cAC                   eval      error = *on
700cAC                   eval      $slwhdpe = '1'
700cAC                   eval      $sldispe = '1'
700cAC                   eval      $preturn = 'SLTNOTACTV'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Item must be sent.
700cA
700cAC                   if        not $slitemu
700cAC                   eval      error = *on
700cAC                   eval      $sliteme = '1'
700cAC                   eval      $preturn = 'ITMNOTSNT'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Verify item and that it is allowed in slot.
700cA
700cAC                   eval      check4err = *on
700cAC                   eval      $drisubcmd = '*VERIFYS'
700cAC                   eval      item# = $slitem
700cAC                   exsr      getitem
700cAC                   if        error
700cAC                   eval      $sliteme = '1'
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cAC                   eval      #sentitem = $ititem
700cAC                   eval      #senttype = $ittype
700cAC                   eval      #sentdesc = $itdesc
700cAC                   eval      #sentpdsc = $itpdsc
700cAC                   eval      #sentwhdp = $itwhdp
700cAC                   eval      #sentstyp = $itstyp
700cAC                   eval      #sentdesg = $itdesg
700cAC                   eval      #sentum1  = $itum1
700cAC                   eval      #sentflg1 = $itflg1
700cAC                   eval      #sentum2  = $itum2
700cAC                   eval      #sentumq2 = $itumq2
700cAC                   eval      #sentflg2 = $itflg2
700cAC                   eval      #sentum3  = $itum3
700cAC                   eval      #sentumq3 = $itumq3
700cAC                   eval      #sentmitem = $itmitem
700cA
700cAC                   eval      #slotitem = $ititem
700cAC                   eval      #slottype = $ittype
700cAC                   eval      #slotdesc = $itdesc
700cAC                   eval      #slotpdsc = $itpdsc
700cAC                   eval      #slotwhdp = $itwhdp
700cAC                   eval      #slotstyp = $itstyp
700cAC                   eval      #slotdesg = $itdesg
700cAC                   eval      #slotum1  = $itum1
700cAC                   eval      #slotflg1 = $itflg1
700cAC                   eval      #slotum2  = $itum2
700cAC                   eval      #slotumq2 = $itumq2
700cAC                   eval      #slotumq2orig = $itumq2
700cAC                   eval      #slotflg2 = $itflg2
700cAC                   eval      #slotum3  = $itum3
700cAC                   eval      #slotumq3 = $itumq3
700cAC                   eval      #slotumq3orig = $itumq3
700cAC                   eval      #slotnrpk = $imnrpk
700cAC                   eval      #slotflgd = $itflgd
700cAC                   eval      #slotswgt = $itswgt
700cAC                   eval      #slotcwgt = $itcwgt
700cAC                   eval      #slotmitem = $itmitem
700cA
700cA*  Get item designation code information.
700cA
700cAC                   eval      check4err = *off
700cAC                   eval      desigcode = $itdesg
700cAC                   exsr      getdesig
700 AC                   eval      #dtypeitem = $dstype
MQS A*
MQS A*    if slot def for current slot matches Staging/Store slot def then
MQS A*    force "S" or #dtypeitem to ignore next check
MQS A*
MQS Ac                   if        client = Marques
MQS Ac                   if        $slsdef = oprzst
MQS Ac                             and #dtypeitem='H'
MQS Ac                   eval      #dtypeitem = 'S'
MQS Ac                   endif
MQS Ac                   endif
700cA
700cA*  Dept, section and designation must match item.
700cA
700cAC                   if        slwhdp <> $itwhdp or
700cAC                             slstyp <> $itstyp or
700cAC                             sldesg <> $itdesg and #dtypeslot ='H' or
700cAC                             sldesg <> $itdesg and #dtypeitem ='H'
700cAC                   eval      error = *on
700cAC                   eval      $slwhdpe = '1'
700cAC                   eval      $slstype = '1'
700cAC                   eval      $sldesge = '1'
700cAC                   eval      $preturn = 'ISMISMTCH'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Get slot definition information.
700cA
700cAC                   exsr      getslotdef
700cA
700cA*  See if item already exists in slot (either base or virtual).
700cA
700cAC                   exsr      look4slot
700cA
700cA*  If item exists in slot then we can skip trying to create a slot.
700cA
700cAC                   if        found
700cAC                   eval      error = *on
700cAC                   eval      $sliteme = '1'
700cAC                   eval      $preturn = 'INSLOT'
700cAC                   exsr      getmsg
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cA*  Re-retreive base slot. Info was destroyed in look4slot routines.
700cA
700cAC                   eval      lock = *off
700cAC                   eval      kywhse = $slwhse
700cAC                   eval      kywhdp = $slwhdp
700cAC                   eval      kydisp = $sldisp
700cAC                   eval      check4err = *on
700cAC                   exsr      getslot2
700cAC                   if        error
700cAC                   eval      $slwhdpe = '1'
700cAC                   eval      $sldispe = '1'
700cAC                   goto      endvfycrtvofl
700cAC                   endif
700cA
700cAC     endvfycrtvofl endsr

640tA*----------------------------------------------------------------
640tA*  vfydpundo     DPUNDO verification
640tA*----------------------------------------------------------------
640tA
640tAC     vfydpundo     begsr
     C                   eval      currRoutine = 'vfydpundo'
     C                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Get department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   leavesr
     C                   endif

     *  If not Directed Putaway department, get out.

     C                   if        not DirectPutaway
     C                   eval      error = *on
     C                   eval      $pmessage = 'Not Directed Putaway'
     C                   leavesr
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Item must be sent.

     C                   if        not $saitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Get corresponding "slot" item for "sent" item.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSLOT'
     C                   eval      item# = $saitem
     C                   exsr      getitem
     C                   if        error
     C                   leavesr
     C                   endif

     C                   eval      #slotitem = $ititem

     *  Get slot

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  If slot is reserverd, nothing to do so get out.
     *    This means that item was in slot before DP used it.

     C                   if        slrsrv = 'Y'
     C                   eval      error = *on
     C                   eval      $pmessage = 'Slot Reserved - Leave alone'
     C                   leavesr
     C                   endif

     *  If item is different, get out.
     *    This shouldn't happen, but protect against it anyway.

     C                   if        slitem <> #slotitem
     C                   eval      error = *on
     C                   eval      $pmessage = 'Item Different - Leave alone'
     C                   leavesr
     C                   endif

     *  If status is not Active, get out.
     *    This shouldn't happen, but protect against it anyway.

     C                   if        slstat <> 'A'
     C                   eval      error = *on
     C                   eval      $pmessage = 'Not Active - Leave alone'
     C                   leavesr
     C                   endif

     *  If stock <> 0, get out.
     *    This shouldn't happen, but protect against it anyway.

     C                   if        slstk1 <> 0
     C                             or slstk2 <> 0
     C                             or slstk3 <> 0
     C                   eval      error = *on
     C                   eval      $pmessage = 'Stock not zero - Leave alone'
     C                   leavesr
     C                   endif

     *  If non-stock buckets <> 0, get out.
     *    This would mean someone has already touched the slot, like selection.
     *    Therefore, send error message back.

     C                   if        slalc1 <> 0
     C                             or slalc2 <> 0
     C                             or slalc3 <> 0
     C                             or slpck1 <> 0
     C                             or slpck2 <> 0
     C                             or slpck3 <> 0
     C                             or sltfr1 <> 0
     C                             or sltfr2 <> 0
     C                             or sltfr3 <> 0
     C                             or slrcv1 <> 0
     C                             or slrcv2 <> 0
     C                             or slrcv3 <> 0
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLTNOTZRO'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  If slot has more than one open directed putaway, leave it alone.

     C                   call      'CHKOPNDP'
     C                   parm      $slwhse       dWhse             3 0
     C                   parm      $slwhdp       dWhdp             5
     C                   parm      $sldisp       dDisp            12
     C                   parm      $saitem       dItem            15
     C                   parm                    dTotal            3 0
     C                   parm                    dItmTtl           3 0
     C                   parm                    dQty1             5 0
     C                   parm                    dQty2             5 0
     C                   parm                    dQty3             5 0

     C                   if        dItmTtl > 1
     C                   eval      error = *on
     C                   eval      $pmessage = 'Other open putaways '
     C                                       + '- Leave alone'
     C                   leavesr
     C                   endif

     C                   endsr

500aA*----------------------------------------------------------------
500aA*  vfygetovrfav  GETOVRFAV verification
500aA*----------------------------------------------------------------
500aA
500aAC     vfygetovrfav  begsr
600tAC                   eval      currRoutine = 'vfygetovrfav'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetovrf
     C                   endif

     *    Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetovrf
     C                   endif

     *    Status must be sent.

     C                   if        not $slstatu
     C                   eval      error = *on
     C                   eval      $slstate = '1'
     C                   eval      $preturn = 'STSNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetovrf
     C                   endif

     *    Aisle must be sent.

     C                   if        not $slaislu
     C                   eval      error = *on
     C                   eval      $slaisle = '1'
     C                   eval      $preturn = 'ASLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetovrf
     C                   endif

     *    Location must be sent.

     C                   if        not $sllocu
     C                   eval      error = *on
     C                   eval      $slloce = '1'
     C                   eval      $preturn = 'LOCNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetovrf
     C                   endif

     *    Level must be sent.

     C                   if        not $slrlvlu
     C                   eval      error = *on
     C                   eval      $slrlvle = '1'
     C                   eval      $preturn = 'LVLNOTSNT'
     C                   exsr      getmsg
     C                   goto      endvfygetovrf
     C                   endif

     C     endvfygetovrf endsr

610gA*----------------------------------------------------------------
610gA*  vfyinslot    Verify item in physical slot (base or virtual)
610gA*----------------------------------------------------------------
610gA
610gAC     vfyinslot     begsr
     C                   eval      currRoutine = 'vfyinslot'
     C                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Item must be sent.

     C                   if        not $saitemu
     C                   eval      error = *on
     C                   eval      $saiteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify slot.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Virtual slot is not allowed to be sent.

     C                   if        slrsrv = 'V'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'VIRTLSLOT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  See if item is in slot.
     *    Assuming sent item is a slot item.

     C                   if        slitem = $saitem
     C                             and slstat <> 'V' and slstat <> 'Z'
     C                   eval      $preturn = 'ITMFOUND'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Make sure appropriate file is open.

     C                   exsr      openvslot2
     C                   if        error
     C                   leavesr
     C                   endif

     *  See if item is in virtual slot.

     C     keyvs2l4      setll     vslot2
     C                   dow       forever = forever

     C     keyvs2l4      reade     vslot2
     C                   if        %eof
     C                   leave
     C                   endif

     C                   eval      lock = *off
     C                   eval      kywhse = vswhse
     C                   eval      kywhdp = vswhdp
     C                   eval      kydisp = vsdisp
     C                   exsr      getslot2

     C                   if        error
     C                   eval      error = *off
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '
     C                   iter
     C                   endif

     C                   if        slitem <> $saitem
     C                             or slstat = 'V' or  slstat = 'Z'
     C                   iter
     C                   endif

MRTaAc*     Return Virtual Slot when Repack Item Maintenance.
MRTaAc*     Merit uses Virtuals for ODR slots with On Demand Repacks
MRTaAc                   if        $pprogram = 'IT116' and
MRTaAc                             client = Merit
MRTaAc                   eval      $sldisp = vsdisp
MRTaAc                   endif

     C                   eval      $preturn = 'ITMFOUND'
     C                   exsr      getmsg
     C                   leavesr

     C                   enddo

     C                   eval      $preturn = 'ITMNOTFND'
     C                   exsr      getmsg

     C                   endsr

600dA*----------------------------------------------------------------
600dA*  vfylicslt    Verify for *VFYLICSLT
600dA*----------------------------------------------------------------
600dA
600dAC     vfylicslt     begsr
600tAC                   eval      currRoutine = 'vfylicslt'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Item must be sent.

     C                   if        not $saitemu
     C                   eval      error = *on
     C                   eval      $saiteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify slot.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Move slot info into data structure.

     C                   exsr      slot2ds

     *  Slot cannot be at status 'Z' or 'V'

     C                   if        slstat = 'V'
     C                             or slstat = 'Z'
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'SLTNOTAV'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

640wA*  Get corresponding "slot" item for "sent" item.
640wA
640wAC                   eval      check4err = *on
640wAC                   eval      $drisubcmd = '*GETSLOT'
640wAC                   eval      item# = $saitem
640wAC                   exsr      getitem
640waC                   if        error
640wAC                   leavesr
640wAC                   endif

     *  Item sent must match item in the slot.

640wDC**                 if        $saitem <> slitem
640wMC                   if        $ititem <> slitem
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'ITMNOTMTCH'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   endsr

     *----------------------------------------------------------------
610dA*  vfysetfifo   SETFIFO verification
     *----------------------------------------------------------------

     C     vfySetFifo    begsr

     C                   eval      currRoutine = 'vfysetfifo'
     C                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify slot.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *    License must be sent.

     C                   if        not $saTolcnsu
     C                   eval      error = *on
     C                   eval      $saTolcnse = '1'
     C                   eval      $preturn = 'LCSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Priority must be sent.

     C                   if        not $slprtyu
     C                   eval      error = *on
     C                   eval      $slprtye = '1'
     C                   eval      $preturn = 'PRTYNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Expiration date must be sent.

     C                   if        not $slexpdu
     C                   eval      error = *on
     C                   eval      $slexpde = '1'
     C                   eval      $preturn = 'EXPDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *    Enter date must be sent.

     C                   if        not $slentdu
     C                   eval      error = *on
     C                   eval      $slentde = '1'
     C                   eval      $preturn = 'ENTDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   endsr

710kA*----------------------------------------------------------------
710kA*  vfysetolcns  SETOLCNS verification
710kA*----------------------------------------------------------------

710kAC     vfySetOLcns   begsr

710kAC                   eval      currRoutine = 'vfysetfifo'
710kAC                   exsr      phpgmV1V2V3s

710kA*  Clear error flags.

710kAC                   exsr      clearerrflags

710kA*  Warehouse must be sent.

710kAC                   if        not $slwhseu
710kAC                   eval      error = *on
710kAC                   eval      $slwhsee = '1'
710kAC                   eval      $preturn = 'WHSNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*  Department must be sent.

710kAC                   if        not $slwhdpu
710kAC                   eval      error = *on
710kAC                   eval      $slwhdpe = '1'
710kAC                   eval      $preturn = 'WHDNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*  Slot display must be sent.

710kAC                   if        not $sldispu
710kAC                   eval      error = *on
710kAC                   eval      $sldispe = '1'
710kAC                   eval      $preturn = 'DSPNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*  Verify slot.

710kAC                   eval      lock = *off
710kAC                   eval      kywhse = $slwhse
710kAC                   eval      kywhdp = $slwhdp
710kAC                   eval      kydisp = $sldisp
710kAC                   eval      check4err = *on
710kAC                   exsr      getslot2
710kAC                   if        error
710kAC                   eval      $slwhdpe = '1'
710kAC                   eval      $sldispe = '1'
710kAC                   leavesr
710kAC                   endif

710kA*    License must be sent.

710kAC                   if        not $saTolcnsu
710kAC                   eval      error = *on
710kAC                   eval      $saTolcnse = '1'
710kAC                   eval      $preturn = 'LCSNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*    Original License must be sent.

710kAC                   if        not $saOlcnsu
710kAC                   eval      error = *on
710kAC                   eval      $saOlcnse = '1'
710kAC                   eval      $preturn = 'OLCSNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*    Priority must be sent.

710kAC                   if        not $slprtyu
710kAC                   eval      error = *on
710kAC                   eval      $slprtye = '1'
710kAC                   eval      $preturn = 'PRTYNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*    Expiration date must be sent.

710kAC                   if        not $slexpdu
710kAC                   eval      error = *on
710kAC                   eval      $slexpde = '1'
710kAC                   eval      $preturn = 'EXPDNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kA*    Enter date must be sent.

710kAC                   if        not $slentdu
710kAC                   eval      error = *on
710kAC                   eval      $slentde = '1'
710kAC                   eval      $preturn = 'ENTDNOTSNT'
710kAC                   exsr      getmsg
710kAC                   leavesr
710kAC                   endif

710kAC                   endsr

600iA*----------------------------------------------------------------
600iA*  vfystuffdlt    Verify for *STUFFDLT
600iA*----------------------------------------------------------------
600iA
600iAC     vfystuffdlt   begsr
600tAC                   eval      currRoutine = 'vfystuffdlt'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Department must be sent.

     C                   if        not $slwhdpu
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $preturn = 'WHDNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify warehouse department.

     C                   eval      check4err = *on
     C                   exsr      getdept
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   leavesr
     C                   endif

     *  Slot display must be sent.

     C                   if        not $sldispu
     C                   eval      error = *on
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'DSPNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify slot.

     C                   eval      lock = *off
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2
     C                   if        error
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   leavesr
     C                   endif

     *  Virtual slot is not allowed to be sent.

     C                   if        slrsrv = 'V'
CPJaAC                             and client <> cpj
CPJaAC                             and clientloc <> cpjjamaica
     C                   eval      error = *on
     C                   eval      $slwhdpe = '1'
     C                   eval      $sldispe = '1'
     C                   eval      $preturn = 'VIRTLSLOT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Item must be sent.

     C                   if        not $slitemu
     C                   eval      error = *on
     C                   eval      $sliteme = '1'
     C                   eval      $preturn = 'ITMNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     *  Verify item and that it is allowed in slot.

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*VERIFYS'
     C                   eval      item# = $slitem
     C                   exsr      getitem
     C                   if        error
     C                   eval      $sliteme = '1'
     C                   leavesr
     C                   endif

     C                   eval      #sentitem = $ititem
     C                   eval      #senttype = $ittype
     C                   eval      #sentdesc = $itdesc
     C                   eval      #sentpdsc = $itpdsc
     C                   eval      #sentwhdp = $itwhdp
     C                   eval      #sentstyp = $itstyp
     C                   eval      #sentdesg = $itdesg
     C                   eval      #sentum1  = $itum1
     C                   eval      #sentflg1 = $itflg1
     C                   eval      #sentum2  = $itum2
     C                   eval      #sentumq2 = $itumq2
     C                   eval      #sentflg2 = $itflg2
     C                   eval      #sentum3  = $itum3
     C                   eval      #sentumq3 = $itumq3
     C                   eval      #sentmitem = $itmitem
     C                   eval      #sentlot  = $imlot
     C                   eval      #senttrack = $imltrk

     C                   eval      #slotitem = $ititem
     C                   eval      #slottype = $ittype
     C                   eval      #slotdesc = $itdesc
     C                   eval      #slotpdsc = $itpdsc
     C                   eval      #slotwhdp = $itwhdp
     C                   eval      #slotstyp = $itstyp
     C                   eval      #slotdesg = $itdesg
     C                   eval      #slotum1  = $itum1
     C                   eval      #slotflg1 = $itflg1
     C                   eval      #slotum2  = $itum2
     C                   eval      #slotumq2 = $itumq2
600xAC                   eval      #slotumq2orig = $itumq2
     C                   eval      #slotflg2 = $itflg2
     C                   eval      #slotum3  = $itum3
     C                   eval      #slotumq3 = $itumq3
600xAC                   eval      #slotumq3orig = $itumq3
     C                   eval      #slotnrpk = $imnrpk
     C                   eval      #slotflgd = $itflgd
     C                   eval      #slotswgt = $itswgt
     C                   eval      #slotcwgt = $itcwgt
     C                   eval      #slotmitem = $itmitem
     C                   eval      #slottrack = $imltrk

     *  Get corresponding SSB item for "slot" item (if any)

     C                   eval      check4err = *on
     C                   eval      $drisubcmd = '*GETSSB'
     C                   eval      item# = #slotitem
     C                   exsr      getitem

     C                   if        error

     C                   eval      error = *off
     C                   eval      ssbflag = *off
     C                   eval      $preturn = '*OK'
     C                   eval      $pmessage = ' '

     C                   else

     C                   eval      ssbflag = *on
     C                   eval      #ssbitem = $ititem
     C                   eval      #ssbtype = $ittype
     C                   eval      #ssbdesc = $itdesc
     C                   eval      #ssbpdsc = $itpdsc
     C                   eval      #ssbwhdp = $itwhdp
     C                   eval      #ssbstyp = $itstyp
     C                   eval      #ssbdesg = $itdesg
     C                   eval      #ssbum1  = $itum1
     C                   eval      #ssbum2  = $itum2
     C                   eval      #ssbumq2 = $itumq2
     C                   eval      #ssbum3  = $itum3
     C                   eval      #ssbumq3 = $itumq3

     C                   endif

     C                   endsr

600iA*----------------------------------------------------------------
600iA*  vfysynclcns    Verify for *SYNCLCNS
600iA*----------------------------------------------------------------
600iA
600iAC     vfysynclcns   begsr
600tAC                   eval      currRoutine = 'vfysynclcns'
600tAC                   exsr      phpgmV1V2V3s

     *  Clear error flags.

     C                   exsr      clearerrflags

     *  Warehouse must be sent.

     C                   if        not $slwhseu
     C                   eval      error = *on
     C                   eval      $slwhsee = '1'
     C                   eval      $preturn = 'WHSNOTSNT'
     C                   exsr      getmsg
     C                   leavesr
     C                   endif

     C                   endsr

     *----------------------------------------------------------------
     *  warningchk   Warning checks.
     *----------------------------------------------------------------

     C     warningchk    begsr

     *  Set warning type

     C                   eval      warningtype = $psubcmd

     *  Main loop.

     C                   dow       forever = forever

     *    Blank build code.

     *      See if previous warning has been overridden.

     C                   if        warningtype ='*WARNOVR' and $slblde = 'W'

     C                   if        $slbldu and $slbld = ' '
     C                   eval      error = *on
500oDC*                  eval      $slblde = '2'
500oMC                   eval      $slblde = '1'
     C                   eval      $preturn = 'WARNBLD'
     C                   eval      $pmessage = 'Warning: Build code is '
     C                                       + 'blank'
     C                   goto      endwarn
     C                   endif

     C                   endif

     C                   leave
     C                   enddo

     C     endwarn       endsr

416nA*----------------------------------------------------------------
416nA*  writeadj    Write itemadj and adj label record(s).
416nA*              Original code taken from qtyadjust routine.
416nA*----------------------------------------------------------------
416nA
416nAC     writeadj      begsr

     *  Open ItemAdj and Label files.

     C                   exsr      openitemadj
     C                   if        error
     C                   goto      endwriteadj
     C                   endif

     C                   exsr      openlabel
     C                   if        error
     C                   goto      endwriteadj
     C                   endif

     *  Calculate unit weight for lowest uom.

     C                   eval      lowunitwgt = 0
416mMC                   if        $sacwta <> 0 and lowiaqty <> 0
     C                   eval      lowunitwgt = $sacwta / lowiaqty
     C                   endif
416aA
416aA*  If adjustment code is marked for only updating the host ...
416aA*    then just write label record(s).
416aA
416aAC                   if        $vsys = 'H'
416aAC                   goto      writelabel
416aAC                   endif

     *  Create adjustment record(s) ...

     C                   clear                   iarec
     C                   eval      iawhse = $slwhse
     C                   eval      iaitem = $saitem
     C                   eval      iawhdp = $slwhdp
     C                   eval      iadisp = $sldisp
740cAC                   select
740aDC*                  if        client = CoastalSunbelt
740aMC                   when      client = CoastalSunbelt
CSPaAC                             and $sacode = 'CI'
CSPaAC                   eval      iacode = '10'
HPCaAC                   when      client = holtpaper
HPCaAC                             and $sacode = 'CI'
HPCaAC                   eval      iacode = '8 '
740cDC*                  else
740cAC                   other
     C                   eval      iacode = $sacode
740aDC*                  endif
740aMC                   endsl
     C                   eval      iamemo = $samemo
     C                   eval      iaby   = $saby
     C                   eval      iadate = curdate
     C                   eval      iatime = curtime
510cAC                   eval      $sadate = curdate
510cAC                   eval      $satime = curtime

EFCaA*    Add slot status to end of memo for some clients.
EFCaA
EFCaAC                   if        client = eastland
EFCaAC                   eval      %subst(iamemo:28:3) = '-' + slstat
EFCaAC                   endif

     C                   select

     *    When only catch weight sent ...

     C                   when      $sacwta <> 0 and
     C                             $saqty1 = 0  and
     C                             $saqty2 = 0  and
     C                             $saqty3 = 0

     C                   eval      iacwta = $sacwta

700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *off
700 AC                   exsr      writeLicAdj

     C                   write     iarec
     C                   if        %error
     C                   endif

     *    When SSB item exists ...

     C                   when      ssbflag = *on

     C                   eval      remaincw = $sacwta

     *      Write adjustment record for base item.

     C                   if        $saqty1 <> 0

     C                   eval      iaqty1 = $saqty1
     C                   eval      iaqty2 = 0
     C                   eval      iaqty3 = 0
     C                   if        $saqty2 = 0 and $saqty3 = 0
     C                   eval      iacwta = $sacwta
     C                   else
     C                   eval      iacwta = ($saqty1 * #slotumq2 * #slotumq3)
     C                                    * lowunitwgt
     C                   eval      remaincw = $sacwta - iacwta
     C                   endif
700 A
700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *off
700 AC                   exsr      writeLicAdj
700 A
     C                   write     iarec
     C                   if        %error
     C                   endif

     C                   endif

     *      Write adjustment record for SSB item.

     C                   if        $saqty2 <> 0 or $saqty3 <> 0

417pAC                   eval      iaitem = #ssbitem
     C                   eval      iaqty1 = $saqty2
     C                   eval      iaqty2 = $saqty3
     C                   eval      iaqty3 = 0
     C                   eval      iacwta = remaincw
700 A
700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *off
700 AC                   exsr      writeLicAdj
700 A
     C                   write     iarec
     C                   if        %error
     C                   endif

     C                   endif

     *    When SSB item does not exist ...

     C                   other

     *      Write single adjustment record for item.

     C                   eval      iaqty1 = $saqty1
     C                   eval      iaqty2 = $saqty2
     C                   eval      iaqty3 = $saqty3
     C                   eval      iacwta = $sacwta
700 A
700 A*  Write LicAdj record.
700 AC                   eval      negLicAdj = *off
700 AC                   exsr      writeLicAdj
700 A
     C                   write     iarec
     C                   if        %error
     C                   endif

     C                   endsl

     *  Create label record(s).

416aAC     writelabel    tag

     C                   clear                   lbrec
     C                   eval      lbwhse = $slwhse
     C                   eval      lbitem = $saitem
     C                   eval      lbwhdp = $slwhdp
416aAC                   if        $vsys <> 'H'
     C                   eval      lbaisl = $slaisl
     C                   eval      lbloc  = $slloc
     C                   eval      lbrlvl = $slrlvl
     C                   eval      lbhand = $slhand
     C                   eval      lbpseq = $slpseq
     C                   eval      lbstyp = $slstyp
     C                   if        lbstyp = 'P'
     C                   eval      lbqryf = 1
     C                   else
     C                   eval      lbqryf = 0
     C                   endif
416aAC                   endif
     C                   eval      lbdisp = $sldisp
     C                   eval      lbstat = 'C'
     C                   eval      lbsdte = curdate
     C                   eval      lbstim = curtime
     C                   eval      lbrdte = curdate
     C                   eval      lbtype = 'A'

     C                   select

     *    Write single label when only weight was sent.

     C                   when      $sacwta <> 0 and
     C                             $saqty1=0 and $saqty2=0 and $saqty3=0

     C                   call      'PIRLBL#'
     C                   parm                    lblbl#
     C                   eval      lbutyp = 'N'
     C                   eval      lbucod = 'WT'
     C                   eval      lbswgt = $sacwta
     C                   write     lbrec
     C                   if        %error
     C                   endif

     *    Otherwise, write one label record for each quantity sent.
     *      Note: Not trying to compensate for catch weight rounding errors

     C                   other

     C                   if        $saqty1 <> 0
     C                   call      'PIRLBL#'
     C                   parm                    lblbl#
416aAC                   eval      lbqalc = $saqty1
416aAC                   if        $vsys <> 'H'
     C                   eval      lbqpck = $saqty1
416aAC                   endif
     C                   eval      lbutyp = 'N'
     C                   eval      lbucod = #slotum1
     C                   if        $saqty2 = 0 and $saqty3 = 0
     C                   eval      lbswgt = $sacwta
     C                   else
     C                   eval      lbswgt = ($saqty1 * #slotumq2 * #slotumq3)
     C                                    * lowunitwgt
     C                   endif
     C                   write     lbrec
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        $saqty2 <> 0
     C                   call      'PIRLBL#'
     C                   parm                    lblbl#
416aAC                   eval      lbqalc = $saqty2
416aAC                   if        $vsys <> 'H'
     C                   eval      lbqpck = $saqty2
416aAC                   endif
     C                   eval      lbutyp = '1'
     C                   eval      lbucod = #slotum2
     C                   eval      lbswgt = $saqty2 * lowunitwgt
     C                   if        $saqty1 = 0 and $saqty3 = 0
     C                   eval      lbswgt = $sacwta
     C                   else
     C                   eval      lbswgt = ($saqty2 * #slotumq3)
     C                                    * lowunitwgt
     C                   endif
     C                   write     lbrec
     C                   if        %error
     C                   endif
     C                   endif

     C                   if        $saqty3 <> 0
     C                   call      'PIRLBL#'
     C                   parm                    lblbl#
416aAC                   eval      lbqalc = $saqty3
416aAC                   if        $vsys <> 'H'
     C                   eval      lbqpck = $saqty3
416aAC                   endif
     C                   eval      lbutyp = '2'
     C                   eval      lbucod = #slotum3
     C                   if        $saqty1 = 0 and $saqty2 = 0
     C                   eval      lbswgt = $sacwta
     C                   else
     C                   eval      lbswgt = $saqty3 * lowunitwgt
     C                   endif
     C                   write     lbrec
     C                   if        %error
     C                   endif
     C                   endif

     C                   endsl

     C     endwriteadj   endsr

700 A*----------------------------------------------------------------
700 A*  writeLicAdj  Write LICADJ record
700 A*----------------------------------------------------------------
700 A
700 AC     writeLicAdj   begsr
700 A
700 A*  Get *ADJUST OPTIONS flag for LICADJ file
700 A /free
700 A   monitor;
700 A     GetOptions(%editc($slwhse:'X'): '*ADJUST': '002': '001': getoptval);
700 A     if getoptval = 'Y';
700 A       useLicAdj = *on;
700 A     else;
700 A       useLicAdj = *off;
700 A     endif;
700 A   on-error;
700 A     useLicAdj = *off;
700 A   endmon;
700 A
700 A   // If option not on, do nothing.
700 A   if useLicAdj = *off;
700 A     leavesr;
700 A   endif;
700 A
700 A   // If file not open, open it.
700 A   if not %open(licadj);
700 A     open LicAdj;
700 A   endif;
700 A
700 A   // Get unique adjustment record id.
700 A   GetRecId($slwhse: 'LICADJ': recidnum);
700 A   // For certain actions, make sure parent number is blank.
700 A   if $psubcmd = '*TFR2USR'
700 A    or $psubcmd = '*TFR2USR';
700 A     holdadjnum = *blank;
700 A   endif;
700 A
700 A   // Get transfer adj code default if none provided.
700 A   if $sacode = *blank;
700 A     GetOptions(%editc($slwhse:'X'): '*ADJUST': '003': '002': getoptval);
700 A     $sacode = getoptval;
700 A   endif;
700 A
FPRhA   // If function is *ADJUSTORD, clear out held adjustment # and slot.
FPRhA   if $psubcmd = '*ADJUSTORD'
FPRhA    or $psubcmd = '*ADJUST'
710bA    or $psubcmd = '*ADJUSTIMP';
FPRhA     holdadjnum = *blanks;
FPRhA     holdprvslt = *blanks;
FPRhA   endif;
700 A
700 A   // For FoodPro, force adjustment on warehouse transfers
700 A   forceadjcod = *off;
700 A   if client = Foodpro
700 A    and holdadjnum <> *blanks
700 A    and holdprvslt <> *blanks
FPRhA    and $psubcmd <> '*ADJUSTORD';
700 A     select;
700 A       when %subst(holdprvslt:1:3) <> 'WHS'
700 A        and %subst(sldisp:1:3) <> 'WHS';
700 A         // not whs transfer, continue
700 A       when %subst(holdprvslt:1:3) <> 'WHS'
FPRcM        and %subst(sldisp:1:3) = 'WHS'
FPRcA        and %subst(sldisp:4:1) <> '3';
700 A         $sacode = '1' + %subst(sldisp:4:1);
700 A         forceadjcod = *on;
700 A       when %subst(holdprvslt:1:3) = 'WHS'
FPRcM        and %subst(sldisp:1:3) <> 'WHS'
FPRcA        and %subst(holdprvslt:4:1) <> '3';
700 A         $sacode = %subst(holdprvslt:4:1) + '1';
700 A         forceadjcod = *on;
700 A       when %subst(holdprvslt:1:3) = 'WHS'
FPRcM        and %subst(sldisp:1:3) = 'WHS'
FPRcA        and %subst(sldisp:4:1) <> '3'
FPRcA        and %subst(holdprvslt:4:1) <> '3';
700 A         $sacode = %subst(holdprvslt:4:1) + %subst(sldisp:4:1);
700 A         forceadjcod = *on;
700 A     endsl;
700 A   endif;
700 A
700 A   // Get adjustment code description/system.
700 A   GetAdjCode($sacode: gaDesc: gaSys);
700 A
SBRaA   // For S.Bertram, if prev or current slot is OSS, force both.
SBRaA   if client = SBertram;
SBRaA    if (%subst(holdprvslt:1:3) = 'OSS'
SBRaA     or %subst(sldisp:1:3) = 'OSS')
SBRaA     and $sacode = 'TF';
SBRaA      gaSys = 'B';
SBRaA    endif;
SBRaA   endif;
SBRaA
SBRaA   // If S.Bertram transfer and item changed, change parent
SBRaA   //  to CI and set current to CI.
700rD   //if client = SBertram
700rM   if $pprogram <> 'RC200'
700eA    and statChgOnly = *off
SBRaA    and holdadjnum <> *blanks
SBRaA    and holdprvitm <> $saitem;
SBRaA       $sacode = 'CI';
SBRaA       gaSys = 'B';
FPRoA   if client = FoodPRO
FPRoA       and holdprvdpt <> slwhdp;
FPRoA       $sacode = 'FM';
FPRoA       gaSys = 'B';
FPRoA   endif;
SBRaA   endif;
700 A   adjwhs = slwhse;
700 A   adjnbr = %char(recidnum);
700 A   adjparent = holdadjnum;
700 A   holdadjnum = adjnbr;
700 A   holdprvslt = sldisp;
700 A   adjcode = $sacode;
700 A   adjcsys = gaSys;
700 A   select;
700 A    when $psubcmd = '*CHANGE';
700 A     adjitem = slitem;
700 A    other;
700 A     adjitem = $saitem;
700 A   endsl;
700 A   if negLicAdj = *on;
700 A     adjaqty1 = $saqty1 * -1;
700 A     adjaqty2 = $saqty2 * -1;
700 A     adjaqty3 = $saqty3 * -1;
700 A     adjcqta = $sacwta * -1;
700 A   else;
700 A     adjaqty1 = $saqty1;
700 A     adjaqty2 = $saqty2;
700 A     adjaqty3 = $saqty3;
700 A     adjcqta = $sacwta;
700 A   endif;
750eA   if statChgOnly;
750eA     if negLicAdj = *on;
750eA       adjaqty1 = statChgOnlyQ1 * -1;
750eA       adjaqty2 = statChgOnlyQ2 * -1;
750eA       adjaqty3 = statChgOnlyQ3 * -1;
750eA       adjcqta = 0;
750eA     else;
750eA       adjaqty1 = statChgOnlyQ1;
750eA       adjaqty2 = statChgOnlyQ2;
750eA       adjaqty3 = statChgOnlyQ3;
750eA       adjcqta = 0;
750eA     endif;
750eA   endif;
700 A   adjwhdp = slwhdp;
700 A   adjdisp = sldisp;
700 A   adjaisl = slaisl;
700 A   adjloc = slloc;
700 A   adjrlvl = slrlvl;
700 A   adjhand = slhand;
700 A   select;
700 A    when $psubcmd = '*USR2RCV'
720 A      or $psubcmd = '*USR2RPA'
700sA      or $psubcmd = '*USR2RTNO'
730eA      or $psubcmd = '*USR2RWO'
700 A      or $psubcmd = '*TFR2USR'
700 A      or $psubcmd = '*TFR2USRR';
700 A     adjstat = frmSLREC.slstat;
700 A    other;
700 A     adjstat = slstat;
700 A   endsl;
700 A   if $samemo = *blank;
700 A     adjmemo = gaDesc;
700 A   else;
700 A     adjmemo = $samemo;
700 A   endif;
DRYbA   if client = Dairyland;
DRYbA   // Store Before Slot Status code.
DRYbA     adjmemo = %replace(%subst($slotbefore:53:2):
DRYbA                               adjmemo:29:2);
DRYbA   endif;
700 A   //ADJLLTRN =
700 A   //ADJLLTRSQ =
700nA   select;
700nA   when $psubcmd = '*ADJUST'
710bA     or $psubcmd = '*ADJUSTIMP'
710dA     or $psubcmd = '*USR2PUT';
700nA     adjlcns = $litolcns;
700nA   when $psubcmd = '*TFR2USR'
700nA    and $pprogram = 'RC200';
700nA     adjlcns = $satolcns;
700nA   when $psubcmd = '*TFR2USR'
700nA    and $pprogram <> 'RC200';
700nA     adjlcns = $litolcns;
710iA   when $psubcmd = '*TFR2USRR'
710iA    and $pprogram <> 'RC200';
710iA     adjlcns = $liolcns;
700nA   other;
700nM     adjlcns = $safrmlcns;
700nA   endsl;
700 A   adjaddts = %timestamp();
700 A   adjadduc = %timestamp();
700 A   adjaddcpgm = $pprogram;
700 A   adjaddjpgm = #pgm;
700 A   adjaddemp = *zero;
700 A   adjaddcusr = #curruser;
700 A   adjaddjusr = #user;
700 A   adjaddjob = #job;
700 A   adjaddnbr = #jobnbr;
700 A   adjexpflag = *blank;
700 A   //ADJEXPTS
700 A   //ADJEXPUC
700 A   //ADJEXPJUSR
700 A   //ADJEXPJOB
700 A   //ADJEXPNBR
700 A   adjdrislot = $psubcmd;
700 A   adjdrilic = *blanks;
700 A
FPReA   // If slot is QU status, force update to host.
FPRlA   if client = FoodPro;
FPReA   if adjstat = 'QU';
FPReA     adjcsys = 'B';
FPReA   endif;
FPRlA   endif;
700 A
700 A   write adjrec;
700 A
FPRdA   holdprvadj = adjparent;
FPRdA   // if putaway and catchweight entered, update parent record
FPRdA   if $psubcmd = '*USR2PUT'
FPRdA    and $sacwta <> 0
FPRdA    and adjparent <> *blanks;
FPRdA     chain (adjwhs: holdprvadj) licadj;
FPRdA     if %found(licadj);
FPRdA       adjcqta = $sacwta * -1;
FPRdA       adjexpflag = ' '; // in case export ran already
FPRdA       update adjrec;
FPRdA     endif;
FPRdA   endif;
FPRdA
700 A   // if adjustment code changed, update parent record
700 A   if forceadjcod;
700 A     chain (adjwhs: holdprvadj) licadj;
700 A     if %found(licadj);
700 A       adjcode = $sacode;
700 A       adjcsys = gaSys;
700 A       adjexpflag = ' '; // in case export ran already
700 A       update adjrec;
700 A     endif;
700 A     forceadjcod = *off;
700 A   endif;
700 A
SBRaA   // if S.Bertram and OSS slot, update parent record
SBRaA   if client = SBertram
SBRaA    and %subst(sldisp:1:3) = 'OSS'
SBRaA    and holdprvadj <> *blanks;
SBRaA     chain (adjwhs: holdprvadj) licadj;
SBRaA     if %found(licadj);
SBRaA       if adjcsys <> 'B';
SBRaA         adjexpflag = ' '; // in case export ran already
SBRaA       endif;
SBRaA       adjcsys = 'B';
SBRaA       update adjrec;
SBRaA     endif;
SBRaA   endif;
SBRaA
SBRaA   // If S.Bertram transfer and item changed, change parent
SBRaA   //  to CI and set current to CI.
700rD   //if client = SBertram
700rM   if $pprogram <> 'RC200'
750eA    and statChgOnly = *off
SBRaA    and holdprvadj <> *blanks
SBRaA    and holdprvitm <> adjitem;
SBRaA     chain (adjwhs: holdprvadj) licadj;
SBRaA     if %found(licadj);
SBRaA       if adjcsys <> 'B';
SBRaA         adjexpflag = ' '; // in case export ran already
SBRaA       endif;
SBRaA       adjcode = 'CI';
SBRaA       adjcsys = 'B';
FPRoA   if client = FoodPRO
FPRoA       and holdprvdpt <> slwhdp;
FPRoA       adjcode = 'FM';
FPRoA       adjcsys = 'B';
FPRoA   endif;
SBRaA       update adjrec;
SBRaA     endif;
SBRaA   endif;
SBRaA   holdprvitm = adjitem;
FPRoA   holdprvdpt = adjwhdp;
700aA
700 A   endsr;  // writelicadj
700 A /end-free
700 A
     *----------------------------------------------------------------
     *  writelog    Write record to log file
     *----------------------------------------------------------------

     C     writelog      begsr
600gA
600gA* Don't believe this log is being used, so decided not to write
600gA* to it unless it proves to be necessary.
600gA
600gAC                   leavesr

     * Get next sequence number to use.

     C     *dtaara       define    logslot#      nextseq#
     C     *lock         in        nextseq#
     C                   eval      lgslotseq# = nextseq#
     C                   if        nextseq# = 9999999
     C                   eval      nextseq# = 1
     C                   else
     C                   eval      nextseq# = nextseq# + 1
     C                   endif

     * Initialize log fields.

     C                   exsr      getdatetime

     C                   eval      lgslotdate = curdate
     C                   eval      lgslottime = curtime
     C                   eval      lgslotscmd = $psubcmd
     C                   eval      lgslotpgm  = $pprogram

     * Write log record.

     C                   select

     *   Single record if virtual slot was created.

     C                   when      vslotcreated
     C                   eval      lgslottype = 'PT'
     C                   eval      lgslotrtn  = $preturn
     C                   eval      lgslotmsg  = $pmessage
     C                   eval      lgslotdata = $slot
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif

     *   Single record if update was done by calling program.

     C                   when      not UpdateDakota
     C                   eval      lgslottype = 'NU'
     C                   eval      lgslotrtn  = $preturninput
     C                   eval      lgslotmsg  = $pmessageinput
600fDC**                 eval      lgslotdata = $slotinput
600fMC                   eval      lgslotdata = in$slot
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif

     *   Single record if error occured during update.

     C                   when      error
     C                   eval      lgslottype = 'ER'
     C                   eval      lgslotrtn  = $preturn
     C                   eval      lgslotmsg  = $pmessage
     C                   eval      lgslotdata = $slot
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif

     *   Single record for *ADD or *CRTXDOCK.

     C                   when      $psubcmd = '*ADD' or
416jAC                             $psubcmd = '*CRTXDOCK'
     C                   eval      lgslottype = 'PT'
     C                   eval      lgslotrtn  = $preturn
     C                   eval      lgslotmsg  = $pmessage
     C                   eval      lgslotdata = $slot
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif

     *   Single record for *DELETE.

     C                   when      $psubcmd = '*DELETE'  or
     C                             $psubcmd = '*DELETEI'
700aAC                             or $psubcmd = '*DELETEWEB'
     C                   eval      lgslottype = 'DL'
     C                   eval      lgslotrtn  = $preturn
     C                   eval      lgslotmsg  = $pmessage
     C                   eval      lgslotdata = $slot
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif

     *   Before/After records for everything else.

     C                   other
     C                   eval      lgslottype = 'UB'
     C                   eval      lgslotrtn  = $preturninput
     C                   eval      lgslotmsg  = $pmessageinput
     C                   eval      lgslotdata = $slotbefore
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif
     C                   eval      lgslotseq# = nextseq#
     C                   if        nextseq# = 9999999
     C                   eval      nextseq# = 1
     C                   else
     C                   eval      nextseq# = nextseq# + 1
     C                   endif
     C                   eval      lgslottype = 'UP'
     C                   eval      lgslotrtn  = $preturn
     C                   eval      lgslotmsg  = $pmessage
     C                   eval      lgslotdata = $slot
     C                   write(e)  lgslotrec
     C                   if        %error
     C                   endif

     C                   endsl

     * Update sequence number to use.

     C                   out       nextseq#

     C     endwritelog   endsr

417cA*----------------------------------------------------------------
417cA*  zerovfy    Zero verify slot
417cA*----------------------------------------------------------------
417cA
417cAC     zerovfy       begsr
600tAC                   eval      currRoutine = 'zerovfy'
600tAC                   exsr      phpgmV1V2V3s
ADWa *    Do not zero verify slots for ANDREWS
ADWa C                   if        client = andrews
ADWa C                   goto      endzerovfy
ADWa C                   endif
     C                   eval      error = *off
611fA
611fA*  Slot cannot be in WORKUSR file.
611fA
611fAC                   eval      kywhse = $slwhse
611fAC     keywu1        setll     workusr1
611fAC                   dow       forever = forever
611fAC     keywu1        reade     workusr1
611fAC                   if        %eof(workusr1)
611fAC                   leave
611fAC                   endif
611fAC                   if        (wupckwhdp=$slwhdp and wupckdisp=$sldisp)
611fAC                             or (wupulwhdp=$slwhdp and wupuldisp=$sldisp)
611fAC                   eval      error = *on
611fAC                   eval      $preturn = 'INWORKUSR'
611fAC                   exsr      getmsg
611fAC                   leavesr
611fAC                   endif
611fAC                   enddo

     *  Get and lock slot.

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2

     C                   if        error
     C                   goto      endzerovfy
     C                   endif

     *  If slot is not at 'Z' status, then send back an error.

     C                   if        slstat <> 'Z' and slstat <> 'V'
     C                   eval      error = *on
     C                   eval      $preturn = 'NOTZROSTAT'
     C                   exsr      getmsg
     C                   goto      endzerovfy
     C                   endif

     *  Delete special order record(s).

     C                   exsr      deletespclord

     *  Delete Printed exception record(s).

     C                   exsr      deletevslexcp
650qA
     *  Delete Store Staging Slots

650qAc*                  if        slaisl='RPA'
650qAc*                  exsr      deleteslot
     c*                  endif
650qA
650qA*  Production Module slots will be deleted once Zero Verified
650qA
650qA /free
650qA                    if %lookup(slaisl:prdslt:1) > 0;
720eA        // do not delete Production base slots
720eA                    if slstat='Z' and slhand=' ' and slrsrv<>'V';
720eA                       slstat='PR';
720eA                       update slrec2;
720eA /end-free
720eAC                   goto      endzerovfy
720eA /free
720eA                    else;
650qA                       exsr deleteslot;
720eA                    endif;
650qA        // delete cross reference for customer order stock
650qA                    setll (kywhse:kydisp) pcslot1;
650qA                    reade (kywhse:kydisp) pcslot1;
650qA                    dow forever = forever;
650qA                       if %eof(pcslot1) or not %found(pcslot1);
650qA                          leave;
650qA                       endif;
650qA                       delete csrec;
650qA                       reade (kywhse:kydisp) pcslot1;
650qA                    enddo;
650qA                    setll (*loval) pcslot1;
650qA /end-free
650qAC                   goto      endzerovfy
650qAc                   endif

     *  Change status code for ...

 2B  C                   select

     *    Crossdock and Virtual slots - Delete record and skip to end.

 2X  C                   when      slstyp = 'X' or
 2X  C                             slrsrv = 'V'
     C                   exsr      deleteslot
goto C                   goto      endzerovfy

     *    Verified slot - Just unlock record.

 2X  C                   when      slstat <> 'Z'
     C                   unlock    slot2

     *    Zero slot - Delete associated records and Verify slot.

 2X  C                   other
     C                   exsr      deletespclord
     C                   exsr      deletevslexcp
     C                   exsr      set2vfy

 2E  C                   endsl

     *  See if we should delete corresponding Zero virtual slots.

     C                   eval      kywhse = *zeros
     C                   eval      opcode = '*ZEROVFY'
     C     keyop         chain     options
 1B  C                   if        not %found
     C                   eval      opvfyv = 'N'
     C                   else
     C                   eval      opdat3 = opdata
 1E  C                   endif
611g  *  Reset kywhse key, changed to 0 to get options.
611gAC                   eval      kywhse = $slwhse

     *  User has chosen to verify virtuals individually, so skip to end.

 2B  C     opvfyv        cabeq     'Y'           endzerovfy

     *  Open virtual slot file.

     C                   exsr      openvslot2
     C                   if        error
     C                   goto      endzerovfy
     C                   endif

     *  Loop through virtuals for slot, delete if status 'Z'

     C     keysl2        setll     vslot2
 3B  C                   dow       forever = forever
     C     keysl2        reade     vslot2
 4B  C                   if        %eof
 3L  C                   leave
 4E  C                   endif

     C     keysl2vs      chain     slot2
 5B  C                   if        %found and slstat = 'Z'
     C                   exsr      deleteslot
     C*****              delete    slrec2
     C*****              delete    vsrec2
 5E  C                   endif

 3E  C                   enddo

     C     endzerovfy    endsr

610wA*----------------------------------------------------------------
610wA*  zzsetstat    Set status
610wA*----------------------------------------------------------------
    A
    AC     zzsetstat     begsr
    AC                   eval      currRoutine = 'setstat'
    AC                   exsr      phpgmV1V2V3s
     *
     C                   eval      error = *off

     *  Get and lock slot.

     C                   eval      lock = *on
     C                   eval      kywhse = $slwhse
     C                   eval      kywhdp = $slwhdp
     C                   eval      kydisp = $sldisp
     C                   eval      check4err = *on
     C                   exsr      getslot2

     C                   if        error
     C                   goto      endsetstat
     C                   endif

     *  If slot is not at zero qty, then send back an error.

     C                   if        slstk1 <> 0 or
     C                             slstk2 <> 0 or
     C                             slstk3 <> 0
     C                   eval      error = *on
     C                   eval      $preturn = 'NOTZROSTAT'
     C                   exsr      getmsg
     C                   goto      endsetstat
     C                   endif

     C                   exsr      setstatus

     C                   update(e) slrec2
     C                   if        %error
     C                   eval      error = *on
     C                   eval      $preturn = 'UPDERRSLT2'
     C                   exsr      getmsg
     C                   endif

     C     endsetstat    endsr

CWD A*----------------------------------------------------------------
CWD A*  zzvpckchkcwd    Check if Virtual Pick Slot Allowed.
CWD A*----------------------------------------------------------------
CWD A
CWD AC     zzvpckchkcwd  begsr
CWD AC                   eval      skipvpckchk = '0'
CWD A*
CWD AC                   select
CWD A*-------------------------------------------
CWD AC                   when      $slwhdp = 'CHM'
CWD A*
CWD AC                   select
CWD AC                   when          $slaisl = ' 10'
CWD AC                             and $slloc  = 027
CWD AC                             and $slrlvl = 3
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'HZ'
CWD AC                   eval      skipvpckchk = '1'
CWD A*
CWD AC                   endsl
CWD A*
CWD A*-------------------------------------------
CWD DC                   when      $slwhdp = 'CLR'
CWD A*
CWD AC                   select
CWD AC                   when          $slaisl = ' 39'
CWD AC                             and $slloc  >= 004
CWD AC                             and $slloc  <= 006
CWD AC                             and $slrlvl >= 1
CWD AC                             and $slrlvl <= 3
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'GZ'
CWD A*
CWD AC                             or  $slaisl = ' 42'
CWD AC                             and $slloc  = 045
CWD AC                             and $slrlvl >= 2
CWD AC                             and $slrlvl <= 3
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'FZ'
CWD A*
CWD AC                   eval      skipvpckchk = '1'
CWD A*
CWD AC                   endsl
CWD A*
CWD A*-------------------------------------------
CWD AC                   when      $slwhdp = 'DRY'
CWD A*
CWD AC                   select
CWD AC                   when          $slaisl = ' 17'
CWD AC                             and $slloc  = 226
CWD AC                             and $slrlvl >= 1
CWD AC                             and $slrlvl <= 5
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'HZ'
CWD A*
CWD AC                             or  $slaisl = ' 16'
CWD AC                             and $slloc  = 175
CWD AC                             and $slrlvl >= 1
CWD AC                             and $slrlvl <= 6
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'KZ'
CWD A*
CWD AC                             or  $slaisl = ' 16'
CWD AC                             and $slloc  = 177
CWD AC                             and $slrlvl >= 1
CWD AC                             and $slrlvl <= 5
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'KZ'
CWD A*
CWD AC                             or  $slaisl = ' 16'
CWD AC                             and $slloc  = 176
CWD AC                             and $slrlvl >= 1
CWD AC                             and $slrlvl <= 6
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'FZ'
CWD A*
CWD AC                   eval      skipvpckchk = '1'
CWD A*
CWD AC                   endsl
CWD A*
CWD A*-------------------------------------------
CWD AC                   when      $slwhdp = 'FRZ'
CWD A*
CWD AC                   select
CWD AC                   when          $slaisl = ' 65'
CWD AC                             and $slloc  = 003
CWD AC                             and $slrlvl >= 1
CWD AC                             and $slrlvl <= 7
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'KZ'
CWD A*
CWD AC                             or  $slaisl = ' 65'
CWD AC                             and $slloc  = 001
CWD AC                             and $slrlvl >= 4
CWD AC                             and $slrlvl <= 4
CWD AC                             and $slhand >= ' A'
CWD AC                             and $slhand <= 'KZ'
CWD A*
CWD AC                   eval      skipvpckchk = '1'
CWD A*
CWD AC                   endsl
CWD A*
CWD AC                   endsl
CWD A
CWD AC     endvpckchkcwd endsr

CWDaA*----------------------------------------------------------------
CWDaA*  zzvpckchkcwd3   Check if Virtual Pick Slot Allowed - Kearney
CWDaA*----------------------------------------------------------------
CWDaA
CWDaAC     zzvpckchkcwd3 begsr
CWDaAC                   eval      skipvpckchk = '0'
CWDaA*
CWDaAC                   select
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'AFFD'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'AFFR'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'CHM'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaDC                   when      $slwhdp = 'CLR'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaDC                   when      $slwhdp = 'CND'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'CST'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'DRY'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'FRZ'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'NEW'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaA*-------------------------------------------
CWDaAC                   when      $slwhdp = 'TOB'
CWDaA*
CWDaAC                   select
CWDaAC                   when          slaisl = ' AF'
CWDaAC                              or slaisl = ' PR'
CWDaAC                   eval      skipvpckchk = '1'
CWDaA*
CWDaAC                   endsl
CWDaA*
CWDaAC                   endsl
CWDaA
CWDaAC     endvpckchkcwd3endsr

600dA*----------------------------------------------------------------
600dA*----------------------------------------------------------------
600dA*                     DRI SUBROUTINES
600dA*----------------------------------------------------------------
600dA*----------------------------------------------------------------

     *----------------------------------------------------------------
     *  clr$dept  Clear $dept data structure fields
     *----------------------------------------------------------------

     C     clr$dept      begsr
     C                   eval      savever# = $wdver#
     C                   clear                   $dept
     C                   eval      $wdver# = savever#
     C                   endsr

     *----------------------------------------------------------------
     *  clr$desig  Clear $desig data structure fields
     *----------------------------------------------------------------

     C     clr$desig     begsr
     C                   eval      savever# = $dsver#
     C                   clear                   $desig
     C                   eval      $dsver# = savever#
     C                   endsr

     *----------------------------------------------------------------
     *  clr$item  Clear $item data structure fields
     *----------------------------------------------------------------

     C     clr$item      begsr
     C                   eval      savever# = $itver#
     C                   clear                   $item
     C                   clear                   $item2
     C                   eval      $itver# = savever#
     C                   endsr

     *----------------------------------------------------------------
     *  clr$itemqty  Clear $itemqty data structure fields
     *----------------------------------------------------------------

     C     clr$itemqty   begsr
     C                   eval      savever# = $iqver#
     C                   clear                   $itemqty
     C                   eval      $iqver# = savever#
     C                   endsr

     *----------------------------------------------------------------
     *  clr$license  Clear $license data structure fields
     *----------------------------------------------------------------

     C     clr$license   begsr
     C                   eval      savever# = $liver#
     C                   clear                   $license
     C                   clear                   $license2
710gAC                   clear                   $license3
     C                   eval      $liver# = savever#
     C                   eval      $liuser = #curruser
610oDC*                  eval      $lipgm  = #pgm
610oMC                   eval      $lipgm  = $pprogram
     C                   eval      $lijob  = #job
     C                   eval      $lijobn = #jobnbr
600dAC                   if        $saemp#U
     C                   eval      $liemp# = $saemp#
730hA /free
730hA       $emp# = $saemp#;
730hA       getempl($emp#: $whse: $code: $fnam: $init: $lnam: $whdp:
730hA         $styp: $shft: $crew: $nhrs: $rtn: $bpu: $lng:
730hA         $email: $pics);
730hA       if $rtn = '*ERROR';
730hA       else;
730hA         $liuser = $code;
730hA       endif;
730hA /end-free
600dAC                   endif
     C                   endsr

640sA*----------------------------------------------------------------
640sA*  clr$license  Clear $license data structure fields
640sA*----------------------------------------------------------------
640sA
640sAC     clr$licinfo   begsr
     C                   eval      savever# = $lnver#
     C                   clear                   $licinfo
     C                   clear                   $licinfo2
     C                   eval      $lnver# = savever#
     C                   eval      $lnuser = #curruser
     C                   eval      $lnpgm  = $pprogram
     C                   eval      $lnjob  = #job
     C                   eval      $lnjobnbr = #jobnbr
     C                   endsr

     *----------------------------------------------------------------
     *  clr$prtyrpl  Clear $prtyrpl data structure fields
     *----------------------------------------------------------------

     C     clr$prtyrpl   begsr
     C                   eval      savever# = $prver#
     C                   clear                   $prtyrpl
     C                   eval      $prver# = savever#
     C                   endsr

     *----------------------------------------------------------------
     *  clr$slotdef  Clear $slotdef data structure fields
     *----------------------------------------------------------------

     C     clr$slotdef   begsr
     C                   eval      savever# = $sdver#
     C                   clear                   $slotdef
     C                   eval      $sdver# = savever#
     C                   endsr

GFC A*----------------------------------------------------------------
GFC A*  zeroLicExpd    Zero license expiration date

GFC AC     zeroLicExpd   begsr
GFC A
GFC AC                   eval      currRoutine = 'zeroLicExp'
GFC AC                   exsr      phpgmV1V2V3s
GFC AC                   eval      error = *off

GFC AC                   exsr      clr$license

GFC AC                   eval      $liToWhseu = *on
GFC AC                   eval      $liToWhse = slwhse
GFC AC                   eval      $liToSItemU = *on
GFC AC                   eval      $liToSItem = slitem

GFC AC                   eval      $dricommand = 'DRILICENSE'
GFC AC                   eval      $drisubcmd  = '%ZEROEXPD '
GFC AC                   eval      $drisys2upd = 'D'
GFC AC                   exsr      zzzdrimain3

GFC AC                   endsr

GFC A*----------------------------------------------------------------
GFC A*  zeroSlotExpd   Zero slot expiration date
GFC A*----------------------------------------------------------------

GFC AC     zeroSlotExpd  begsr
GFC A
GFC AC                   if        not %open(slot3)
GFC AC                   open      slot3
GFC AC                   endif

GFC AC     keysl3p3      setll     slot3
GFC AC                   dow       forever = forever
GFC AC     keysl3p3      reade     slot3
GFC AC                   if        %eof(slot3)
GFC AC                   leave
GFC AC                   endif

GFC AC                   eval      slexpd = 0
GFC AC                   update    slrec3

GFC AC                   enddo

GFC AC                   endsr

     *----------------------------------------------------------------
     *  zzzdrimain3  Call DRIMAIN3
     *----------------------------------------------------------------

     C     zzzdrimain3   begsr
     C                   eval      main3err = *off
     C                   eval      main3callerr = *off
     C                   eval      main3rtnerr = *off

     C                   select
     C                   when      $dricommand = 'DRIDEPT'
     C                   eval      dridept = *on
     C                   eval      $dridata = $dept
     C                   when      $dricommand = 'DRIDESIG'
     C                   eval      dridesig = *on
     C                   eval      $dridata = $desig
     C                   when      $dricommand = 'DRIITEM'
     C                   eval      driitem = *on
     C                   eval      $dridata = $item
     C                   eval      $dridata2 = $item2
     C                   when      $dricommand = 'DRIITEMQTY'
     C                   eval      driitemqty = *on
     C                   eval      $dridata = $itemqty
     C                   when      $dricommand = 'DRILICENSE'
     C                   eval      drilicense = *on
     C                   eval      $dridata = $license
     C                   eval      $dridata2 = $license2
710gAC                   eval      $dridata3 = $license3
     C                   when      $dricommand = 'DRILICINFO'
     C                   eval      drilicinfo = *on
     C                   eval      $dridata = $licinfo
640vAC                   eval      $dridata2= $licinfo2
     C                   when      $dricommand = 'DRIPRTYRPL'
     C                   eval      driprtyrpl = *on
     C                   eval      $dridata = $prtyrpl
     C                   when      $dricommand = 'DRISLOTDEF'
     C                   eval      drislotdef = *on
     C                   eval      $dridata = $slotdef
     C                   endsl

710gA * added $dridata3 for DRILICENSE
710gA * change this logic to select/when
710gAc                   select
710gMC                   when      $dricommand = 'DRIITEM'
710gDC*                  if        $dricommand = 'DRIITEM'
710gDC*                            or $dricommand = 'DRILICENSE'
640vAC                             or $dricommand = 'DRILICINFO'
     C                   call(e)   'DRIMAIN3'
     C                   parm                    $dricommand
     C                   parm                    $drisubcmd
     C                   parm                    $drisys2upd
601bDC**                 parm      #pgm          $driprogram
601bMC                   parm      $pprogram     $driprogram
     C                   parm      ' '           $drireturn
     C                   parm      ' '           $drimessage
     C                   parm                    $dridata
     C                   parm                    $dridata2
710gAC                   when      $dricommand = 'DRILICENSE'
710gAC                   call(e)   'DRIMAIN3'
710gAC                   parm                    $dricommand
710gAC                   parm                    $drisubcmd
710gAC                   parm                    $drisys2upd
710gAC                   parm      $pprogram     $driprogram
710gAC                   parm      ' '           $drireturn
710gAC                   parm      ' '           $drimessage
710gAC                   parm                    $dridata
710gAC                   parm                    $dridata2
710gAC                   parm                    $dridata3
710gDC*                  else
710gMC                   other
     C                   call(e)   'DRIMAIN3'
     C                   parm                    $dricommand
     C                   parm                    $drisubcmd
     C                   parm                    $drisys2upd
601bDC**                 parm      #pgm          $driprogram
601bMC                   parm      $pprogram     $driprogram
     C                   parm      ' '           $drireturn
     C                   parm      ' '           $drimessage
     C                   parm                    $dridata
710gDC*                  endif
710gMC                   endsl

     C                   select

     C                   when      %error
     C                   eval      main3err = *on
     C                   eval      main3callerr = *on
     C                   eval      $drireturn  = 'CALLERROR'
     C                   eval      $drimessage = 'Error occured on call to '
     C                                         + 'DRIMAIN3'
     C                                         + '/' + %trim($drisubcmd)
     C                                         + ' from ' + #pgm

     C                   when      $drireturn <> '*OK'
     C                   eval      main3err = *on
     C                   eval      main3rtnerr = *on

     C                   endsl

     C                   select
     C                   when      $dricommand = 'DRIDEPT'
     C                   eval      $dept = $dridata
     C                   when      $dricommand = 'DRIDESIG'
     C                   eval      $desig = $dridata
     C                   when      $dricommand = 'DRIITEM'
     C                   eval      $item = $dridata
     C                   eval      $item2 = $dridata2
     C                   when      $dricommand = 'DRIITEMQTY'
     C                   eval      $itemqty = $dridata
     C                   when      $dricommand = 'DRILICENSE'
     C                   eval      $license = $dridata
     C                   eval      $license2 = $dridata2
710gAC                   eval      $license3 = $dridata3
     C                   when      $dricommand = 'DRILICINFO'
     C                   eval      $licinfo = $dridata
640vAC                   eval      $licinfo2 = $dridata2
     C                   when      $dricommand = 'DRIPRTYRPL'
     C                   eval      $prtyrpl = $dridata
     C                   when      $dricommand = 'DRISLOTDEF'
     C                   eval      $slotdef = $dridata
     C                   endsl

     C     enddricop     endsr

GFC A*----------------------------------------------------------------
GFC A*  fileopenLA2  Open file licactive2
GFC A*----------------------------------------------------------------
GFC A
GFC A /free
GFC A  begsr fileopenLA2;

         if not %open(licactive2);
           open(e) licactive2;
           if %error;
             error = *on;
             $preturn  = 'OPNERRLA2';
             $pmessage = 'Error occured trying to '
                       + 'open file LICACTIVE2 in pgm '
                       + #prog;
           endif;
         endif;

       endsr;
      /end-free

600tA*----------------------------------------------------------------
600tA*----------------------------------------------------------------
600tA*  Phrase Routines
600tA*----------------------------------------------------------------
600tA*----------------------------------------------------------------

600tA*----------------------------------------------------------------
600tA*  phClearVars  - Clear phrase variables
600tA*----------------------------------------------------------------
600tA
      /free
       begsr phClearVars;

         v1 = ' ';
         v2 = ' ';
         v3 = ' ';
         v4 = ' ';
         v5 = ' ';

       endsr;
      /end-free

600tA*----------------------------------------------------------------
600tA*  phWrtPhrase  - Write logging phrase
600tA*----------------------------------------------------------------

      /free
       begsr phWrtPhrase;

         pWhse = $slwhse;
         if $saemp#u;
           pEmp# = $saemp#;
         endif;
         pUser = #curruser;
         pPgm  = #pgm;
         //pItem = lrTItm;
         //pWhdp = lrTWhd;
         //if lrTCod = 'S' or lrTCod='F';
         //  pLocation = lrTdsp;
         //else;
         //  pLocation = lrTAra;
         //endif;
         //pTrn# = lrTrn#;
         //pLcns = lrLcns;
         //pLtrn = lrLtrn;

      /end-free
     C                   call      'WRTPHRASE'
     c                   parm                    pPhraseId
     c                   parm                    pWhse
     c                   parm                    pEmp#
     c                   parm                    pUser
     c                   parm                    pPgm
     c                   parm                    pItem
     c                   parm                    pWhdp
     c                   parm                    pLocation
     c                   parm                    pTrn#
     c                   parm                    pLcns
     c                   parm                    pLtrn
     c                   parm                    v1
     c                   parm                    v2
     c                   parm                    v3
     c                   parm                    v4
     c                   parm                    v5
      /free


         if %error;
           eval error = error;
         endif;

       endsr;
      /end-free

600bA*----------------------------------------------------------------
600bA*  phPgmV1V2V3s
600bA*----------------------------------------------------------------
600bA
      /free
       begsr phPgmV1V2V3s;

         pPhraseId = pgmV1V2V3;

         exsr phClearVars;
         v1 = $psubcmd;
         v2 = currRoutine;
         v3 = 'Start';

         // exsr phWrtPhrase;

         psrpgm = #pgm;
         psrsubcmd = $psubcmd;
         psrsubrtn = currRoutine;
         psraddts = %timestamp();
         setll (psrpgm: psrsubcmd: psrsubrtn)
               pgmsubrtn;
         if not %equal(pgmsubrtn);
           write(e) psrrec;
         endif;

         //exsr pushRoutine;

       endsr;
      /end-free

600tA*----------------------------------------------------------------
600tA*  pushRoutine  -  Add routine to stack
600tA*----------------------------------------------------------------
600tA
      /free
       begsr pushRoutine;

         for i = stackCount downto 1;
           eval aRoutine(i+1) = aRoutine(i);
         endfor;

         aRoutine(1) = currRoutine;
         stackCount += 1;

       endsr;
      /end-free

600tA*----------------------------------------------------------------
600tA*  popRoutine  -  Remove routine from stack
600tA*----------------------------------------------------------------
600tA
      /free
       begsr popRoutine;

         for i = 1 to stackCount-1;
           eval aRoutine(i) = aRoutine(i+1);
         endfor;

         aRoutine(stackCount) = ' ';
         stackCount -= 1;
         currRoutine = aRoutine(1);

       endsr;
      /end-free

GFC A*----------------------------------------------------------------
GFC A*  UpdLicSlotExpd - FIFO Update license and slot expiration date
GFC A*----------------------------------------------------------------
GFC A
GFC A /free
GFC A  begsr UpdLicSlotExpd;

         kyWhse = $slwhse;
         kyItem = $slItem;

         // Open licactive2 file

         exsr fileOpenLA2;

         if error;
             leavesr;
         endif;

         setll (kywhse: kyitem) licactive2;
         dow forever = forever;
           reade (kywhse: kyitem) licactive2;

           if %eof(licactive2);
             leave;
           endif;

           datein = 0;

640sD      //setll (kywhse: lalcns) licinfo2;
640sD      //dow forever = forever;
640sD      //  reade (kywhse: lalcns) licinfo2;
640sD      //
640sD      //  if %eof(licinfo2);
640sD      //    leave;
640sD      //  endif;
640sD      //
640sD      //  if lncode = '*DATEIN';
640sD      //    datein = %dec(%subst(lnvalue:1:8):8:0);
640sD      //    leave;
640sD      //  endif;
640sD      //
640sD      //enddo;

640sA      exsr clr$licinfo;
640sA
640sA      $lnwhse  = kywhse;
640sA      $lntype  = 'P';
640sA      $lnlcns  = lalcns;
640sA
640sA      $lncodeu(1) = *on;
640sA      $lncode(1) = '*DATEIN ';
640sA      $lncseq(1) = 1;
640sA
640sA      $dricommand = '*LICINFO';
640sA      $drisubcmd  = '%GET';
640sA      $drisys2upd = 'D';
640sA      exsr zzzdrimain3;
640sA
640sA      if not main3err
640sA        and $lncodee(1) = $driok
640sA        and $lnvalnum(1) > 0
640sA        and $lnvalnum(1) < 99999999;
640sA          datein = $lnvalnum(1);
640sA      endif;

           if datein = 0;
             iter;
           endif;

           $cdcmd = '*ADD    ';
           $cddays = $saIMMDAY;
           clcdur2($cdcmd: datein: $cdtimein: $cdyears:
                    $cdmonths: $cddays: $cdhours: $cdminutes:
                    $cdseconds: $cddateout: $cdtimeout);
           expd = $cddateout;

           $slwhseu = *on;
           $slwhse  = lawhse;
           $slwhdpu = *on;
           $slwhdp  = lawhdp;
           $sldispu = *on;
           $sldisp  = ladisp;
           $slexpdu = *on;
           $slexpd  = expd;
           $slentdu = *on;
           $slentd  = laentd;
           $slprtyu = *on;
           $slprty  = laprty;
           $saToLcnsu = *on;
           $saToLcns  = lalcns;
           logit = *off;
           exsr vfySetFifo;

           if error = *off;
             #slotitem = $slitem;
             #slotflgd = $saITFLGD;
             exsr setLicFifo;
           endif;

         enddo;

       endsr;
      /end-free

     *----------------------------------------------------------------*********
     *  COMPILE TIME TABLES
     *----------------------------------------------------------------*********
**
 ABCDEFGHIJKLMNOPQRSTUVWXYZ
**
0123456789
